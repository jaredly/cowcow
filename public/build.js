/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 32);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var out_of_memory = /* tuple */[
  "Out_of_memory",
  0
];

var sys_error = /* tuple */[
  "Sys_error",
  -1
];

var failure = /* tuple */[
  "Failure",
  -2
];

var invalid_argument = /* tuple */[
  "Invalid_argument",
  -3
];

var end_of_file = /* tuple */[
  "End_of_file",
  -4
];

var division_by_zero = /* tuple */[
  "Division_by_zero",
  -5
];

var not_found = /* tuple */[
  "Not_found",
  -6
];

var match_failure = /* tuple */[
  "Match_failure",
  -7
];

var stack_overflow = /* tuple */[
  "Stack_overflow",
  -8
];

var sys_blocked_io = /* tuple */[
  "Sys_blocked_io",
  -9
];

var assert_failure = /* tuple */[
  "Assert_failure",
  -10
];

var undefined_recursive_module = /* tuple */[
  "Undefined_recursive_module",
  -11
];

out_of_memory.tag = 248;

sys_error.tag = 248;

failure.tag = 248;

invalid_argument.tag = 248;

end_of_file.tag = 248;

division_by_zero.tag = 248;

not_found.tag = 248;

match_failure.tag = 248;

stack_overflow.tag = 248;

sys_blocked_io.tag = 248;

assert_failure.tag = 248;

undefined_recursive_module.tag = 248;

exports.out_of_memory              = out_of_memory;
exports.sys_error                  = sys_error;
exports.failure                    = failure;
exports.invalid_argument           = invalid_argument;
exports.end_of_file                = end_of_file;
exports.division_by_zero           = division_by_zero;
exports.not_found                  = not_found;
exports.match_failure              = match_failure;
exports.stack_overflow             = stack_overflow;
exports.sys_blocked_io             = sys_blocked_io;
exports.assert_failure             = assert_failure;
exports.undefined_recursive_module = undefined_recursive_module;
/*  Not a pure module */


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_array = __webpack_require__(7);

function app(_f, _args) {
  while(true) {
    var args = _args;
    var f = _f;
    var arity = f.length;
    var arity$1 = arity ? arity : 1;
    var len = args.length;
    var d = arity$1 - len | 0;
    if (d) {
      if (d < 0) {
        _args = Caml_array.caml_array_sub(args, arity$1, -d | 0);
        _f = f.apply(null, Caml_array.caml_array_sub(args, 0, arity$1));
        continue ;
        
      } else {
        return (function(f,args){
        return function (x) {
          return app(f, args.concat(/* array */[x]));
        }
        }(f,args));
      }
    } else {
      return f.apply(null, args);
    }
  };
}

function curry_1(o, a0, arity) {
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[a0]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          return o(a0);
      case 2 : 
          return (function (param) {
              return o(a0, param);
            });
      case 3 : 
          return (function (param, param$1) {
              return o(a0, param, param$1);
            });
      case 4 : 
          return (function (param, param$1, param$2) {
              return o(a0, param, param$1, param$2);
            });
      case 5 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, param, param$1, param$2, param$3);
            });
      case 6 : 
          return (function (param, param$1, param$2, param$3, param$4) {
              return o(a0, param, param$1, param$2, param$3, param$4);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3, param$4, param$5) {
              return o(a0, param, param$1, param$2, param$3, param$4, param$5);
            });
      
    }
  }
}

function _1(o, a0) {
  var arity = o.length;
  if (arity === 1) {
    return o(a0);
  } else {
    return curry_1(o, a0, arity);
  }
}

function __1(o) {
  var arity = o.length;
  if (arity === 1) {
    return o;
  } else {
    return (function (a0) {
        return _1(o, a0);
      });
  }
}

function curry_2(o, a0, a1, arity) {
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          return app(o(a0), /* array */[a1]);
      case 2 : 
          return o(a0, a1);
      case 3 : 
          return (function (param) {
              return o(a0, a1, param);
            });
      case 4 : 
          return (function (param, param$1) {
              return o(a0, a1, param, param$1);
            });
      case 5 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, param, param$1, param$2);
            });
      case 6 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, a1, param, param$1, param$2, param$3);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3, param$4) {
              return o(a0, a1, param, param$1, param$2, param$3, param$4);
            });
      
    }
  }
}

function _2(o, a0, a1) {
  var arity = o.length;
  if (arity === 2) {
    return o(a0, a1);
  } else {
    return curry_2(o, a0, a1, arity);
  }
}

function __2(o) {
  var arity = o.length;
  if (arity === 2) {
    return o;
  } else {
    return (function (a0, a1) {
        return _2(o, a0, a1);
      });
  }
}

function curry_3(o, a0, a1, a2, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[a2]);
      case 3 : 
          return o(a0, a1, a2);
      case 4 : 
          return (function (param) {
              return o(a0, a1, a2, param);
            });
      case 5 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, param, param$1);
            });
      case 6 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, a2, param, param$1, param$2);
            });
      case 7 : 
          return (function (param, param$1, param$2, param$3) {
              return o(a0, a1, a2, param, param$1, param$2, param$3);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2
              ]);
  }
  
}

function _3(o, a0, a1, a2) {
  var arity = o.length;
  if (arity === 3) {
    return o(a0, a1, a2);
  } else {
    return curry_3(o, a0, a1, a2, arity);
  }
}

function __3(o) {
  var arity = o.length;
  if (arity === 3) {
    return o;
  } else {
    return (function (a0, a1, a2) {
        return _3(o, a0, a1, a2);
      });
  }
}

function curry_4(o, a0, a1, a2, a3, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[a3]);
      case 4 : 
          return o(a0, a1, a2, a3);
      case 5 : 
          return (function (param) {
              return o(a0, a1, a2, a3, param);
            });
      case 6 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, a3, param, param$1);
            });
      case 7 : 
          return (function (param, param$1, param$2) {
              return o(a0, a1, a2, a3, param, param$1, param$2);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3
              ]);
  }
  
}

function _4(o, a0, a1, a2, a3) {
  var arity = o.length;
  if (arity === 4) {
    return o(a0, a1, a2, a3);
  } else {
    return curry_4(o, a0, a1, a2, a3, arity);
  }
}

function __4(o) {
  var arity = o.length;
  if (arity === 4) {
    return o;
  } else {
    return (function (a0, a1, a2, a3) {
        return _4(o, a0, a1, a2, a3);
      });
  }
}

function curry_5(o, a0, a1, a2, a3, a4, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[a4]);
      case 5 : 
          return o(a0, a1, a2, a3, a4);
      case 6 : 
          return (function (param) {
              return o(a0, a1, a2, a3, a4, param);
            });
      case 7 : 
          return (function (param, param$1) {
              return o(a0, a1, a2, a3, a4, param, param$1);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4
              ]);
  }
  
}

function _5(o, a0, a1, a2, a3, a4) {
  var arity = o.length;
  if (arity === 5) {
    return o(a0, a1, a2, a3, a4);
  } else {
    return curry_5(o, a0, a1, a2, a3, a4, arity);
  }
}

function __5(o) {
  var arity = o.length;
  if (arity === 5) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4) {
        return _5(o, a0, a1, a2, a3, a4);
      });
  }
}

function curry_6(o, a0, a1, a2, a3, a4, a5, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[a5]);
      case 6 : 
          return o(a0, a1, a2, a3, a4, a5);
      case 7 : 
          return (function (param) {
              return o(a0, a1, a2, a3, a4, a5, param);
            });
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5
              ]);
  }
  
}

function _6(o, a0, a1, a2, a3, a4, a5) {
  var arity = o.length;
  if (arity === 6) {
    return o(a0, a1, a2, a3, a4, a5);
  } else {
    return curry_6(o, a0, a1, a2, a3, a4, a5, arity);
  }
}

function __6(o) {
  var arity = o.length;
  if (arity === 6) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5) {
        return _6(o, a0, a1, a2, a3, a4, a5);
      });
  }
}

function curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5,
                      a6
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5,
                      a6
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[
                      a5,
                      a6
                    ]);
      case 6 : 
          return app(o(a0, a1, a2, a3, a4, a5), /* array */[a6]);
      case 7 : 
          return o(a0, a1, a2, a3, a4, a5, a6);
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5,
                a6
              ]);
  }
  
}

function _7(o, a0, a1, a2, a3, a4, a5, a6) {
  var arity = o.length;
  if (arity === 7) {
    return o(a0, a1, a2, a3, a4, a5, a6);
  } else {
    return curry_7(o, a0, a1, a2, a3, a4, a5, a6, arity);
  }
}

function __7(o) {
  var arity = o.length;
  if (arity === 7) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6) {
        return _7(o, a0, a1, a2, a3, a4, a5, a6);
      });
  }
}

function curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity) {
  var exit = 0;
  if (arity > 7 || arity < 0) {
    return app(o, /* array */[
                a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7
              ]);
  } else {
    switch (arity) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      case 2 : 
          return app(o(a0, a1), /* array */[
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 3 : 
          return app(o(a0, a1, a2), /* array */[
                      a3,
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 4 : 
          return app(o(a0, a1, a2, a3), /* array */[
                      a4,
                      a5,
                      a6,
                      a7
                    ]);
      case 5 : 
          return app(o(a0, a1, a2, a3, a4), /* array */[
                      a5,
                      a6,
                      a7
                    ]);
      case 6 : 
          return app(o(a0, a1, a2, a3, a4, a5), /* array */[
                      a6,
                      a7
                    ]);
      case 7 : 
          return app(o(a0, a1, a2, a3, a4, a5, a6), /* array */[a7]);
      
    }
  }
  if (exit === 1) {
    return app(o(a0), /* array */[
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7
              ]);
  }
  
}

function _8(o, a0, a1, a2, a3, a4, a5, a6, a7) {
  var arity = o.length;
  if (arity === 8) {
    return o(a0, a1, a2, a3, a4, a5, a6, a7);
  } else {
    return curry_8(o, a0, a1, a2, a3, a4, a5, a6, a7, arity);
  }
}

function __8(o) {
  var arity = o.length;
  if (arity === 8) {
    return o;
  } else {
    return (function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return _8(o, a0, a1, a2, a3, a4, a5, a6, a7);
      });
  }
}

exports.app     = app;
exports.curry_1 = curry_1;
exports._1      = _1;
exports.__1     = __1;
exports.curry_2 = curry_2;
exports._2      = _2;
exports.__2     = __2;
exports.curry_3 = curry_3;
exports._3      = _3;
exports.__3     = __3;
exports.curry_4 = curry_4;
exports._4      = _4;
exports.__4     = __4;
exports.curry_5 = curry_5;
exports._5      = _5;
exports.__5     = __5;
exports.curry_6 = curry_6;
exports._6      = _6;
exports.__6     = __6;
exports.curry_7 = curry_7;
exports._7      = _7;
exports.__7     = __7;
exports.curry_8 = curry_8;
exports._8      = _8;
exports.__8     = __8;
/* No side effect */


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Curry                    = __webpack_require__(1);
var Caml_io                  = __webpack_require__(38);
var Caml_obj                 = __webpack_require__(4);
var Caml_sys                 = __webpack_require__(15);
var Caml_format              = __webpack_require__(8);
var Caml_string              = __webpack_require__(6);
var Caml_exceptions          = __webpack_require__(11);
var Caml_missing_polyfill    = __webpack_require__(28);
var Caml_builtin_exceptions  = __webpack_require__(0);
var CamlinternalFormatBasics = __webpack_require__(39);

function failwith(s) {
  throw [
        Caml_builtin_exceptions.failure,
        s
      ];
}

function invalid_arg(s) {
  throw [
        Caml_builtin_exceptions.invalid_argument,
        s
      ];
}

var Exit = Caml_exceptions.create("Pervasives.Exit");

function min(x, y) {
  if (Caml_obj.caml_lessequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (Caml_obj.caml_greaterequal(x, y)) {
    return x;
  } else {
    return y;
  }
}

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

function lnot(x) {
  return x ^ -1;
}

var min_int = -2147483648;

function $caret(a, b) {
  return a + b;
}

function char_of_int(n) {
  if (n < 0 || n > 255) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "char_of_int"
        ];
  } else {
    return n;
  }
}

function string_of_bool(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

function bool_of_string(param) {
  switch (param) {
    case "false" : 
        return /* false */0;
    case "true" : 
        return /* true */1;
    default:
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "bool_of_string"
          ];
  }
}

function string_of_int(param) {
  return "" + param;
}

function valid_float_lexem(s) {
  var l = s.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= l) {
      return $caret(s, ".");
    } else {
      var match = Caml_string.get(s, i);
      if (match >= 48) {
        if (match >= 58) {
          return s;
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      } else if (match !== 45) {
        return s;
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    }
  };
}

function string_of_float(f) {
  return valid_float_lexem(Caml_format.caml_format_float("%.12g", f));
}

function $at(l1, l2) {
  if (l1) {
    return /* :: */[
            l1[0],
            $at(l1[1], l2)
          ];
  } else {
    return l2;
  }
}

var stdin = Caml_io.stdin;

var stdout = Caml_io.stdout;

var stderr = Caml_io.stderr;

function open_out_gen(_, _$1, _$2) {
  return Caml_io.caml_ml_open_descriptor_out(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
}

function open_out(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_text */7,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function open_out_bin(name) {
  return open_out_gen(/* :: */[
              /* Open_wronly */1,
              /* :: */[
                /* Open_creat */3,
                /* :: */[
                  /* Open_trunc */4,
                  /* :: */[
                    /* Open_binary */6,
                    /* [] */0
                  ]
                ]
              ]
            ], 438, name);
}

function flush_all() {
  var _param = Caml_io.caml_ml_out_channels_list(/* () */0);
  while(true) {
    var param = _param;
    if (param) {
      try {
        Caml_io.caml_ml_flush(param[0]);
      }
      catch (exn){
        
      }
      _param = param[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function output_bytes(oc, s) {
  return Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output_string(oc, s) {
  return Caml_io.caml_ml_output(oc, s, 0, s.length);
}

function output(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "output"
        ];
  } else {
    return Caml_io.caml_ml_output(oc, s, ofs, len);
  }
}

function output_substring(oc, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "output_substring"
        ];
  } else {
    return Caml_io.caml_ml_output(oc, s, ofs, len);
  }
}

function output_value(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
}

function close_out(oc) {
  Caml_io.caml_ml_flush(oc);
  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
}

function close_out_noerr(oc) {
  try {
    Caml_io.caml_ml_flush(oc);
  }
  catch (exn){
    
  }
  try {
    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
  }
  catch (exn$1){
    return /* () */0;
  }
}

function open_in_gen(_, _$1, _$2) {
  return Caml_io.caml_ml_open_descriptor_in(Caml_missing_polyfill.not_implemented("caml_sys_open not implemented by bucklescript yet\n"));
}

function open_in(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_text */7,
                /* [] */0
              ]
            ], 0, name);
}

function open_in_bin(name) {
  return open_in_gen(/* :: */[
              /* Open_rdonly */0,
              /* :: */[
                /* Open_binary */6,
                /* [] */0
              ]
            ], 0, name);
}

function input(_, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "input"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
  }
}

function unsafe_really_input(_, _$1, _ofs, _len) {
  while(true) {
    var len = _len;
    var ofs = _ofs;
    if (len <= 0) {
      return /* () */0;
    } else {
      var r = Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
      if (r) {
        _len = len - r | 0;
        _ofs = ofs + r | 0;
        continue ;
        
      } else {
        throw Caml_builtin_exceptions.end_of_file;
      }
    }
  };
}

function really_input(ic, s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "really_input"
        ];
  } else {
    return unsafe_really_input(ic, s, ofs, len);
  }
}

function really_input_string(ic, len) {
  var s = Caml_string.caml_create_string(len);
  really_input(ic, s, 0, len);
  return Caml_string.bytes_to_string(s);
}

function input_line(chan) {
  var build_result = function (buf, _pos, _param) {
    while(true) {
      var param = _param;
      var pos = _pos;
      if (param) {
        var hd = param[0];
        var len = hd.length;
        Caml_string.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);
        _param = param[1];
        _pos = pos - len | 0;
        continue ;
        
      } else {
        return buf;
      }
    };
  };
  var scan = function (_accu, _len) {
    while(true) {
      var len = _len;
      var accu = _accu;
      var n = Caml_missing_polyfill.not_implemented("caml_ml_input_scan_line not implemented by bucklescript yet\n");
      if (n) {
        if (n > 0) {
          var res = Caml_string.caml_create_string(n - 1 | 0);
          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
          Caml_io.caml_ml_input_char(chan);
          if (accu) {
            var len$1 = (len + n | 0) - 1 | 0;
            return build_result(Caml_string.caml_create_string(len$1), len$1, /* :: */[
                        res,
                        accu
                      ]);
          } else {
            return res;
          }
        } else {
          var beg = Caml_string.caml_create_string(-n | 0);
          Caml_missing_polyfill.not_implemented("caml_ml_input not implemented by bucklescript yet\n");
          _len = len - n | 0;
          _accu = /* :: */[
            beg,
            accu
          ];
          continue ;
          
        }
      } else if (accu) {
        return build_result(Caml_string.caml_create_string(len), len, accu);
      } else {
        throw Caml_builtin_exceptions.end_of_file;
      }
    };
  };
  return Caml_string.bytes_to_string(scan(/* [] */0, 0));
}

function close_in_noerr() {
  try {
    return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
  }
  catch (exn){
    return /* () */0;
  }
}

function print_char(c) {
  return Caml_io.caml_ml_output_char(stdout, c);
}

function print_string(s) {
  return output_string(stdout, s);
}

function print_bytes(s) {
  return output_bytes(stdout, s);
}

function print_int(i) {
  return output_string(stdout, "" + i);
}

function print_float(f) {
  return output_string(stdout, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function print_endline(param) {
  console.log(param);
  return 0;
}

function print_newline() {
  Caml_io.caml_ml_output_char(stdout, /* "\n" */10);
  return Caml_io.caml_ml_flush(stdout);
}

function prerr_char(c) {
  return Caml_io.caml_ml_output_char(stderr, c);
}

function prerr_string(s) {
  return output_string(stderr, s);
}

function prerr_bytes(s) {
  return output_bytes(stderr, s);
}

function prerr_int(i) {
  return output_string(stderr, "" + i);
}

function prerr_float(f) {
  return output_string(stderr, valid_float_lexem(Caml_format.caml_format_float("%.12g", f)));
}

function prerr_endline(param) {
  console.error(param);
  return 0;
}

function prerr_newline() {
  Caml_io.caml_ml_output_char(stderr, /* "\n" */10);
  return Caml_io.caml_ml_flush(stderr);
}

function read_line() {
  Caml_io.caml_ml_flush(stdout);
  return input_line(stdin);
}

function read_int() {
  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function read_float() {
  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));
}

function string_of_format(param) {
  return param[1];
}

function $caret$caret(param, param$1) {
  return /* Format */[
          CamlinternalFormatBasics.concat_fmt(param[0], param$1[0]),
          $caret(param[1], $caret("%,", param$1[1]))
        ];
}

var exit_function = [flush_all];

function at_exit(f) {
  var g = exit_function[0];
  exit_function[0] = (function () {
      Curry._1(f, /* () */0);
      return Curry._1(g, /* () */0);
    });
  return /* () */0;
}

function do_at_exit() {
  return Curry._1(exit_function[0], /* () */0);
}

function exit(retcode) {
  do_at_exit(/* () */0);
  return Caml_sys.caml_sys_exit(retcode);
}

var max_int = 2147483647;

var infinity = Infinity;

var neg_infinity = -Infinity;

var nan = NaN;

var max_float = Number.MAX_VALUE;

var min_float = Number.MIN_VALUE;

var epsilon_float = 2.220446049250313e-16;

var flush = Caml_io.caml_ml_flush;

var output_char = Caml_io.caml_ml_output_char;

var output_byte = Caml_io.caml_ml_output_char;

function output_binary_int(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_output_int not implemented by bucklescript yet\n");
}

function seek_out(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out not implemented by bucklescript yet\n");
}

function pos_out() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out not implemented by bucklescript yet\n");
}

function out_channel_length() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
}

function set_binary_mode_out(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
}

var input_char = Caml_io.caml_ml_input_char;

var input_byte = Caml_io.caml_ml_input_char;

function input_binary_int() {
  return Caml_missing_polyfill.not_implemented("caml_ml_input_int not implemented by bucklescript yet\n");
}

function input_value() {
  return Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
}

function seek_in(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in not implemented by bucklescript yet\n");
}

function pos_in() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in not implemented by bucklescript yet\n");
}

function in_channel_length() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size not implemented by bucklescript yet\n");
}

function close_in() {
  return Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
}

function set_binary_mode_in(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_set_binary_mode not implemented by bucklescript yet\n");
}

function LargeFile_000(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_out_64 not implemented by bucklescript yet\n");
}

function LargeFile_001() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_out_64 not implemented by bucklescript yet\n");
}

function LargeFile_002() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
}

function LargeFile_003(_, _$1) {
  return Caml_missing_polyfill.not_implemented("caml_ml_seek_in_64 not implemented by bucklescript yet\n");
}

function LargeFile_004() {
  return Caml_missing_polyfill.not_implemented("caml_ml_pos_in_64 not implemented by bucklescript yet\n");
}

function LargeFile_005() {
  return Caml_missing_polyfill.not_implemented("caml_ml_channel_size_64 not implemented by bucklescript yet\n");
}

var LargeFile = [
  LargeFile_000,
  LargeFile_001,
  LargeFile_002,
  LargeFile_003,
  LargeFile_004,
  LargeFile_005
];

exports.invalid_arg         = invalid_arg;
exports.failwith            = failwith;
exports.Exit                = Exit;
exports.min                 = min;
exports.max                 = max;
exports.abs                 = abs;
exports.max_int             = max_int;
exports.min_int             = min_int;
exports.lnot                = lnot;
exports.infinity            = infinity;
exports.neg_infinity        = neg_infinity;
exports.nan                 = nan;
exports.max_float           = max_float;
exports.min_float           = min_float;
exports.epsilon_float       = epsilon_float;
exports.$caret              = $caret;
exports.char_of_int         = char_of_int;
exports.string_of_bool      = string_of_bool;
exports.bool_of_string      = bool_of_string;
exports.string_of_int       = string_of_int;
exports.string_of_float     = string_of_float;
exports.$at                 = $at;
exports.stdin               = stdin;
exports.stdout              = stdout;
exports.stderr              = stderr;
exports.print_char          = print_char;
exports.print_string        = print_string;
exports.print_bytes         = print_bytes;
exports.print_int           = print_int;
exports.print_float         = print_float;
exports.print_endline       = print_endline;
exports.print_newline       = print_newline;
exports.prerr_char          = prerr_char;
exports.prerr_string        = prerr_string;
exports.prerr_bytes         = prerr_bytes;
exports.prerr_int           = prerr_int;
exports.prerr_float         = prerr_float;
exports.prerr_endline       = prerr_endline;
exports.prerr_newline       = prerr_newline;
exports.read_line           = read_line;
exports.read_int            = read_int;
exports.read_float          = read_float;
exports.open_out            = open_out;
exports.open_out_bin        = open_out_bin;
exports.open_out_gen        = open_out_gen;
exports.flush               = flush;
exports.flush_all           = flush_all;
exports.output_char         = output_char;
exports.output_string       = output_string;
exports.output_bytes        = output_bytes;
exports.output              = output;
exports.output_substring    = output_substring;
exports.output_byte         = output_byte;
exports.output_binary_int   = output_binary_int;
exports.output_value        = output_value;
exports.seek_out            = seek_out;
exports.pos_out             = pos_out;
exports.out_channel_length  = out_channel_length;
exports.close_out           = close_out;
exports.close_out_noerr     = close_out_noerr;
exports.set_binary_mode_out = set_binary_mode_out;
exports.open_in             = open_in;
exports.open_in_bin         = open_in_bin;
exports.open_in_gen         = open_in_gen;
exports.input_char          = input_char;
exports.input_line          = input_line;
exports.input               = input;
exports.really_input        = really_input;
exports.really_input_string = really_input_string;
exports.input_byte          = input_byte;
exports.input_binary_int    = input_binary_int;
exports.input_value         = input_value;
exports.seek_in             = seek_in;
exports.pos_in              = pos_in;
exports.in_channel_length   = in_channel_length;
exports.close_in            = close_in;
exports.close_in_noerr      = close_in_noerr;
exports.set_binary_mode_in  = set_binary_mode_in;
exports.LargeFile           = LargeFile;
exports.string_of_format    = string_of_format;
exports.$caret$caret        = $caret$caret;
exports.exit                = exit;
exports.at_exit             = at_exit;
exports.valid_float_lexem   = valid_float_lexem;
exports.unsafe_really_input = unsafe_really_input;
exports.do_at_exit          = do_at_exit;
/* No side effect */


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Block                   = __webpack_require__(25);
var Caml_builtin_exceptions = __webpack_require__(0);

function caml_obj_dup(x) {
  var len = x.length;
  var v = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    v[i] = x[i];
  }
  v.tag = x.tag | 0;
  return v;
}

function caml_obj_truncate(x, new_size) {
  var len = x.length;
  if (new_size <= 0 || new_size > len) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Obj.truncate"
        ];
  } else if (len !== new_size) {
    for(var i = new_size ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      x[i] = 0;
    }
    x.length = new_size;
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_lazy_make_forward(x) {
  return Block.__(250, [x]);
}

function caml_update_dummy(x, y) {
  var len = y.length;
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    x[i] = y[i];
  }
  var y_tag = y.tag | 0;
  if (y_tag !== 0) {
    x.tag = y_tag;
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_int_compare(x, y) {
  if (x < y) {
    return -1;
  } else if (x === y) {
    return 0;
  } else {
    return 1;
  }
}

function caml_compare(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    var a_type = typeof a;
    var b_type = typeof b;
    if (a_type === "string") {
      var x = a;
      var y = b;
      if (x < y) {
        return -1;
      } else if (x === y) {
        return 0;
      } else {
        return 1;
      }
    } else {
      var is_a_number = +(a_type === "number");
      var is_b_number = +(b_type === "number");
      if (is_a_number !== 0) {
        if (is_b_number !== 0) {
          return caml_int_compare(a, b);
        } else {
          return -1;
        }
      } else if (is_b_number !== 0) {
        return 1;
      } else if (a_type === "boolean" || a_type === "undefined" || a === null) {
        var x$1 = a;
        var y$1 = b;
        if (x$1 === y$1) {
          return 0;
        } else if (x$1 < y$1) {
          return -1;
        } else {
          return 1;
        }
      } else if (a_type === "function" || b_type === "function") {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "compare: functional value"
            ];
      } else {
        var tag_a = a.tag | 0;
        var tag_b = b.tag | 0;
        if (tag_a === 250) {
          _a = a[0];
          continue ;
          
        } else if (tag_b === 250) {
          _b = b[0];
          continue ;
          
        } else if (tag_a === 248) {
          return caml_int_compare(a[1], b[1]);
        } else if (tag_a === 251) {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "equal: abstract value"
              ];
        } else if (tag_a !== tag_b) {
          if (tag_a < tag_b) {
            return -1;
          } else {
            return 1;
          }
        } else {
          var len_a = a.length;
          var len_b = b.length;
          if (len_a === len_b) {
            var a$1 = a;
            var b$1 = b;
            var _i = 0;
            var same_length = len_a;
            while(true) {
              var i = _i;
              if (i === same_length) {
                return 0;
              } else {
                var res = caml_compare(a$1[i], b$1[i]);
                if (res !== 0) {
                  return res;
                } else {
                  _i = i + 1 | 0;
                  continue ;
                  
                }
              }
            };
          } else if (len_a < len_b) {
            var a$2 = a;
            var b$2 = b;
            var _i$1 = 0;
            var short_length = len_a;
            while(true) {
              var i$1 = _i$1;
              if (i$1 === short_length) {
                return -1;
              } else {
                var res$1 = caml_compare(a$2[i$1], b$2[i$1]);
                if (res$1 !== 0) {
                  return res$1;
                } else {
                  _i$1 = i$1 + 1 | 0;
                  continue ;
                  
                }
              }
            };
          } else {
            var a$3 = a;
            var b$3 = b;
            var _i$2 = 0;
            var short_length$1 = len_b;
            while(true) {
              var i$2 = _i$2;
              if (i$2 === short_length$1) {
                return 1;
              } else {
                var res$2 = caml_compare(a$3[i$2], b$3[i$2]);
                if (res$2 !== 0) {
                  return res$2;
                } else {
                  _i$2 = i$2 + 1 | 0;
                  continue ;
                  
                }
              }
            };
          }
        }
      }
    }
  };
}

function caml_equal(_a, _b) {
  while(true) {
    var b = _b;
    var a = _a;
    if (a === b) {
      return /* true */1;
    } else {
      var a_type = typeof a;
      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
        return /* false */0;
      } else {
        var b_type = typeof b;
        if (a_type === "function" || b_type === "function") {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "equal: functional value"
              ];
        } else if (b_type === "number" || b_type === "undefined" || b === null) {
          return /* false */0;
        } else {
          var tag_a = a.tag | 0;
          var tag_b = b.tag | 0;
          if (tag_a === 250) {
            _a = a[0];
            continue ;
            
          } else if (tag_b === 250) {
            _b = b[0];
            continue ;
            
          } else if (tag_a === 248) {
            return +(a[1] === b[1]);
          } else if (tag_a === 251) {
            throw [
                  Caml_builtin_exceptions.invalid_argument,
                  "equal: abstract value"
                ];
          } else if (tag_a !== tag_b) {
            return /* false */0;
          } else {
            var len_a = a.length;
            var len_b = b.length;
            if (len_a === len_b) {
              var a$1 = a;
              var b$1 = b;
              var _i = 0;
              var same_length = len_a;
              while(true) {
                var i = _i;
                if (i === same_length) {
                  return /* true */1;
                } else if (caml_equal(a$1[i], b$1[i])) {
                  _i = i + 1 | 0;
                  continue ;
                  
                } else {
                  return /* false */0;
                }
              };
            } else {
              return /* false */0;
            }
          }
        }
      }
    }
  };
}

function caml_notequal(a, b) {
  return 1 - caml_equal(a, b);
}

function caml_greaterequal(a, b) {
  return +(caml_compare(a, b) >= 0);
}

function caml_greaterthan(a, b) {
  return +(caml_compare(a, b) > 0);
}

function caml_lessequal(a, b) {
  return +(caml_compare(a, b) <= 0);
}

function caml_lessthan(a, b) {
  return +(caml_compare(a, b) < 0);
}

var caml_int32_compare = caml_int_compare;

var caml_nativeint_compare = caml_int_compare;

exports.caml_obj_dup           = caml_obj_dup;
exports.caml_obj_truncate      = caml_obj_truncate;
exports.caml_lazy_make_forward = caml_lazy_make_forward;
exports.caml_update_dummy      = caml_update_dummy;
exports.caml_int_compare       = caml_int_compare;
exports.caml_int32_compare     = caml_int32_compare;
exports.caml_nativeint_compare = caml_nativeint_compare;
exports.caml_compare           = caml_compare;
exports.caml_equal             = caml_equal;
exports.caml_notequal          = caml_notequal;
exports.caml_greaterequal      = caml_greaterequal;
exports.caml_greaterthan       = caml_greaterthan;
exports.caml_lessthan          = caml_lessthan;
exports.caml_lessequal         = caml_lessequal;
/* No side effect */


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_builtin_exceptions = __webpack_require__(0);

function div(x, y) {
  if (y === 0) {
    throw Caml_builtin_exceptions.division_by_zero;
  } else {
    return x / y | 0;
  }
}

function mod_(x, y) {
  if (y === 0) {
    throw Caml_builtin_exceptions.division_by_zero;
  } else {
    return x % y;
  }
}

function caml_bswap16(x) {
  return ((x & 255) << 8) | ((x & 65280) >>> 8);
}

function caml_int32_bswap(x) {
  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & 4278190080) >>> 24);
}

var imul = ( Math.imul || function (x,y) {
  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
}
);

var caml_nativeint_bswap = caml_int32_bswap;

exports.div                  = div;
exports.mod_                 = mod_;
exports.caml_bswap16         = caml_bswap16;
exports.caml_int32_bswap     = caml_int32_bswap;
exports.caml_nativeint_bswap = caml_nativeint_bswap;
exports.imul                 = imul;
/* imul Not a pure module */


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_builtin_exceptions = __webpack_require__(0);

function string_of_char(prim) {
  return String.fromCharCode(prim);
}

function caml_string_get(s, i) {
  if (i >= s.length || i < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return s.charCodeAt(i);
  }
}

function caml_create_string(len) {
  if (len < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.create"
        ];
  } else {
    return new Array(len);
  }
}

function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

function caml_fill_string(s, i, l, c) {
  if (l > 0) {
    for(var k = i ,k_finish = (l + i | 0) - 1 | 0; k <= k_finish; ++k){
      s[k] = c;
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function caml_blit_string(s1, i1, s2, i2, len) {
  if (len > 0) {
    var off1 = s1.length - i1 | 0;
    if (len <= off1) {
      for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
        s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
      }
      return /* () */0;
    } else {
      for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
        s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
      }
      for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
        s2[i2 + i$2 | 0] = /* "\000" */0;
      }
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len > 0) {
    if (s1 === s2) {
      var s1$1 = s1;
      var i1$1 = i1;
      var i2$1 = i2;
      var len$1 = len;
      if (i1$1 < i2$1) {
        var range_a = (s1$1.length - i2$1 | 0) - 1 | 0;
        var range_b = len$1 - 1 | 0;
        var range = range_a > range_b ? range_b : range_a;
        for(var j = range; j >= 0; --j){
          s1$1[i2$1 + j | 0] = s1$1[i1$1 + j | 0];
        }
        return /* () */0;
      } else if (i1$1 > i2$1) {
        var range_a$1 = (s1$1.length - i1$1 | 0) - 1 | 0;
        var range_b$1 = len$1 - 1 | 0;
        var range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
        for(var k = 0; k <= range$1; ++k){
          s1$1[i2$1 + k | 0] = s1$1[i1$1 + k | 0];
        }
        return /* () */0;
      } else {
        return 0;
      }
    } else {
      var off1 = s1.length - i1 | 0;
      if (len <= off1) {
        for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
          s2[i2 + i | 0] = s1[i1 + i | 0];
        }
        return /* () */0;
      } else {
        for(var i$1 = 0 ,i_finish$1 = off1 - 1 | 0; i$1 <= i_finish$1; ++i$1){
          s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
        }
        for(var i$2 = off1 ,i_finish$2 = len - 1 | 0; i$2 <= i_finish$2; ++i$2){
          s2[i2 + i$2 | 0] = /* "\000" */0;
        }
        return /* () */0;
      }
    }
  } else {
    return 0;
  }
}

function bytes_of_string(s) {
  var len = s.length;
  var res = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    res[i] = s.charCodeAt(i);
  }
  return res;
}

function bytes_to_string(a) {
  var bytes = a;
  var i = 0;
  var len = a.length;
  var s = "";
  var s_len = len;
  if (i === 0 && len <= 4096 && len === bytes.length) {
    return String.fromCharCode.apply(null,bytes);
  } else {
    var offset = 0;
    while(s_len > 0) {
      var next = s_len < 1024 ? s_len : 1024;
      var tmp_bytes = new Array(next);
      caml_blit_bytes(bytes, offset, tmp_bytes, 0, next);
      s = s + String.fromCharCode.apply(null,tmp_bytes);
      s_len = s_len - next | 0;
      offset = offset + next | 0;
    };
    return s;
  }
}

function caml_string_of_char_array(chars) {
  var len = chars.length;
  var bytes = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    bytes[i] = chars[i];
  }
  return bytes_to_string(bytes);
}

function caml_is_printable(c) {
  if (c > 31) {
    return +(c < 127);
  } else {
    return /* false */0;
  }
}

function caml_string_get16(s, i) {
  return s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0;
}

function caml_string_get32(s, i) {
  return ((s.charCodeAt(i) + (s.charCodeAt(i + 1 | 0) << 8) | 0) + (s.charCodeAt(i + 2 | 0) << 16) | 0) + (s.charCodeAt(i + 3 | 0) << 24) | 0;
}

function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return s.charCodeAt(i);
  }
}

exports.bytes_of_string           = bytes_of_string;
exports.bytes_to_string           = bytes_to_string;
exports.caml_is_printable         = caml_is_printable;
exports.caml_string_of_char_array = caml_string_of_char_array;
exports.caml_string_get           = caml_string_get;
exports.caml_string_compare       = caml_string_compare;
exports.caml_create_string        = caml_create_string;
exports.caml_fill_string          = caml_fill_string;
exports.caml_blit_string          = caml_blit_string;
exports.caml_blit_bytes           = caml_blit_bytes;
exports.caml_string_get16         = caml_string_get16;
exports.caml_string_get32         = caml_string_get32;
exports.string_of_char            = string_of_char;
exports.get                       = get;
/* No side effect */


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_builtin_exceptions = __webpack_require__(0);

function caml_array_sub(x, offset, len) {
  var result = new Array(len);
  var j = 0;
  var i = offset;
  while(j < len) {
    result[j] = x[i];
    j = j + 1 | 0;
    i = i + 1 | 0;
  };
  return result;
}

function len(_acc, _l) {
  while(true) {
    var l = _l;
    var acc = _acc;
    if (l) {
      _l = l[1];
      _acc = l[0].length + acc | 0;
      continue ;
      
    } else {
      return acc;
    }
  };
}

function fill(arr, _i, _l) {
  while(true) {
    var l = _l;
    var i = _i;
    if (l) {
      var x = l[0];
      var l$1 = x.length;
      var k = i;
      var j = 0;
      while(j < l$1) {
        arr[k] = x[j];
        k = k + 1 | 0;
        j = j + 1 | 0;
      };
      _l = l[1];
      _i = k;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function caml_array_concat(l) {
  var v = len(0, l);
  var result = new Array(v);
  fill(result, 0, l);
  return result;
}

function caml_array_set(xs, index, newval) {
  if (index < 0 || index >= xs.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    xs[index] = newval;
    return /* () */0;
  }
}

function caml_array_get(xs, index) {
  if (index < 0 || index >= xs.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "index out of bounds"
        ];
  } else {
    return xs[index];
  }
}

function caml_make_vect(len, init) {
  var b = new Array(len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    b[i] = init;
  }
  return b;
}

function caml_array_blit(a1, i1, a2, i2, len) {
  if (i2 <= i1) {
    for(var j = 0 ,j_finish = len - 1 | 0; j <= j_finish; ++j){
      a2[j + i2 | 0] = a1[j + i1 | 0];
    }
    return /* () */0;
  } else {
    for(var j$1 = len - 1 | 0; j$1 >= 0; --j$1){
      a2[j$1 + i2 | 0] = a1[j$1 + i1 | 0];
    }
    return /* () */0;
  }
}

exports.caml_array_sub    = caml_array_sub;
exports.caml_array_concat = caml_array_concat;
exports.caml_make_vect    = caml_make_vect;
exports.caml_array_blit   = caml_array_blit;
exports.caml_array_get    = caml_array_get;
exports.caml_array_set    = caml_array_set;
/* No side effect */


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Curry                   = __webpack_require__(1);
var Caml_int32              = __webpack_require__(5);
var Caml_int64              = __webpack_require__(16);
var Caml_utils              = __webpack_require__(26);
var Caml_builtin_exceptions = __webpack_require__(0);

function caml_failwith(s) {
  throw [
        Caml_builtin_exceptions.failure,
        s
      ];
}

function parse_digit(c) {
  if (c >= 65) {
    if (c >= 97) {
      if (c >= 123) {
        return -1;
      } else {
        return c - 87 | 0;
      }
    } else if (c >= 91) {
      return -1;
    } else {
      return c - 55 | 0;
    }
  } else if (c > 57 || c < 48) {
    return -1;
  } else {
    return c - /* "0" */48 | 0;
  }
}

function int_of_string_base(param) {
  switch (param) {
    case 0 : 
        return 8;
    case 1 : 
        return 16;
    case 2 : 
        return 10;
    case 3 : 
        return 2;
    
  }
}

function parse_sign_and_base(s) {
  var sign = 1;
  var base = /* Dec */2;
  var i = 0;
  if (s[i] === "-") {
    sign = -1;
    i = i + 1 | 0;
  }
  var match = s.charCodeAt(i);
  var match$1 = s.charCodeAt(i + 1 | 0);
  if (match === 48) {
    if (match$1 >= 89) {
      if (match$1 !== 98) {
        if (match$1 !== 111) {
          if (match$1 === 120) {
            base = /* Hex */1;
            i = i + 2 | 0;
          }
          
        } else {
          base = /* Oct */0;
          i = i + 2 | 0;
        }
      } else {
        base = /* Bin */3;
        i = i + 2 | 0;
      }
    } else if (match$1 !== 66) {
      if (match$1 !== 79) {
        if (match$1 >= 88) {
          base = /* Hex */1;
          i = i + 2 | 0;
        }
        
      } else {
        base = /* Oct */0;
        i = i + 2 | 0;
      }
    } else {
      base = /* Bin */3;
      i = i + 2 | 0;
    }
  }
  return /* tuple */[
          i,
          sign,
          base
        ];
}

function caml_int_of_string(s) {
  var match = parse_sign_and_base(s);
  var i = match[0];
  var base = int_of_string_base(match[2]);
  var threshold = 4294967295;
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = parse_digit(c);
  if (d < 0 || d >= base) {
    throw [
          Caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
          
        } else {
          var v = parse_digit(a);
          if (v < 0 || v >= base) {
            throw [
                  Caml_builtin_exceptions.failure,
                  "int_of_string"
                ];
          } else {
            var acc$1 = base * acc + v;
            if (acc$1 > threshold) {
              throw [
                    Caml_builtin_exceptions.failure,
                    "int_of_string"
                  ];
            } else {
              _k = k + 1 | 0;
              _acc = acc$1;
              continue ;
              
            }
          }
        }
      }
    };
  };
  var res = match[1] * aux(d, i + 1 | 0);
  var or_res = res | 0;
  if (base === 10 && res !== or_res) {
    throw [
          Caml_builtin_exceptions.failure,
          "int_of_string"
        ];
  }
  return or_res;
}

function caml_int64_of_string(s) {
  var match = parse_sign_and_base(s);
  var hbase = match[2];
  var i = match[0];
  var base = Caml_int64.of_int32(int_of_string_base(hbase));
  var sign = Caml_int64.of_int32(match[1]);
  var threshold;
  switch (hbase) {
    case 0 : 
        threshold = /* int64 */[
          /* hi */536870911,
          /* lo */4294967295
        ];
        break;
    case 1 : 
        threshold = /* int64 */[
          /* hi */268435455,
          /* lo */4294967295
        ];
        break;
    case 2 : 
        threshold = /* int64 */[
          /* hi */429496729,
          /* lo */2576980377
        ];
        break;
    case 3 : 
        threshold = /* int64 */[
          /* hi */2147483647,
          /* lo */4294967295
        ];
        break;
    
  }
  var len = s.length;
  var c = i < len ? s.charCodeAt(i) : /* "\000" */0;
  var d = Caml_int64.of_int32(parse_digit(c));
  if (Caml_int64.lt(d, /* int64 */[
          /* hi */0,
          /* lo */0
        ]) || Caml_int64.ge(d, base)) {
    throw [
          Caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  var aux = function (_acc, _k) {
    while(true) {
      var k = _k;
      var acc = _acc;
      if (k === len) {
        return acc;
      } else {
        var a = s.charCodeAt(k);
        if (a === /* "_" */95) {
          _k = k + 1 | 0;
          continue ;
          
        } else {
          var v = Caml_int64.of_int32(parse_digit(a));
          if (Caml_int64.lt(v, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ]) || Caml_int64.ge(v, base) || Caml_int64.gt(acc, threshold)) {
            throw [
                  Caml_builtin_exceptions.failure,
                  "int64_of_string"
                ];
          } else {
            var acc$1 = Caml_int64.add(Caml_int64.mul(base, acc), v);
            _k = k + 1 | 0;
            _acc = acc$1;
            continue ;
            
          }
        }
      }
    };
  };
  var res = Caml_int64.mul(sign, aux(d, i + 1 | 0));
  var or_res = Caml_int64.or_(res, /* int64 */[
        /* hi */0,
        /* lo */0
      ]);
  if (Caml_int64.eq(base, /* int64 */[
          /* hi */0,
          /* lo */10
        ]) && Caml_int64.neq(res, or_res)) {
    throw [
          Caml_builtin_exceptions.failure,
          "int64_of_string"
        ];
  }
  return or_res;
}

function int_of_base(param) {
  switch (param) {
    case 0 : 
        return 8;
    case 1 : 
        return 16;
    case 2 : 
        return 10;
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function parse_format(fmt) {
  var len = fmt.length;
  if (len > 31) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "format_int: format too long"
        ];
  }
  var f = /* record */[
    /* justify */"+",
    /* signstyle */"-",
    /* filter */" ",
    /* alternate : false */0,
    /* base : Dec */2,
    /* signedconv : false */0,
    /* width */0,
    /* uppercase : false */0,
    /* sign */1,
    /* prec */-1,
    /* conv */"f"
  ];
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return f;
    } else {
      var c = fmt.charCodeAt(i);
      var exit = 0;
      if (c >= 69) {
        if (c >= 88) {
          if (c >= 121) {
            exit = 1;
          } else {
            switch (c - 88 | 0) {
              case 0 : 
                  f[/* base */4] = /* Hex */1;
                  f[/* uppercase */7] = /* true */1;
                  _i = i + 1 | 0;
                  continue ;
                  case 13 : 
              case 14 : 
              case 15 : 
                  exit = 5;
                  break;
              case 12 : 
              case 17 : 
                  exit = 4;
                  break;
              case 23 : 
                  f[/* base */4] = /* Oct */0;
                  _i = i + 1 | 0;
                  continue ;
                  case 29 : 
                  f[/* base */4] = /* Dec */2;
                  _i = i + 1 | 0;
                  continue ;
                  case 1 : 
              case 2 : 
              case 3 : 
              case 4 : 
              case 5 : 
              case 6 : 
              case 7 : 
              case 8 : 
              case 9 : 
              case 10 : 
              case 11 : 
              case 16 : 
              case 18 : 
              case 19 : 
              case 20 : 
              case 21 : 
              case 22 : 
              case 24 : 
              case 25 : 
              case 26 : 
              case 27 : 
              case 28 : 
              case 30 : 
              case 31 : 
                  exit = 1;
                  break;
              case 32 : 
                  f[/* base */4] = /* Hex */1;
                  _i = i + 1 | 0;
                  continue ;
                  
            }
          }
        } else if (c >= 72) {
          exit = 1;
        } else {
          f[/* signedconv */5] = /* true */1;
          f[/* uppercase */7] = /* true */1;
          f[/* conv */10] = String.fromCharCode(lowercase(c));
          _i = i + 1 | 0;
          continue ;
          
        }
      } else {
        var switcher = c - 32 | 0;
        if (switcher > 25 || switcher < 0) {
          exit = 1;
        } else {
          switch (switcher) {
            case 3 : 
                f[/* alternate */3] = /* true */1;
                _i = i + 1 | 0;
                continue ;
                case 0 : 
            case 11 : 
                exit = 2;
                break;
            case 13 : 
                f[/* justify */0] = "-";
                _i = i + 1 | 0;
                continue ;
                case 14 : 
                f[/* prec */9] = 0;
                var j = i + 1 | 0;
                while((function(j){
                    return function () {
                      var w = fmt.charCodeAt(j) - /* "0" */48 | 0;
                      return +(w >= 0 && w <= 9);
                    }
                    }(j))()) {
                  f[/* prec */9] = (Caml_int32.imul(f[/* prec */9], 10) + fmt.charCodeAt(j) | 0) - /* "0" */48 | 0;
                  j = j + 1 | 0;
                };
                _i = j;
                continue ;
                case 1 : 
            case 2 : 
            case 4 : 
            case 5 : 
            case 6 : 
            case 7 : 
            case 8 : 
            case 9 : 
            case 10 : 
            case 12 : 
            case 15 : 
                exit = 1;
                break;
            case 16 : 
                f[/* filter */2] = "0";
                _i = i + 1 | 0;
                continue ;
                case 17 : 
            case 18 : 
            case 19 : 
            case 20 : 
            case 21 : 
            case 22 : 
            case 23 : 
            case 24 : 
            case 25 : 
                exit = 3;
                break;
            
          }
        }
      }
      switch (exit) {
        case 1 : 
            _i = i + 1 | 0;
            continue ;
            case 2 : 
            f[/* signstyle */1] = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
            case 3 : 
            f[/* width */6] = 0;
            var j$1 = i;
            while((function(j$1){
                return function () {
                  var w = fmt.charCodeAt(j$1) - /* "0" */48 | 0;
                  return +(w >= 0 && w <= 9);
                }
                }(j$1))()) {
              f[/* width */6] = (Caml_int32.imul(f[/* width */6], 10) + fmt.charCodeAt(j$1) | 0) - /* "0" */48 | 0;
              j$1 = j$1 + 1 | 0;
            };
            _i = j$1;
            continue ;
            case 4 : 
            f[/* signedconv */5] = /* true */1;
            f[/* base */4] = /* Dec */2;
            _i = i + 1 | 0;
            continue ;
            case 5 : 
            f[/* signedconv */5] = /* true */1;
            f[/* conv */10] = String.fromCharCode(c);
            _i = i + 1 | 0;
            continue ;
            
      }
    }
  };
}

function finish_formatting(param, rawbuffer) {
  var justify = param[/* justify */0];
  var signstyle = param[/* signstyle */1];
  var filter = param[/* filter */2];
  var alternate = param[/* alternate */3];
  var base = param[/* base */4];
  var signedconv = param[/* signedconv */5];
  var width = param[/* width */6];
  var uppercase = param[/* uppercase */7];
  var sign = param[/* sign */8];
  var len = rawbuffer.length;
  if (signedconv && (sign < 0 || signstyle !== "-")) {
    len = len + 1 | 0;
  }
  if (alternate) {
    if (base) {
      if (base === /* Hex */1) {
        len = len + 2 | 0;
      }
      
    } else {
      len = len + 1 | 0;
    }
  }
  var buffer = "";
  if (justify === "+" && filter === " ") {
    for(var i = len ,i_finish = width - 1 | 0; i <= i_finish; ++i){
      buffer = buffer + filter;
    }
  }
  if (signedconv) {
    if (sign < 0) {
      buffer = buffer + "-";
    } else if (signstyle !== "-") {
      buffer = buffer + signstyle;
    }
    
  }
  if (alternate && base === /* Oct */0) {
    buffer = buffer + "0";
  }
  if (alternate && base === /* Hex */1) {
    buffer = buffer + "0x";
  }
  if (justify === "+" && filter === "0") {
    for(var i$1 = len ,i_finish$1 = width - 1 | 0; i$1 <= i_finish$1; ++i$1){
      buffer = buffer + filter;
    }
  }
  buffer = uppercase ? buffer + rawbuffer.toUpperCase() : buffer + rawbuffer;
  if (justify === "-") {
    for(var i$2 = len ,i_finish$2 = width - 1 | 0; i$2 <= i_finish$2; ++i$2){
      buffer = buffer + " ";
    }
  }
  return buffer;
}

function caml_format_int(fmt, i) {
  if (fmt === "%d") {
    return String(i);
  } else {
    var f = parse_format(fmt);
    var f$1 = f;
    var i$1 = i;
    var i$2 = i$1 < 0 ? (
        f$1[/* signedconv */5] ? (f$1[/* sign */8] = -1, -i$1) : (i$1 >>> 0)
      ) : i$1;
    var s = i$2.toString(int_of_base(f$1[/* base */4]));
    if (f$1[/* prec */9] >= 0) {
      f$1[/* filter */2] = " ";
      var n = f$1[/* prec */9] - s.length | 0;
      if (n > 0) {
        s = Caml_utils.repeat(n, "0") + s;
      }
      
    }
    return finish_formatting(f$1, s);
  }
}

function caml_int64_format(fmt, x) {
  var f = parse_format(fmt);
  var x$1 = f[/* signedconv */5] && Caml_int64.lt(x, /* int64 */[
        /* hi */0,
        /* lo */0
      ]) ? (f[/* sign */8] = -1, Caml_int64.neg(x)) : x;
  var s = "";
  var match = f[/* base */4];
  switch (match) {
    case 0 : 
        var wbase = /* int64 */[
          /* hi */0,
          /* lo */8
        ];
        var cvtbl = "01234567";
        if (Caml_int64.lt(x$1, /* int64 */[
                /* hi */0,
                /* lo */0
              ])) {
          var y = Caml_int64.discard_sign(x$1);
          var match$1 = Caml_int64.div_mod(y, wbase);
          var quotient = Caml_int64.add(/* int64 */[
                /* hi */268435456,
                /* lo */0
              ], match$1[0]);
          var modulus = match$1[1];
          s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
          while(Caml_int64.neq(quotient, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$2 = Caml_int64.div_mod(quotient, wbase);
            quotient = match$2[0];
            modulus = match$2[1];
            s = String.fromCharCode(cvtbl.charCodeAt(modulus[1] | 0)) + s;
          };
        } else {
          var match$3 = Caml_int64.div_mod(x$1, wbase);
          var quotient$1 = match$3[0];
          var modulus$1 = match$3[1];
          s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
          while(Caml_int64.neq(quotient$1, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$4 = Caml_int64.div_mod(quotient$1, wbase);
            quotient$1 = match$4[0];
            modulus$1 = match$4[1];
            s = String.fromCharCode(cvtbl.charCodeAt(modulus$1[1] | 0)) + s;
          };
        }
        break;
    case 1 : 
        s = Caml_int64.to_hex(x$1) + s;
        break;
    case 2 : 
        var wbase$1 = /* int64 */[
          /* hi */0,
          /* lo */10
        ];
        var cvtbl$1 = "0123456789";
        if (Caml_int64.lt(x$1, /* int64 */[
                /* hi */0,
                /* lo */0
              ])) {
          var y$1 = Caml_int64.discard_sign(x$1);
          var match$5 = Caml_int64.div_mod(y$1, wbase$1);
          var match$6 = Caml_int64.div_mod(Caml_int64.add(/* int64 */[
                    /* hi */0,
                    /* lo */8
                  ], match$5[1]), wbase$1);
          var quotient$2 = Caml_int64.add(Caml_int64.add(/* int64 */[
                    /* hi */214748364,
                    /* lo */3435973836
                  ], match$5[0]), match$6[0]);
          var modulus$2 = match$6[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
          while(Caml_int64.neq(quotient$2, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$7 = Caml_int64.div_mod(quotient$2, wbase$1);
            quotient$2 = match$7[0];
            modulus$2 = match$7[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$2[1] | 0)) + s;
          };
        } else {
          var match$8 = Caml_int64.div_mod(x$1, wbase$1);
          var quotient$3 = match$8[0];
          var modulus$3 = match$8[1];
          s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
          while(Caml_int64.neq(quotient$3, /* int64 */[
                  /* hi */0,
                  /* lo */0
                ])) {
            var match$9 = Caml_int64.div_mod(quotient$3, wbase$1);
            quotient$3 = match$9[0];
            modulus$3 = match$9[1];
            s = String.fromCharCode(cvtbl$1.charCodeAt(modulus$3[1] | 0)) + s;
          };
        }
        break;
    
  }
  if (f[/* prec */9] >= 0) {
    f[/* filter */2] = " ";
    var n = f[/* prec */9] - s.length | 0;
    if (n > 0) {
      s = Caml_utils.repeat(n, "0") + s;
    }
    
  }
  return finish_formatting(f, s);
}

function caml_format_float(fmt, x) {
  var f = parse_format(fmt);
  var prec = f[/* prec */9] < 0 ? 6 : f[/* prec */9];
  var x$1 = x < 0 ? (f[/* sign */8] = -1, -x) : x;
  var s = "";
  if (isNaN(x$1)) {
    s = "nan";
    f[/* filter */2] = " ";
  } else if (isFinite(x$1)) {
    var match = f[/* conv */10];
    switch (match) {
      case "e" : 
          s = x$1.toExponential(prec);
          var i = s.length;
          if (s[i - 3 | 0] === "e") {
            s = s.slice(0, i - 1 | 0) + ("0" + s.slice(i - 1 | 0));
          }
          break;
      case "f" : 
          s = x$1.toFixed(prec);
          break;
      case "g" : 
          var prec$1 = prec !== 0 ? prec : 1;
          s = x$1.toExponential(prec$1 - 1 | 0);
          var j = s.indexOf("e");
          var exp = Number(s.slice(j + 1 | 0)) | 0;
          if (exp < -4 || x$1 >= 1e21 || x$1.toFixed().length > prec$1) {
            var i$1 = j - 1 | 0;
            while(s[i$1] === "0") {
              i$1 = i$1 - 1 | 0;
            };
            if (s[i$1] === ".") {
              i$1 = i$1 - 1 | 0;
            }
            s = s.slice(0, i$1 + 1 | 0) + s.slice(j);
            var i$2 = s.length;
            if (s[i$2 - 3 | 0] === "e") {
              s = s.slice(0, i$2 - 1 | 0) + ("0" + s.slice(i$2 - 1 | 0));
            }
            
          } else {
            var p = prec$1;
            if (exp < 0) {
              p = p - (exp + 1 | 0) | 0;
              s = x$1.toFixed(p);
            } else {
              while((function () {
                      s = x$1.toFixed(p);
                      return +(s.length > (prec$1 + 1 | 0));
                    })()) {
                p = p - 1 | 0;
              };
            }
            if (p !== 0) {
              var k = s.length - 1 | 0;
              while(s[k] === "0") {
                k = k - 1 | 0;
              };
              if (s[k] === ".") {
                k = k - 1 | 0;
              }
              s = s.slice(0, k + 1 | 0);
            }
            
          }
          break;
      default:
        
    }
  } else {
    s = "inf";
    f[/* filter */2] = " ";
  }
  return finish_formatting(f, s);
}

var float_of_string = (
  function (s, caml_failwith) {
    var res = +s;
    if ((s.length > 0) && (res === res))
        return res;
    s = s.replace(/_/g, "");
    res = +s;
    if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) {
        return res;
    }
    ;
    if (/^ *0x[0-9a-f_]+p[+-]?[0-9_]+/i.test(s)) {
        var pidx = s.indexOf('p');
        pidx = (pidx == -1) ? s.indexOf('P') : pidx;
        var exp = +s.substring(pidx + 1);
        res = +s.substring(0, pidx);
        return res * Math.pow(2, exp);
    }
    if (/^\+?inf(inity)?$/i.test(s))
        return Infinity;
    if (/^-inf(inity)?$/i.test(s))
        return -Infinity;
    caml_failwith("float_of_string");
}

);

function caml_float_of_string(s) {
  return Curry._2(float_of_string, s, caml_failwith);
}

var caml_nativeint_format = caml_format_int;

var caml_int32_format = caml_format_int;

var caml_int32_of_string = caml_int_of_string;

var caml_nativeint_of_string = caml_int_of_string;

exports.caml_format_float        = caml_format_float;
exports.caml_format_int          = caml_format_int;
exports.caml_nativeint_format    = caml_nativeint_format;
exports.caml_int32_format        = caml_int32_format;
exports.caml_float_of_string     = caml_float_of_string;
exports.caml_int64_format        = caml_int64_format;
exports.caml_int_of_string       = caml_int_of_string;
exports.caml_int32_of_string     = caml_int32_of_string;
exports.caml_int64_of_string     = caml_int64_of_string;
exports.caml_nativeint_of_string = caml_nativeint_of_string;
/* float_of_string Not a pure module */


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Curry                   = __webpack_require__(1);
var Caml_obj                = __webpack_require__(4);
var Pervasives              = __webpack_require__(2);
var Caml_builtin_exceptions = __webpack_require__(0);

function length(l) {
  var _len = 0;
  var _param = l;
  while(true) {
    var param = _param;
    var len = _len;
    if (param) {
      _param = param[1];
      _len = len + 1 | 0;
      continue ;
      
    } else {
      return len;
    }
  };
}

function hd(param) {
  if (param) {
    return param[0];
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "hd"
        ];
  }
}

function tl(param) {
  if (param) {
    return param[1];
  } else {
    throw [
          Caml_builtin_exceptions.failure,
          "tl"
        ];
  }
}

function nth(l, n) {
  if (n < 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.nth"
        ];
  } else {
    var _l = l;
    var _n = n;
    while(true) {
      var n$1 = _n;
      var l$1 = _l;
      if (l$1) {
        if (n$1) {
          _n = n$1 - 1 | 0;
          _l = l$1[1];
          continue ;
          
        } else {
          return l$1[0];
        }
      } else {
        throw [
              Caml_builtin_exceptions.failure,
              "nth"
            ];
      }
    };
  }
}

function rev_append(_l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      _l2 = /* :: */[
        l1[0],
        l2
      ];
      _l1 = l1[1];
      continue ;
      
    } else {
      return l2;
    }
  };
}

function rev(l) {
  return rev_append(l, /* [] */0);
}

function flatten(param) {
  if (param) {
    return Pervasives.$at(param[0], flatten(param[1]));
  } else {
    return /* [] */0;
  }
}

function map(f, param) {
  if (param) {
    var r = Curry._1(f, param[0]);
    return /* :: */[
            r,
            map(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi(i, f, param) {
  if (param) {
    var r = Curry._2(f, i, param[0]);
    return /* :: */[
            r,
            mapi(i + 1 | 0, f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapi$1(f, l) {
  return mapi(0, f, l);
}

function rev_map(f, l) {
  var _accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = /* :: */[
        Curry._1(f, param[0]),
        accu
      ];
      continue ;
      
    } else {
      return accu;
    }
  };
}

function iter(f, _param) {
  while(true) {
    var param = _param;
    if (param) {
      Curry._1(f, param[0]);
      _param = param[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iteri(f, l) {
  var _i = 0;
  var f$1 = f;
  var _param = l;
  while(true) {
    var param = _param;
    var i = _i;
    if (param) {
      Curry._2(f$1, i, param[0]);
      _param = param[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function fold_left(f, _accu, _l) {
  while(true) {
    var l = _l;
    var accu = _accu;
    if (l) {
      _l = l[1];
      _accu = Curry._2(f, accu, l[0]);
      continue ;
      
    } else {
      return accu;
    }
  };
}

function fold_right(f, l, accu) {
  if (l) {
    return Curry._2(f, l[0], fold_right(f, l[1], accu));
  } else {
    return accu;
  }
}

function map2(f, l1, l2) {
  if (l1) {
    if (l2) {
      var r = Curry._2(f, l1[0], l2[0]);
      return /* :: */[
              r,
              map2(f, l1[1], l2[1])
            ];
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.map2"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.map2"
        ];
  } else {
    return /* [] */0;
  }
}

function rev_map2(f, l1, l2) {
  var _accu = /* [] */0;
  var _l1 = l1;
  var _l2 = l2;
  while(true) {
    var l2$1 = _l2;
    var l1$1 = _l1;
    var accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1[1];
        _l1 = l1$1[1];
        _accu = /* :: */[
          Curry._2(f, l1$1[0], l2$1[0]),
          accu
        ];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.rev_map2"
            ];
      }
    } else if (l2$1) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.rev_map2"
          ];
    } else {
      return accu;
    }
  };
}

function iter2(f, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        Curry._2(f, l1[0], l2[0]);
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.iter2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.iter2"
          ];
    } else {
      return /* () */0;
    }
  };
}

function fold_left2(f, _accu, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    var accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2[1];
        _l1 = l1[1];
        _accu = Curry._3(f, accu, l1[0], l2[0]);
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.fold_left2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.fold_left2"
          ];
    } else {
      return accu;
    }
  };
}

function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return Curry._3(f, l1[0], l2[0], fold_right2(f, l1[1], l2[1], accu));
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.fold_right2"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.fold_right2"
        ];
  } else {
    return accu;
  }
}

function for_all(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Curry._1(p, param[0])) {
        _param = param[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else {
      return /* true */1;
    }
  };
}

function exists(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Curry._1(p, param[0])) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function for_all2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1[0], l2[0])) {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.for_all2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.for_all2"
          ];
    } else {
      return /* true */1;
    }
  };
}

function exists2(p, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2) {
        if (Curry._2(p, l1[0], l2[0])) {
          return /* true */1;
        } else {
          _l2 = l2[1];
          _l1 = l1[1];
          continue ;
          
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "List.exists2"
            ];
      }
    } else if (l2) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.exists2"
          ];
    } else {
      return /* false */0;
    }
  };
}

function mem(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_compare(param[0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function memq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0] === x) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (Caml_obj.caml_compare(match[0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return match[1];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var match = param[0];
      if (match[0] === x) {
        return match[1];
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function mem_assoc(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_compare(param[0][0], x)) {
        _param = param[1];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function mem_assq(x, _param) {
  while(true) {
    var param = _param;
    if (param) {
      if (param[0][0] === x) {
        return /* true */1;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

function remove_assoc(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (Caml_obj.caml_compare(pair[0], x)) {
      return /* :: */[
              pair,
              remove_assoc(x, l)
            ];
    } else {
      return l;
    }
  } else {
    return /* [] */0;
  }
}

function remove_assq(x, param) {
  if (param) {
    var l = param[1];
    var pair = param[0];
    if (pair[0] === x) {
      return l;
    } else {
      return /* :: */[
              pair,
              remove_assq(x, l)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function find(p, _param) {
  while(true) {
    var param = _param;
    if (param) {
      var x = param[0];
      if (Curry._1(p, x)) {
        return x;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_all(p) {
  return (function (param) {
      var _accu = /* [] */0;
      var _param = param;
      while(true) {
        var param$1 = _param;
        var accu = _accu;
        if (param$1) {
          var l = param$1[1];
          var x = param$1[0];
          if (Curry._1(p, x)) {
            _param = l;
            _accu = /* :: */[
              x,
              accu
            ];
            continue ;
            
          } else {
            _param = l;
            continue ;
            
          }
        } else {
          return rev_append(accu, /* [] */0);
        }
      };
    });
}

function partition(p, l) {
  var _yes = /* [] */0;
  var _no = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var no = _no;
    var yes = _yes;
    if (param) {
      var l$1 = param[1];
      var x = param[0];
      if (Curry._1(p, x)) {
        _param = l$1;
        _yes = /* :: */[
          x,
          yes
        ];
        continue ;
        
      } else {
        _param = l$1;
        _no = /* :: */[
          x,
          no
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              rev_append(yes, /* [] */0),
              rev_append(no, /* [] */0)
            ];
    }
  };
}

function split(param) {
  if (param) {
    var match = param[0];
    var match$1 = split(param[1]);
    return /* tuple */[
            /* :: */[
              match[0],
              match$1[0]
            ],
            /* :: */[
              match[1],
              match$1[1]
            ]
          ];
  } else {
    return /* tuple */[
            /* [] */0,
            /* [] */0
          ];
  }
}

function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return /* :: */[
              /* tuple */[
                l1[0],
                l2[0]
              ],
              combine(l1[1], l2[1])
            ];
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "List.combine"
          ];
    }
  } else if (l2) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "List.combine"
        ];
  } else {
    return /* [] */0;
  }
}

function merge(cmp, l1, l2) {
  if (l1) {
    if (l2) {
      var h2 = l2[0];
      var h1 = l1[0];
      if (Curry._2(cmp, h1, h2) <= 0) {
        return /* :: */[
                h1,
                merge(cmp, l1[1], l2)
              ];
      } else {
        return /* :: */[
                h2,
                merge(cmp, l1, l2[1])
              ];
      }
    } else {
      return l1;
    }
  } else {
    return l2;
  }
}

function chop(_k, _l) {
  while(true) {
    var l = _l;
    var k = _k;
    if (k) {
      if (l) {
        _l = l[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "list.ml",
                223,
                11
              ]
            ];
      }
    } else {
      return l;
    }
  };
}

function stable_sort(cmp, l) {
  var sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (Curry._2(cmp, x1, x2) <= 0) {
              if (Curry._2(cmp, x2, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (Curry._2(cmp, x1, x3) <= 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (Curry._2(cmp, x1, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (Curry._2(cmp, x2, x3) <= 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (Curry._2(cmp, x1$1, x2$1) <= 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = rev_sort(n1, l);
      var s2 = rev_sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var h2 = l2$1[0];
            var h1 = l1[0];
            if (Curry._2(cmp, h1, h2) > 0) {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l1 = l1[1];
              continue ;
              
            } else {
              _accu = /* :: */[
                h2,
                accu
              ];
              _l2 = l2$1[1];
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var rev_sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            if (Curry._2(cmp, x1, x2) > 0) {
              if (Curry._2(cmp, x2, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ]
                      ];
              } else if (Curry._2(cmp, x1, x3) > 0) {
                return /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              } else {
                return /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ]
                      ];
              }
            } else if (Curry._2(cmp, x1, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x1,
                        /* :: */[
                          x3,
                          /* [] */0
                        ]
                      ]
                    ];
            } else if (Curry._2(cmp, x2, x3) > 0) {
              return /* :: */[
                      x2,
                      /* :: */[
                        x3,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            } else {
              return /* :: */[
                      x3,
                      /* :: */[
                        x2,
                        /* :: */[
                          x1,
                          /* [] */0
                        ]
                      ]
                    ];
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        if (Curry._2(cmp, x1$1, x2$1) > 0) {
          return /* :: */[
                  x1$1,
                  /* :: */[
                    x2$1,
                    /* [] */0
                  ]
                ];
        } else {
          return /* :: */[
                  x2$1,
                  /* :: */[
                    x1$1,
                    /* [] */0
                  ]
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = sort(n1, l);
      var s2 = sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var h2 = l2$1[0];
            var h1 = l1[0];
            if (Curry._2(cmp, h1, h2) <= 0) {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l1 = l1[1];
              continue ;
              
            } else {
              _accu = /* :: */[
                h2,
                accu
              ];
              _l2 = l2$1[1];
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

function sort_uniq(cmp, l) {
  var sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = Curry._2(cmp, x1, x2);
            if (c) {
              if (c < 0) {
                var c$1 = Curry._2(cmp, x2, x3);
                if (c$1) {
                  if (c$1 < 0) {
                    return /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$2 = Curry._2(cmp, x1, x3);
                    if (c$2) {
                      if (c$2 < 0) {
                        return /* :: */[
                                x1,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x1,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x1,
                              /* :: */[
                                x2,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                if (c$3) {
                  if (c$3 < 0) {
                    return /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$4 = Curry._2(cmp, x2, x3);
                    if (c$4) {
                      if (c$4 < 0) {
                        return /* :: */[
                                x2,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x2,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x2,
                              /* :: */[
                                x1,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                }
              }
            } else {
              var c$5 = Curry._2(cmp, x2, x3);
              if (c$5) {
                if (c$5 < 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              }
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6) {
          if (c$6 < 0) {
            return /* :: */[
                    x1$1,
                    /* :: */[
                      x2$1,
                      /* [] */0
                    ]
                  ];
          } else {
            return /* :: */[
                    x2$1,
                    /* :: */[
                      x1$1,
                      /* [] */0
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = rev_sort(n1, l);
      var s2 = rev_sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var t2 = l2$1[1];
            var h2 = l2$1[0];
            var t1 = l1[1];
            var h1 = l1[0];
            var c$7 = Curry._2(cmp, h1, h2);
            if (c$7) {
              if (c$7 > 0) {
                _accu = /* :: */[
                  h1,
                  accu
                ];
                _l1 = t1;
                continue ;
                
              } else {
                _accu = /* :: */[
                  h2,
                  accu
                ];
                _l2 = t2;
                continue ;
                
              }
            } else {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l2 = t2;
              _l1 = t1;
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var rev_sort = function (n, l) {
    var exit = 0;
    if (n !== 2) {
      if (n !== 3) {
        exit = 1;
      } else if (l) {
        var match = l[1];
        if (match) {
          var match$1 = match[1];
          if (match$1) {
            var x3 = match$1[0];
            var x2 = match[0];
            var x1 = l[0];
            var c = Curry._2(cmp, x1, x2);
            if (c) {
              if (c > 0) {
                var c$1 = Curry._2(cmp, x2, x3);
                if (c$1) {
                  if (c$1 > 0) {
                    return /* :: */[
                            x1,
                            /* :: */[
                              x2,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$2 = Curry._2(cmp, x1, x3);
                    if (c$2) {
                      if (c$2 > 0) {
                        return /* :: */[
                                x1,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x1,
                                  /* :: */[
                                    x2,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x1,
                              /* :: */[
                                x2,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x1,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                var c$3 = Curry._2(cmp, x1, x3);
                if (c$3) {
                  if (c$3 > 0) {
                    return /* :: */[
                            x2,
                            /* :: */[
                              x1,
                              /* :: */[
                                x3,
                                /* [] */0
                              ]
                            ]
                          ];
                  } else {
                    var c$4 = Curry._2(cmp, x2, x3);
                    if (c$4) {
                      if (c$4 > 0) {
                        return /* :: */[
                                x2,
                                /* :: */[
                                  x3,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      } else {
                        return /* :: */[
                                x3,
                                /* :: */[
                                  x2,
                                  /* :: */[
                                    x1,
                                    /* [] */0
                                  ]
                                ]
                              ];
                      }
                    } else {
                      return /* :: */[
                              x2,
                              /* :: */[
                                x1,
                                /* [] */0
                              ]
                            ];
                    }
                  }
                } else {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x1,
                            /* [] */0
                          ]
                        ];
                }
              }
            } else {
              var c$5 = Curry._2(cmp, x2, x3);
              if (c$5) {
                if (c$5 > 0) {
                  return /* :: */[
                          x2,
                          /* :: */[
                            x3,
                            /* [] */0
                          ]
                        ];
                } else {
                  return /* :: */[
                          x3,
                          /* :: */[
                            x2,
                            /* [] */0
                          ]
                        ];
                }
              } else {
                return /* :: */[
                        x2,
                        /* [] */0
                      ];
              }
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else if (l) {
      var match$2 = l[1];
      if (match$2) {
        var x2$1 = match$2[0];
        var x1$1 = l[0];
        var c$6 = Curry._2(cmp, x1$1, x2$1);
        if (c$6) {
          if (c$6 > 0) {
            return /* :: */[
                    x1$1,
                    /* :: */[
                      x2$1,
                      /* [] */0
                    ]
                  ];
          } else {
            return /* :: */[
                    x2$1,
                    /* :: */[
                      x1$1,
                      /* [] */0
                    ]
                  ];
          }
        } else {
          return /* :: */[
                  x1$1,
                  /* [] */0
                ];
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var n1 = (n >> 1);
      var n2 = n - n1 | 0;
      var l2 = chop(n1, l);
      var s1 = sort(n1, l);
      var s2 = sort(n2, l2);
      var _l1 = s1;
      var _l2 = s2;
      var _accu = /* [] */0;
      while(true) {
        var accu = _accu;
        var l2$1 = _l2;
        var l1 = _l1;
        if (l1) {
          if (l2$1) {
            var t2 = l2$1[1];
            var h2 = l2$1[0];
            var t1 = l1[1];
            var h1 = l1[0];
            var c$7 = Curry._2(cmp, h1, h2);
            if (c$7) {
              if (c$7 < 0) {
                _accu = /* :: */[
                  h1,
                  accu
                ];
                _l1 = t1;
                continue ;
                
              } else {
                _accu = /* :: */[
                  h2,
                  accu
                ];
                _l2 = t2;
                continue ;
                
              }
            } else {
              _accu = /* :: */[
                h1,
                accu
              ];
              _l2 = t2;
              _l1 = t1;
              continue ;
              
            }
          } else {
            return rev_append(l1, accu);
          }
        } else {
          return rev_append(l2$1, accu);
        }
      };
    }
    
  };
  var len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort(len, l);
  }
}

var append = Pervasives.$at;

var concat = flatten;

var filter = find_all;

var sort = stable_sort;

var fast_sort = stable_sort;

exports.length       = length;
exports.hd           = hd;
exports.tl           = tl;
exports.nth          = nth;
exports.rev          = rev;
exports.append       = append;
exports.rev_append   = rev_append;
exports.concat       = concat;
exports.flatten      = flatten;
exports.iter         = iter;
exports.iteri        = iteri;
exports.map          = map;
exports.mapi         = mapi$1;
exports.rev_map      = rev_map;
exports.fold_left    = fold_left;
exports.fold_right   = fold_right;
exports.iter2        = iter2;
exports.map2         = map2;
exports.rev_map2     = rev_map2;
exports.fold_left2   = fold_left2;
exports.fold_right2  = fold_right2;
exports.for_all      = for_all;
exports.exists       = exists;
exports.for_all2     = for_all2;
exports.exists2      = exists2;
exports.mem          = mem;
exports.memq         = memq;
exports.find         = find;
exports.filter       = filter;
exports.find_all     = find_all;
exports.partition    = partition;
exports.assoc        = assoc;
exports.assq         = assq;
exports.mem_assoc    = mem_assoc;
exports.mem_assq     = mem_assq;
exports.remove_assoc = remove_assoc;
exports.remove_assq  = remove_assq;
exports.split        = split;
exports.combine      = combine;
exports.sort         = sort;
exports.stable_sort  = stable_sort;
exports.fast_sort    = fast_sort;
exports.sort_uniq    = sort_uniq;
exports.merge        = merge;
/* No side effect */


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var List                    = __webpack_require__(9);
var Curry                   = __webpack_require__(1);
var Events                  = __webpack_require__(43);
var GlMatrix                = __webpack_require__(44);
var Caml_int32              = __webpack_require__(5);
var RGLConstants            = __webpack_require__(12);
var Caml_builtin_exceptions = __webpack_require__(0);

var $$window = (window);

var Document = /* module */[/* window */$$window];

function createCanvas() {
  return document.createElement("canvas");
}

function readFile(filename, cb) {
  var rawFile = new XMLHttpRequest();
  rawFile.open("GET", filename, false);
  rawFile.onreadystatechange = (function () {
      if (rawFile.readyState === 4 && (rawFile.status === 200 || rawFile.status === 0)) {
        return Curry._1(cb, rawFile.responseText);
      } else {
        return 0;
      }
    });
  rawFile.send(null);
  return /* () */0;
}

var File = /* module */[/* readFile */readFile];

function getWidth(prim) {
  return prim.width;
}

function getHeight(prim) {
  return prim.height;
}

function init() {
  var canvas = document.createElement("canvas");
  canvas.style.backgroundColor = "black";
  document.body.appendChild(canvas);
  return canvas;
}

function setWindowSize($$window, width, height) {
  $$window.width = width;
  $$window.height = height;
  return /* () */0;
}

function getContext($$window) {
  return $$window.getContext("webgl", {
              preserveDrawingBuffer: /* true */1,
              antialias: /* true */1
            });
}

var Window = /* module */[
  /* getWidth */getWidth,
  /* getHeight */getHeight,
  /* init */init,
  /* setWindowSize */setWindowSize,
  /* getContext */getContext
];

function render(canvas, mouseDown, mouseUp, mouseMove, keyDown, keyUp, windowResize, displayFunc, _) {
  if (mouseDown) {
    var cb = mouseDown[0];
    canvas.addEventListener("mousedown", (function (e) {
            var match = e.button;
            var button;
            if (match > 2 || match < 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "reasongl.re",
                      150,
                      21
                    ]
                  ];
            } else {
              switch (match) {
                case 0 : 
                    button = /* LeftButton */0;
                    break;
                case 1 : 
                    button = /* MiddleButton */1;
                    break;
                case 2 : 
                    button = /* RightButton */2;
                    break;
                
              }
            }
            var rect = canvas.getBoundingClientRect();
            var x = e.clientX - rect.left | 0;
            var y = e.clientY - rect.top | 0;
            return Curry._4(cb, button, /* MouseDown */0, x, y);
          }));
  }
  if (mouseUp) {
    var cb$1 = mouseUp[0];
    canvas.addEventListener("mouseup", (function (e) {
            var match = e.button;
            var button;
            if (match > 2 || match < 0) {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "reasongl.re",
                      173,
                      21
                    ]
                  ];
            } else {
              switch (match) {
                case 0 : 
                    button = /* LeftButton */0;
                    break;
                case 1 : 
                    button = /* MiddleButton */1;
                    break;
                case 2 : 
                    button = /* RightButton */2;
                    break;
                
              }
            }
            var rect = canvas.getBoundingClientRect();
            var x = e.clientX - rect.left | 0;
            var y = e.clientY - rect.top | 0;
            return Curry._4(cb$1, button, /* MouseUp */1, x, y);
          }));
  }
  if (mouseMove) {
    var cb$2 = mouseMove[0];
    canvas.addEventListener("mousemove", (function (e) {
            var rect = canvas.getBoundingClientRect();
            var x = e.clientX - rect.left | 0;
            var y = e.clientY - rect.top | 0;
            return Curry._2(cb$2, x, y);
          }));
  }
  var keyLastPressed = [/* [] */0];
  if (keyDown) {
    var cb$3 = keyDown[0];
    $$window.addEventListener("keydown", (function (e) {
            var keycode = e.which;
            var repeat = List.fold_left((function (acc, k) {
                    if (acc) {
                      return /* true */1;
                    } else {
                      return +(k === keycode);
                    }
                  }), /* false */0, keyLastPressed[0]);
            if (!repeat) {
              keyLastPressed[0] = /* :: */[
                keycode,
                keyLastPressed[0]
              ];
            }
            return Curry._2(cb$3, Events.keycodeMap(keycode), repeat);
          }));
  }
  if (keyUp) {
    var cb$4 = keyUp[0];
    $$window.addEventListener("keyup", (function (e) {
            var keycode = e.which;
            keyLastPressed[0] = List.filter((function (k) {
                      return +(k !== keycode);
                    }))(keyLastPressed[0]);
            return Curry._1(cb$4, Events.keycodeMap(keycode));
          }));
  }
  if (windowResize) {
    var cb$5 = windowResize[0];
    $$window.addEventListener("resize", (function () {
            return Curry._1(cb$5, /* () */0);
          }));
  }
  var tick = function (prev, _) {
    var now = Date.now();
    Curry._1(displayFunc, now - prev);
    window.requestAnimationFrame((function (param) {
            return tick(now, param);
          }));
    return /* () */0;
  };
  var partial_arg = Date.now();
  window.requestAnimationFrame((function (param) {
          return tick(partial_arg, param);
        }));
  return /* () */0;
}

function shaderSource(context, shader, source) {
  context.shaderSource(shader, "#version 100 \n precision highp float; \n" + source);
  return /* () */0;
}

function create(kind, size) {
  switch (kind) {
    case 0 : 
        return new Float64Array(size);
    case 1 : 
        return new Float32Array(size);
    case 2 : 
        return new Int16Array(size);
    case 3 : 
        return new Uint16Array(size);
    case 4 : 
        return new Int8Array(size);
    case 5 : 
    case 6 : 
        return new Uint8Array(size);
    case 8 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "reasongl.re",
                352,
                17
              ]
            ];
    case 7 : 
    case 9 : 
        return new Int32Array(size);
    
  }
}

function of_array(kind, arr) {
  switch (kind) {
    case 0 : 
        return new Float64Array(arr);
    case 1 : 
        return new Float32Array(arr);
    case 2 : 
        return new Int16Array(arr);
    case 3 : 
        return new Uint16Array(arr);
    case 4 : 
        return new Int8Array(arr);
    case 5 : 
    case 6 : 
        return new Uint8Array(arr);
    case 8 : 
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "reasongl.re",
                365,
                17
              ]
            ];
    case 7 : 
    case 9 : 
        return new Int32Array(arr);
    
  }
}

function sub(arr, offset, len) {
  return arr.subarray(offset, offset + len | 0);
}

function readPixels_RGBA(context, x, y, width, height) {
  var data = new Uint8Array((Caml_int32.imul(width, height) << 2));
  context.readPixels(x, y, width, height, RGLConstants.rgba, RGLConstants.unsigned_byte, data);
  return data;
}

function loadImage(filename, _, callback, _$1) {
  var image = new Image();
  image.src = filename;
  image.addEventListener("load", (function () {
          return Curry._1(callback, /* Some */[image]);
        }));
  return /* () */0;
}

function texImage2DWithImage(context, target, level, image) {
  context.texImage2D(target, level, RGLConstants.rgba, RGLConstants.rgba, RGLConstants.unsigned_byte, image);
  return /* () */0;
}

function texImage2D_RGBA(context, target, level, width, height, border, data) {
  context.texImage2D(target, level, RGLConstants.rgba, width, height, border, RGLConstants.rgba, RGLConstants.unsigned_byte, data);
  return /* () */0;
}

function vertexAttribPointer(context, attribute, size, type_, normalized, stride, offset) {
  var normalized$1 = normalized ? true : false;
  context.vertexAttribPointer(attribute, size, type_, normalized$1, stride, offset);
  return /* () */0;
}

function to_array(a) {
  return a;
}

function Mat4_001() {
  return GlMatrix.mat4.create();
}

function Mat4_002(prim) {
  GlMatrix.mat4.identity(prim);
  return /* () */0;
}

function Mat4_003(prim, prim$1, prim$2) {
  GlMatrix.mat4.translate(prim, prim$1, prim$2);
  return /* () */0;
}

function Mat4_004(prim, prim$1, prim$2) {
  GlMatrix.mat4.scale(prim, prim$1, prim$2);
  return /* () */0;
}

function Mat4_005(prim, prim$1, prim$2, prim$3) {
  GlMatrix.mat4.rotate(prim, prim$1, prim$2, prim$3);
  return /* () */0;
}

function Mat4_006(prim, prim$1, prim$2, prim$3, prim$4, prim$5, prim$6) {
  GlMatrix.mat4.ortho(prim, prim$1, prim$2, prim$3, prim$4, prim$5, prim$6);
  return /* () */0;
}

var Mat4 = /* module */[
  /* to_array */to_array,
  Mat4_001,
  Mat4_002,
  Mat4_003,
  Mat4_004,
  Mat4_005,
  Mat4_006
];

function uniformMatrix4fv(context, $$location, value) {
  context.uniformMatrix4fv($$location, false, value);
  return /* () */0;
}

function getProgramParameter(context, program, paramName) {
  switch (paramName) {
    case 0 : 
        if (context.getProgramParameter(program, context.DELETE_STATUS)) {
          return 1;
        } else {
          return 0;
        }
    case 1 : 
        if (context.getProgramParameter(program, context.LINK_STATUS)) {
          return 1;
        } else {
          return 0;
        }
    case 2 : 
        if (context.getProgramParameter(program, context.VALIDATE_STATUS)) {
          return 1;
        } else {
          return 0;
        }
    
  }
}

function getShaderParameter(context, shader, paramName) {
  switch (paramName) {
    case 0 : 
        if (context.getShaderParameter(shader, context.DELETE_STATUS)) {
          return 1;
        } else {
          return 0;
        }
    case 1 : 
        if (context.getShaderParameter(shader, context.COMPILE_STATUS)) {
          return 1;
        } else {
          return 0;
        }
    case 2 : 
        return context.getShaderParameter(shader, context.SHADER_TYPE);
    
  }
}

var Gl_003 = /* Events : Events */[Events.keycodeMap];

function Gl_005(prim, prim$1, prim$2, prim$3, prim$4) {
  prim.clearColor(prim$1, prim$2, prim$3, prim$4);
  return /* () */0;
}

function Gl_006(prim) {
  return prim.createProgram();
}

function Gl_007(prim, prim$1) {
  return prim.createShader(prim$1);
}

function Gl_008(prim, prim$1, prim$2) {
  prim.attachShader(prim$1, prim$2);
  return /* () */0;
}

function Gl_009(prim, prim$1) {
  prim.deleteShader(prim$1);
  return /* () */0;
}

function Gl_011(prim, prim$1) {
  prim.compileShader(prim$1);
  return /* () */0;
}

function Gl_012(prim, prim$1) {
  prim.linkProgram(prim$1);
  return /* () */0;
}

function Gl_013(prim, prim$1) {
  prim.useProgram(prim$1);
  return /* () */0;
}

function Gl_014(prim) {
  return prim.createBuffer();
}

function Gl_015(prim, prim$1, prim$2) {
  prim.bindBuffer(prim$1, prim$2);
  return /* () */0;
}

function Gl_016(prim) {
  return prim.createTexture();
}

function Gl_017(prim, prim$1) {
  prim.activeTexture(prim$1);
  return /* () */0;
}

function Gl_018(prim, prim$1, prim$2) {
  prim.bindTexture(prim$1, prim$2);
  return /* () */0;
}

function Gl_019(prim, prim$1, prim$2, prim$3) {
  prim.texParameteri(prim$1, prim$2, prim$3);
  return /* () */0;
}

function Gl_020(prim, prim$1) {
  prim.enable(prim$1);
  return /* () */0;
}

function Gl_021(prim, prim$1) {
  prim.disable(prim$1);
  return /* () */0;
}

function Gl_022(prim, prim$1, prim$2) {
  prim.blendFunc(prim$1, prim$2);
  return /* () */0;
}

var Gl_023 = /* Bigarray */[
  create,
  of_array,
  (function (prim) {
      return prim.length;
    }),
  (function (prim, prim$1) {
      return prim[prim$1];
    }),
  (function (prim, prim$1, prim$2) {
      prim[prim$1] = prim$2;
      return /* () */0;
    }),
  sub
];

function Gl_025(prim) {
  return prim.width;
}

function Gl_026(prim) {
  return prim.height;
}

function Gl_029(prim, prim$1, prim$2) {
  prim.uniform1i(prim$1, prim$2);
  return /* () */0;
}

function Gl_030(prim, prim$1, prim$2) {
  prim.uniform1f(prim$1, prim$2);
  return /* () */0;
}

function Gl_032(prim, prim$1, prim$2, prim$3) {
  prim.bufferData(prim$1, prim$2, prim$3);
  return /* () */0;
}

function Gl_033(prim, prim$1, prim$2, prim$3, prim$4) {
  prim.viewport(prim$1, prim$2, prim$3, prim$4);
  return /* () */0;
}

function Gl_034(prim, prim$1) {
  prim.clear(prim$1);
  return /* () */0;
}

function Gl_035(prim, prim$1, prim$2) {
  return prim.getUniformLocation(prim$1, prim$2);
}

function Gl_036(prim, prim$1, prim$2) {
  return prim.getAttribLocation(prim$1, prim$2);
}

function Gl_037(prim, prim$1) {
  prim.enableVertexAttribArray(prim$1);
  return /* () */0;
}

function Gl_043(prim, prim$1) {
  return prim.getShaderInfoLog(prim$1);
}

function Gl_044(prim, prim$1) {
  return prim.getProgramInfoLog(prim$1);
}

function Gl_045(prim, prim$1) {
  return prim.getShaderSource(prim$1);
}

function Gl_046(prim, prim$1, prim$2, prim$3) {
  prim.drawArrays(prim$1, prim$2, prim$3);
  return /* () */0;
}

function Gl_047(prim, prim$1, prim$2, prim$3, prim$4) {
  prim.drawElements(prim$1, prim$2, prim$3, prim$4);
  return /* () */0;
}

var Gl = /* module */[
  /* target */"web",
  /* File */File,
  /* Window */Window,
  Gl_003,
  /* render */render,
  Gl_005,
  Gl_006,
  Gl_007,
  Gl_008,
  Gl_009,
  /* shaderSource */shaderSource,
  Gl_011,
  Gl_012,
  Gl_013,
  Gl_014,
  Gl_015,
  Gl_016,
  Gl_017,
  Gl_018,
  Gl_019,
  Gl_020,
  Gl_021,
  Gl_022,
  Gl_023,
  /* readPixels_RGBA */readPixels_RGBA,
  Gl_025,
  Gl_026,
  /* loadImage */loadImage,
  /* texImage2DWithImage */texImage2DWithImage,
  Gl_029,
  Gl_030,
  /* texImage2D_RGBA */texImage2D_RGBA,
  Gl_032,
  Gl_033,
  Gl_034,
  Gl_035,
  Gl_036,
  Gl_037,
  /* vertexAttribPointer */vertexAttribPointer,
  /* Mat4 */Mat4,
  /* uniformMatrix4fv */uniformMatrix4fv,
  /* getProgramParameter */getProgramParameter,
  /* getShaderParameter */getShaderParameter,
  Gl_043,
  Gl_044,
  Gl_045,
  Gl_046,
  Gl_047
];

exports.Document     = Document;
exports.createCanvas = createCanvas;
exports.Gl           = Gl;
/* window Not a pure module */


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var id = [0];

function caml_set_oo_id(b) {
  b[1] = id[0];
  id[0] += 1;
  return b;
}

function get_id() {
  id[0] += 1;
  return id[0];
}

function create(str) {
  var v_001 = get_id(/* () */0);
  var v = /* tuple */[
    str,
    v_001
  ];
  v.tag = 248;
  return v;
}

function isCamlExceptionOrOpenVariant(e) {
  if (e === undefined) {
    return /* false */0;
  } else if (e.tag === 248) {
    return /* true */1;
  } else {
    var slot = e[0];
    if (slot !== undefined) {
      return +(slot.tag === 248);
    } else {
      return /* false */0;
    }
  }
}

exports.caml_set_oo_id               = caml_set_oo_id;
exports.get_id                       = get_id;
exports.create                       = create;
exports.isCamlExceptionOrOpenVariant = isCamlExceptionOrOpenVariant;
/* No side effect */


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE



var triangles = 4;

var triangle_strip = 5;

var texture0 = 33984;

var texture1 = 33985;

var texture2 = 33986;

var texture_2d = 3553;

var blend = 3042;

var texture_wrap_s = 10242;

var texture_wrap_t = 10243;

var clamp_to_edge = 33071;

var src_alpha = 770;

var one_minus_src_alpha = 771;

var dst_alpha = 772;

var depth_test = 2929;

var rgb = 6407;

var rgba = 6408;

var triangle_fan = 6;

var array_buffer = 34962;

var element_array_buffer = 34963;

var array_buffer_binding = 34964;

var element_array_buffer_binding = 34965;

var stream_draw = 35040;

var static_draw = 35044;

var dynamic_draw = 35048;

var buffer_size = 34660;

var buffer_usage = 34661;

var float_ = 5126;

var unsigned_int = 5125;

var current_vertex_attrib = 34342;

var fragment_shader = 35632;

var vertex_shader = 35633;

var max_vertex_attribs = 34921;

var max_vertex_uniform_vectors = 36347;

var max_varying_vectors = 36348;

var max_combined_texture_image_units = 35661;

var max_vertex_texture_image_units = 35660;

var max_texture_image_units = 34930;

var max_fragment_uniform_vectors = 36349;

var shader_type = 35663;

var delete_status = 35712;

var link_status = 35714;

var validate_status = 35715;

var attached_shaders = 35717;

var active_uniforms = 35718;

var active_attributes = 35721;

var shading_language_version = 35724;

var current_program = 35725;

var compile_status = 35713;

var vendor = 7936;

var renderer = 7937;

var version = 7938;

var float_vec2 = 35664;

var float_vec3 = 35665;

var float_vec4 = 35666;

var int_vec2 = 35667;

var int_vec3 = 35668;

var int_vec4 = 35669;

var bool_ = 35670;

var bool_vec2 = 35671;

var bool_vec3 = 35672;

var bool_vec4 = 35673;

var float_mat2 = 35674;

var float_mat3 = 35675;

var float_mat4 = 35676;

var sampler_2d = 35678;

var sampler_cube = 35680;

var unpack_flip_y_webgl = 37440;

var unpack_premultiply_alpha_webgl = 37441;

var context_lost_webgl = 37442;

var unpack_colorspace_conversion_webgl = 37443;

var browser_default_webgl = 37444;

var vertex_attrib_array_enabled = 34338;

var vertex_attrib_array_size = 34339;

var vertex_attrib_array_stride = 34340;

var vertex_attrib_array_type = 34341;

var vertex_attrib_array_normalized = 34922;

var vertex_attrib_array_pointer = 34373;

var vertex_attrib_array_buffer_binding = 34975;

var depth_buffer_bit = 256;

var stencil_buffer_bit = 1024;

var color_buffer_bit = 16384;

var unsigned_short = 5123;

var unsigned_byte = 5121;

var texture_mag_filter = 10240;

var texture_min_filter = 10241;

var linear = 9729;

var linear_mipmap_nearest = 9985;

exports.triangles                          = triangles;
exports.triangle_strip                     = triangle_strip;
exports.texture0                           = texture0;
exports.texture1                           = texture1;
exports.texture2                           = texture2;
exports.texture_2d                         = texture_2d;
exports.blend                              = blend;
exports.texture_wrap_s                     = texture_wrap_s;
exports.texture_wrap_t                     = texture_wrap_t;
exports.clamp_to_edge                      = clamp_to_edge;
exports.src_alpha                          = src_alpha;
exports.one_minus_src_alpha                = one_minus_src_alpha;
exports.dst_alpha                          = dst_alpha;
exports.depth_test                         = depth_test;
exports.rgb                                = rgb;
exports.rgba                               = rgba;
exports.triangle_fan                       = triangle_fan;
exports.array_buffer                       = array_buffer;
exports.element_array_buffer               = element_array_buffer;
exports.array_buffer_binding               = array_buffer_binding;
exports.element_array_buffer_binding       = element_array_buffer_binding;
exports.stream_draw                        = stream_draw;
exports.static_draw                        = static_draw;
exports.dynamic_draw                       = dynamic_draw;
exports.buffer_size                        = buffer_size;
exports.buffer_usage                       = buffer_usage;
exports.float_                             = float_;
exports.unsigned_int                       = unsigned_int;
exports.current_vertex_attrib              = current_vertex_attrib;
exports.fragment_shader                    = fragment_shader;
exports.vertex_shader                      = vertex_shader;
exports.max_vertex_attribs                 = max_vertex_attribs;
exports.max_vertex_uniform_vectors         = max_vertex_uniform_vectors;
exports.max_varying_vectors                = max_varying_vectors;
exports.max_combined_texture_image_units   = max_combined_texture_image_units;
exports.max_vertex_texture_image_units     = max_vertex_texture_image_units;
exports.max_texture_image_units            = max_texture_image_units;
exports.max_fragment_uniform_vectors       = max_fragment_uniform_vectors;
exports.shader_type                        = shader_type;
exports.delete_status                      = delete_status;
exports.link_status                        = link_status;
exports.validate_status                    = validate_status;
exports.attached_shaders                   = attached_shaders;
exports.active_uniforms                    = active_uniforms;
exports.active_attributes                  = active_attributes;
exports.shading_language_version           = shading_language_version;
exports.current_program                    = current_program;
exports.compile_status                     = compile_status;
exports.vendor                             = vendor;
exports.renderer                           = renderer;
exports.version                            = version;
exports.float_vec2                         = float_vec2;
exports.float_vec3                         = float_vec3;
exports.float_vec4                         = float_vec4;
exports.int_vec2                           = int_vec2;
exports.int_vec3                           = int_vec3;
exports.int_vec4                           = int_vec4;
exports.bool_                              = bool_;
exports.bool_vec2                          = bool_vec2;
exports.bool_vec3                          = bool_vec3;
exports.bool_vec4                          = bool_vec4;
exports.float_mat2                         = float_mat2;
exports.float_mat3                         = float_mat3;
exports.float_mat4                         = float_mat4;
exports.sampler_2d                         = sampler_2d;
exports.sampler_cube                       = sampler_cube;
exports.unpack_flip_y_webgl                = unpack_flip_y_webgl;
exports.unpack_premultiply_alpha_webgl     = unpack_premultiply_alpha_webgl;
exports.context_lost_webgl                 = context_lost_webgl;
exports.unpack_colorspace_conversion_webgl = unpack_colorspace_conversion_webgl;
exports.browser_default_webgl              = browser_default_webgl;
exports.vertex_attrib_array_enabled        = vertex_attrib_array_enabled;
exports.vertex_attrib_array_size           = vertex_attrib_array_size;
exports.vertex_attrib_array_stride         = vertex_attrib_array_stride;
exports.vertex_attrib_array_type           = vertex_attrib_array_type;
exports.vertex_attrib_array_normalized     = vertex_attrib_array_normalized;
exports.vertex_attrib_array_pointer        = vertex_attrib_array_pointer;
exports.vertex_attrib_array_buffer_binding = vertex_attrib_array_buffer_binding;
exports.depth_buffer_bit                   = depth_buffer_bit;
exports.stencil_buffer_bit                 = stencil_buffer_bit;
exports.color_buffer_bit                   = color_buffer_bit;
exports.unsigned_short                     = unsigned_short;
exports.unsigned_byte                      = unsigned_byte;
exports.texture_mag_filter                 = texture_mag_filter;
exports.texture_min_filter                 = texture_min_filter;
exports.linear                             = linear;
exports.linear_mipmap_nearest              = linear_mipmap_nearest;
/* No side effect */


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                  = __webpack_require__(1);
var Reasongl               = __webpack_require__(10);
var Caml_int32             = __webpack_require__(5);
var Pervasives             = __webpack_require__(2);
var RGLConstants           = __webpack_require__(12);
var Reprocessing_Common    = __webpack_require__(19);
var Reprocessing_Matrix    = __webpack_require__(20);
var Reprocessing_Shaders   = __webpack_require__(50);
var Reprocessing_Constants = __webpack_require__(14);

function getProgram(context, vertexShaderSource, fragmentShaderSource) {
  var vertexShader = Curry._2(Reasongl.Gl[/* createShader */7], context, RGLConstants.vertex_shader);
  Curry._3(Reasongl.Gl[/* shaderSource */10], context, vertexShader, vertexShaderSource);
  Curry._2(Reasongl.Gl[/* compileShader */11], context, vertexShader);
  var compiledCorrectly = +(Curry._3(Reasongl.Gl[/* getShaderParameter */42], context, vertexShader, /* Compile_status */1) === 1);
  if (compiledCorrectly) {
    var fragmentShader = Curry._2(Reasongl.Gl[/* createShader */7], context, RGLConstants.fragment_shader);
    Curry._3(Reasongl.Gl[/* shaderSource */10], context, fragmentShader, fragmentShaderSource);
    Curry._2(Reasongl.Gl[/* compileShader */11], context, fragmentShader);
    var compiledCorrectly$1 = +(Curry._3(Reasongl.Gl[/* getShaderParameter */42], context, fragmentShader, /* Compile_status */1) === 1);
    if (compiledCorrectly$1) {
      var program = Curry._1(Reasongl.Gl[/* createProgram */6], context);
      Curry._3(Reasongl.Gl[/* attachShader */8], context, program, vertexShader);
      Curry._2(Reasongl.Gl[/* deleteShader */9], context, vertexShader);
      Curry._3(Reasongl.Gl[/* attachShader */8], context, program, fragmentShader);
      Curry._2(Reasongl.Gl[/* deleteShader */9], context, fragmentShader);
      Curry._2(Reasongl.Gl[/* linkProgram */12], context, program);
      var linkedCorrectly = +(Curry._3(Reasongl.Gl[/* getProgramParameter */41], context, program, /* Link_status */1) === 1);
      if (linkedCorrectly) {
        return /* Some */[program];
      } else {
        console.log("Linking error: " + Curry._2(Reasongl.Gl[/* getProgramInfoLog */44], context, program));
        return /* None */0;
      }
    } else {
      console.log("Fragment shader error: " + Curry._2(Reasongl.Gl[/* getShaderInfoLog */43], context, fragmentShader));
      return /* None */0;
    }
  } else {
    console.log("Vertex shader error: " + Curry._2(Reasongl.Gl[/* getShaderInfoLog */43], context, vertexShader));
    return /* None */0;
  }
}

function createCanvas($$window, height, width) {
  Curry._3(Reasongl.Gl[/* Window */2][/* setWindowSize */3], $$window, width, height);
  var context = Curry._1(Reasongl.Gl[/* Window */2][/* getContext */4], $$window);
  Curry._5(Reasongl.Gl[/* viewport */33], context, -1, -1, width, height);
  Curry._5(Reasongl.Gl[/* clearColor */5], context, 0, 0, 0, 1);
  Curry._2(Reasongl.Gl[/* clear */34], context, RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
  var camera = /* record */[/* projectionMatrix */Curry._1(Reasongl.Gl[/* Mat4 */39][/* create */1], /* () */0)];
  var vertexBuffer = Curry._1(Reasongl.Gl[/* createBuffer */14], context);
  var elementBuffer = Curry._1(Reasongl.Gl[/* createBuffer */14], context);
  var match = getProgram(context, Reprocessing_Shaders.vertexShaderSource, Reprocessing_Shaders.fragmentShaderSource);
  var program = match ? match[0] : Pervasives.failwith("Could not create the program and/or the shaders. Aborting.");
  Curry._2(Reasongl.Gl[/* useProgram */13], context, program);
  var aVertexPosition = Curry._3(Reasongl.Gl[/* getAttribLocation */36], context, program, "aVertexPosition");
  Curry._2(Reasongl.Gl[/* enableVertexAttribArray */37], context, aVertexPosition);
  var aVertexColor = Curry._3(Reasongl.Gl[/* getAttribLocation */36], context, program, "aVertexColor");
  Curry._2(Reasongl.Gl[/* enableVertexAttribArray */37], context, aVertexColor);
  var pMatrixUniform = Curry._3(Reasongl.Gl[/* getUniformLocation */35], context, program, "uPMatrix");
  Curry._3(Reasongl.Gl[/* uniformMatrix4fv */40], context, pMatrixUniform, camera[/* projectionMatrix */0]);
  var aTextureCoord = Curry._3(Reasongl.Gl[/* getAttribLocation */36], context, program, "aTextureCoord");
  Curry._2(Reasongl.Gl[/* enableVertexAttribArray */37], context, aTextureCoord);
  var texture = Curry._1(Reasongl.Gl[/* createTexture */16], context);
  Curry._2(Reasongl.Gl[/* activeTexture */17], context, RGLConstants.texture0);
  Curry._3(Reasongl.Gl[/* bindTexture */18], context, RGLConstants.texture_2d, texture);
  var uSampler = Curry._3(Reasongl.Gl[/* getUniformLocation */35], context, program, "uSampler");
  Curry._7(Reasongl.Gl[/* texImage2D_RGBA */31], context, RGLConstants.texture_2d, 0, 1, 1, 0, Curry._2(Reasongl.Gl[/* Bigarray */23][/* of_array */1], /* Uint8 */5, /* int array */[
            0,
            0,
            0,
            0
          ]));
  Curry._4(Reasongl.Gl[/* texParameteri */19], context, RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
  Curry._4(Reasongl.Gl[/* texParameteri */19], context, RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear_mipmap_nearest);
  Curry._2(Reasongl.Gl[/* enable */20], context, RGLConstants.blend);
  Curry._3(Reasongl.Gl[/* blendFunc */22], context, RGLConstants.src_alpha, RGLConstants.one_minus_src_alpha);
  Curry._7(Reasongl.Gl[/* Mat4 */39][/* ortho */6], camera[/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return /* record */[
          /* camera */camera,
          /* window */$$window,
          /* gl */context,
          /* vertexBuffer */vertexBuffer,
          /* elementBuffer */elementBuffer,
          /* aVertexColor */aVertexColor,
          /* aTextureCoord */aTextureCoord,
          /* aVertexPosition */aVertexPosition,
          /* pMatrixUniform */pMatrixUniform,
          /* uSampler */uSampler,
          /* batch : record */[
            /* vertexArray */Curry._2(Reasongl.Gl[/* Bigarray */23][/* create */0], /* Float32 */1, Caml_int32.imul(Reprocessing_Common.circularBufferSize, Reprocessing_Common.vertexSize)),
            /* elementArray */Curry._2(Reasongl.Gl[/* Bigarray */23][/* create */0], /* Uint16 */3, Reprocessing_Common.circularBufferSize),
            /* vertexPtr */0,
            /* elementPtr */0,
            /* currTex : None */0,
            /* nullTex */texture
          ],
          /* keyboard : record */[/* keyCode : Nothing */65],
          /* mouse : record */[
            /* pos : tuple */[
              0,
              0
            ],
            /* prevPos : tuple */[
              0,
              0
            ],
            /* pressed : false */0
          ],
          /* style : record */[
            /* strokeColor : Some */[/* record */[
                /* r */0,
                /* g */0,
                /* b */0
              ]],
            /* strokeWeight */10,
            /* strokeCap : Round */0,
            /* fillColor : Some */[/* record */[
                /* r */0,
                /* g */0,
                /* b */0
              ]]
          ],
          /* styleStack : [] */0,
          /* frame : record */[
            /* count */1,
            /* rate */10
          ],
          /* matrix */Reprocessing_Matrix.createIdentity(/* () */0),
          /* matrixStack : [] */0,
          /* size : record */[
            /* height */height,
            /* width */width,
            /* resizeable : true */1
          ]
        ];
}

function drawGeometry(vertexArray, elementArray, mode, count, textureBuffer, env) {
  Curry._3(Reasongl.Gl[/* bindBuffer */15], env[/* gl */2], RGLConstants.array_buffer, env[/* vertexBuffer */3]);
  Curry._4(Reasongl.Gl[/* bufferData */32], env[/* gl */2], RGLConstants.array_buffer, vertexArray, RGLConstants.stream_draw);
  Curry._7(Reasongl.Gl[/* vertexAttribPointer */38], env[/* gl */2], env[/* aVertexPosition */7], 2, RGLConstants.float_, /* false */0, (Reprocessing_Common.vertexSize << 2), 0);
  Curry._7(Reasongl.Gl[/* vertexAttribPointer */38], env[/* gl */2], env[/* aVertexColor */5], 4, RGLConstants.float_, /* false */0, (Reprocessing_Common.vertexSize << 2), 8);
  Curry._7(Reasongl.Gl[/* vertexAttribPointer */38], env[/* gl */2], env[/* aTextureCoord */6], 2, RGLConstants.float_, /* false */0, (Reprocessing_Common.vertexSize << 2), 24);
  Curry._3(Reasongl.Gl[/* uniform1i */29], env[/* gl */2], env[/* uSampler */9], 0);
  Curry._3(Reasongl.Gl[/* bindBuffer */15], env[/* gl */2], RGLConstants.element_array_buffer, env[/* elementBuffer */4]);
  Curry._4(Reasongl.Gl[/* bufferData */32], env[/* gl */2], RGLConstants.element_array_buffer, elementArray, RGLConstants.stream_draw);
  Curry._3(Reasongl.Gl[/* bindTexture */18], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
  return Curry._5(Reasongl.Gl[/* drawElements */47], env[/* gl */2], mode, count, RGLConstants.unsigned_short, 0);
}

function flushGlobalBatch(env) {
  if (env[/* batch */10][/* elementPtr */3] > 0) {
    var match = env[/* batch */10][/* currTex */4];
    var textureBuffer = match ? match[0] : env[/* batch */10][/* nullTex */5];
    drawGeometry(Curry._3(Reasongl.Gl[/* Bigarray */23][/* sub */5], env[/* batch */10][/* vertexArray */0], 0, env[/* batch */10][/* vertexPtr */2]), Curry._3(Reasongl.Gl[/* Bigarray */23][/* sub */5], env[/* batch */10][/* elementArray */1], 0, env[/* batch */10][/* elementPtr */3]), RGLConstants.triangles, env[/* batch */10][/* elementPtr */3], textureBuffer, env);
    env[/* batch */10][/* currTex */4] = /* None */0;
    env[/* batch */10][/* vertexPtr */2] = 0;
    env[/* batch */10][/* elementPtr */3] = 0;
    return /* () */0;
  } else {
    return 0;
  }
}

function maybeFlushBatch(texture, el, vert, env) {
  if ((env[/* batch */10][/* elementPtr */3] + el | 0) >= Reprocessing_Common.circularBufferSize || (env[/* batch */10][/* vertexPtr */2] + vert | 0) >= Reprocessing_Common.circularBufferSize || env[/* batch */10][/* elementPtr */3] > 0 && env[/* batch */10][/* currTex */4] !== texture) {
    return flushGlobalBatch(env);
  } else {
    return 0;
  }
}

function toColorFloat(i) {
  return i / 255;
}

function addRectToGlobalBatch(env, param, param$1, param$2, param$3, param$4) {
  maybeFlushBatch(/* None */0, 6, 32, env);
  var set = Reasongl.Gl[/* Bigarray */23][/* set */4];
  var match_000 = param$4[/* r */0] / 255;
  var match_001 = param$4[/* g */1] / 255;
  var match_002 = param$4[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 24 | 0, param$3[0]);
  Curry._3(set, vertexArrayToMutate, i + 25 | 0, param$3[1]);
  Curry._3(set, vertexArrayToMutate, i + 26 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 27 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 28 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 29 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 30 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 31 | 0, 0.0);
  var ii = Caml_int32.div(i, Reprocessing_Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 3 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 4 | 0, ii + 2 | 0);
  Curry._3(set, elementArrayToMutate, j + 5 | 0, ii + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + (Reprocessing_Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 6 | 0;
  return /* () */0;
}

function drawTriangle(env, param, param$1, param$2, param$3) {
  maybeFlushBatch(/* None */0, 24, 3, env);
  var set = Reasongl.Gl[/* Bigarray */23][/* set */4];
  var match_000 = param$3[/* r */0] / 255;
  var match_001 = param$3[/* g */1] / 255;
  var match_002 = param$3[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var i = env[/* batch */10][/* vertexPtr */2];
  var vertexArrayToMutate = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArrayToMutate, i + 0 | 0, param[0]);
  Curry._3(set, vertexArrayToMutate, i + 1 | 0, param[1]);
  Curry._3(set, vertexArrayToMutate, i + 2 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 3 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 4 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 5 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 6 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 7 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 8 | 0, param$1[0]);
  Curry._3(set, vertexArrayToMutate, i + 9 | 0, param$1[1]);
  Curry._3(set, vertexArrayToMutate, i + 10 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 11 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 12 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 13 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 14 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 15 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 16 | 0, param$2[0]);
  Curry._3(set, vertexArrayToMutate, i + 17 | 0, param$2[1]);
  Curry._3(set, vertexArrayToMutate, i + 18 | 0, r);
  Curry._3(set, vertexArrayToMutate, i + 19 | 0, g);
  Curry._3(set, vertexArrayToMutate, i + 20 | 0, b);
  Curry._3(set, vertexArrayToMutate, i + 21 | 0, 1);
  Curry._3(set, vertexArrayToMutate, i + 22 | 0, 0.0);
  Curry._3(set, vertexArrayToMutate, i + 23 | 0, 0.0);
  var ii = Caml_int32.div(i, Reprocessing_Common.vertexSize);
  var j = env[/* batch */10][/* elementPtr */3];
  var elementArrayToMutate = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArrayToMutate, j + 0 | 0, ii);
  Curry._3(set, elementArrayToMutate, j + 1 | 0, ii + 1 | 0);
  Curry._3(set, elementArrayToMutate, j + 2 | 0, ii + 2 | 0);
  env[/* batch */10][/* vertexPtr */2] = i + Caml_int32.imul(3, Reprocessing_Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = j + 3 | 0;
  return /* () */0;
}

function drawLine(param, param$1, color, width, project, env) {
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  var dx = xx2 - xx1;
  var dy = yy2 - yy1;
  var mag = Math.sqrt(dx * dx + dy * dy);
  var radius = width / 2;
  var xthing = dy / mag * radius;
  var ything = -dx / mag * radius;
  var match = project !== 0 ? /* tuple */[
      dx / mag * radius,
      xthing
    ] : /* tuple */[
      0,
      0
    ];
  var projecty = match[1];
  var projectx = match[0];
  var x1 = xx2 + xthing + projectx;
  var y1 = yy2 + ything + projecty;
  var x2 = xx1 + xthing - projectx;
  var y2 = yy1 + ything - projecty;
  var x3 = xx2 - xthing + projectx;
  var y3 = yy2 - ything + projecty;
  var x4 = xx1 - xthing - projectx;
  var y4 = yy1 - ything - projecty;
  return addRectToGlobalBatch(env, /* tuple */[
              x1,
              y1
            ], /* tuple */[
              x2,
              y2
            ], /* tuple */[
              x3,
              y3
            ], /* tuple */[
              x4,
              y4
            ], color);
}

function drawArc(env, param, radx, rady, start, stop, isPie, matrix, param$1) {
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var noOfFans = ((radx + rady | 0) / 4 | 0) + 10 | 0;
  maybeFlushBatch(/* None */0, Caml_int32.imul(3, noOfFans), (noOfFans << 3), env);
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var match_000 = param$1[/* r */0] / 255;
  var match_001 = param$1[/* g */1] / 255;
  var match_002 = param$1[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var set = Reasongl.Gl[/* Bigarray */23][/* set */4];
  var get = Reasongl.Gl[/* Bigarray */23][/* get */3];
  var vertexArrayOffset = env[/* batch */10][/* vertexPtr */2];
  var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
  var start_i = isPie ? (start / anglePerFan | 0) - 2 | 0 : (start / anglePerFan | 0) - 1 | 0;
  var stop_i = (stop / anglePerFan | 0) - 1 | 0;
  for(var i = start_i; i <= stop_i; ++i){
    var param$2;
    if (isPie && (i - start_i | 0) === 0) {
      param$2 = /* tuple */[
        xCenterOfCircle,
        yCenterOfCircle
      ];
    } else {
      var angle = anglePerFan * (i + 1 | 0);
      param$2 = /* tuple */[
        xCenterOfCircle + Math.cos(angle) * radx,
        yCenterOfCircle + Math.sin(angle) * rady
      ];
    }
    var match = Reprocessing_Matrix.matptmul(matrix, param$2);
    var ii = Caml_int32.imul(i - start_i | 0, Reprocessing_Common.vertexSize) + vertexArrayOffset | 0;
    Curry._3(set, verticesData, ii + 0 | 0, match[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    if ((i - start_i | 0) < 3) {
      Curry._3(set, elementData, (i - start_i | 0) + elementArrayOffset | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
    } else {
      var jj = (Caml_int32.imul((i - start_i | 0) - 3 | 0, 3) + elementArrayOffset | 0) + 3 | 0;
      Curry._3(set, elementData, jj, Caml_int32.div(vertexArrayOffset, Reprocessing_Common.vertexSize));
      Curry._3(set, elementData, jj + 1 | 0, Curry._2(get, elementData, jj - 1 | 0));
      Curry._3(set, elementData, jj + 2 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
    }
  }
  env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + Caml_int32.imul(noOfFans, Reprocessing_Common.vertexSize) | 0;
  env[/* batch */10][/* elementPtr */3] = (env[/* batch */10][/* elementPtr */3] + Caml_int32.imul((stop_i - start_i | 0) - 3 | 0, 3) | 0) + 3 | 0;
  return /* () */0;
}

function drawEllipse(env, center, radx, rady, matrix, c) {
  return drawArc(env, center, radx, rady, 0, Reprocessing_Constants.tau, /* false */0, matrix, c);
}

function drawArcStroke(env, param, radx, rady, start, stop, isOpen, isPie, matrix, strokeColor, strokeWidth) {
  var yCenterOfCircle = param[1];
  var xCenterOfCircle = param[0];
  var match_000 = strokeColor[/* r */0] / 255;
  var match_001 = strokeColor[/* g */1] / 255;
  var match_002 = strokeColor[/* b */2] / 255;
  var b = match_002;
  var g = match_001;
  var r = match_000;
  var verticesData = env[/* batch */10][/* vertexArray */0];
  var elementData = env[/* batch */10][/* elementArray */1];
  var noOfFans = ((radx + rady | 0) / 4 | 0) + 10 | 0;
  var set = Reasongl.Gl[/* Bigarray */23][/* set */4];
  maybeFlushBatch(/* None */0, 6, 16, env);
  var pi = 4.0 * Math.atan(1.0);
  var anglePerFan = 2 * pi / noOfFans;
  var start_i = (start / anglePerFan | 0) - 1 | 0;
  var stop_i = (stop / anglePerFan | 0) - 1 | 0;
  var prevEl = /* None */0;
  var halfwidth = strokeWidth / 2;
  for(var i = start_i; i <= stop_i; ++i){
    var angle = anglePerFan * (i + 1 | 0);
    var param_000 = xCenterOfCircle + Math.cos(angle) * (radx - halfwidth);
    var param_001 = yCenterOfCircle + Math.sin(angle) * (rady - halfwidth);
    var param$1 = /* tuple */[
      param_000,
      param_001
    ];
    var match = Reprocessing_Matrix.matptmul(matrix, param$1);
    var param_000$1 = xCenterOfCircle + Math.cos(angle) * (radx + halfwidth);
    var param_001$1 = yCenterOfCircle + Math.sin(angle) * (rady + halfwidth);
    var param$2 = /* tuple */[
      param_000$1,
      param_001$1
    ];
    var match$1 = Reprocessing_Matrix.matptmul(matrix, param$2);
    var ii = env[/* batch */10][/* vertexPtr */2];
    Curry._3(set, verticesData, ii + 0 | 0, match[0]);
    Curry._3(set, verticesData, ii + 1 | 0, match[1]);
    Curry._3(set, verticesData, ii + 2 | 0, r);
    Curry._3(set, verticesData, ii + 3 | 0, g);
    Curry._3(set, verticesData, ii + 4 | 0, b);
    Curry._3(set, verticesData, ii + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii + 7 | 0, 0.0);
    var ii$1 = ii + Reprocessing_Common.vertexSize | 0;
    Curry._3(set, verticesData, ii$1 + 0 | 0, match$1[0]);
    Curry._3(set, verticesData, ii$1 + 1 | 0, match$1[1]);
    Curry._3(set, verticesData, ii$1 + 2 | 0, r);
    Curry._3(set, verticesData, ii$1 + 3 | 0, g);
    Curry._3(set, verticesData, ii$1 + 4 | 0, b);
    Curry._3(set, verticesData, ii$1 + 5 | 0, 1.0);
    Curry._3(set, verticesData, ii$1 + 6 | 0, 0.0);
    Curry._3(set, verticesData, ii$1 + 7 | 0, 0.0);
    env[/* batch */10][/* vertexPtr */2] = env[/* batch */10][/* vertexPtr */2] + (Reprocessing_Common.vertexSize << 1) | 0;
    var currOuter = Caml_int32.div(ii$1, Reprocessing_Common.vertexSize);
    var currInner = Caml_int32.div(ii$1, Reprocessing_Common.vertexSize) - 1 | 0;
    var currEl = /* Some */[/* tuple */[
        currInner,
        currOuter
      ]];
    var match$2 = prevEl;
    if (match$2) {
      var match$3 = match$2[0];
      var prevInner = match$3[0];
      var elementArrayOffset = env[/* batch */10][/* elementPtr */3];
      Curry._3(set, elementData, elementArrayOffset, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 1 | 0, match$3[1]);
      Curry._3(set, elementData, elementArrayOffset + 2 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 3 | 0, currOuter);
      Curry._3(set, elementData, elementArrayOffset + 4 | 0, prevInner);
      Curry._3(set, elementData, elementArrayOffset + 5 | 0, currInner);
      env[/* batch */10][/* elementPtr */3] = env[/* batch */10][/* elementPtr */3] + 6 | 0;
      prevEl = currEl;
    } else {
      prevEl = currEl;
    }
  }
  if (isOpen) {
    return 0;
  } else {
    var param_000$2 = xCenterOfCircle + Math.cos(start) * radx;
    var param_001$2 = yCenterOfCircle + Math.sin(start) * rady;
    var param$3 = /* tuple */[
      param_000$2,
      param_001$2
    ];
    var match$4 = Reprocessing_Matrix.matptmul(matrix, param$3);
    var startY = match$4[1];
    var startX = match$4[0];
    var param_000$3 = xCenterOfCircle + Math.cos(stop) * radx;
    var param_001$3 = yCenterOfCircle + Math.sin(stop) * rady;
    var param$4 = /* tuple */[
      param_000$3,
      param_001$3
    ];
    var match$5 = Reprocessing_Matrix.matptmul(matrix, param$4);
    var stopY = match$5[1];
    var stopX = match$5[0];
    if (isPie) {
      drawLine(/* tuple */[
            startX,
            startY
          ], /* tuple */[
            xCenterOfCircle,
            yCenterOfCircle
          ], strokeColor, halfwidth, /* false */0, env);
      drawLine(/* tuple */[
            stopX,
            stopY
          ], /* tuple */[
            xCenterOfCircle,
            yCenterOfCircle
          ], strokeColor, halfwidth, /* false */0, env);
      drawEllipse(env, Reprocessing_Matrix.matptmul(matrix, /* tuple */[
                xCenterOfCircle,
                yCenterOfCircle
              ]), halfwidth, halfwidth, matrix, strokeColor);
    } else {
      drawLine(/* tuple */[
            startX,
            startY
          ], /* tuple */[
            stopX,
            stopY
          ], strokeColor, halfwidth, /* false */0, env);
    }
    drawEllipse(env, /* tuple */[
          startX,
          startY
        ], halfwidth, halfwidth, matrix, strokeColor);
    return drawEllipse(env, /* tuple */[
                stopX,
                stopY
              ], halfwidth, halfwidth, matrix, strokeColor);
  }
}

function loadImage(env, filename) {
  var imageRef = [/* None */0];
  Curry._4(Reasongl.Gl[/* loadImage */27], filename, /* None */0, (function (imageData) {
          if (imageData) {
            var img = imageData[0];
            var textureBuffer = Curry._1(Reasongl.Gl[/* createTexture */16], env[/* gl */2]);
            var height = Curry._1(Reasongl.Gl[/* getImageHeight */26], img);
            var width = Curry._1(Reasongl.Gl[/* getImageWidth */25], img);
            imageRef[0] = /* Some */[/* record */[
                /* textureBuffer */textureBuffer,
                /* img */img,
                /* height */height,
                /* width */width
              ]];
            Curry._3(Reasongl.Gl[/* bindTexture */18], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
            Curry._4(Reasongl.Gl[/* texImage2DWithImage */28], env[/* gl */2], RGLConstants.texture_2d, 0, img);
            Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
            Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear);
            Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_s, RGLConstants.clamp_to_edge);
            return Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_t, RGLConstants.clamp_to_edge);
          } else {
            return Pervasives.failwith("Could not load image '" + (filename + "'."));
          }
        }), /* () */0);
  return imageRef;
}

function drawImage(param, x, y, width, height, subx, suby, subw, subh, env) {
  var imgw = param[/* width */3];
  var imgh = param[/* height */2];
  var textureBuffer = param[/* textureBuffer */0];
  maybeFlushBatch(/* Some */[textureBuffer], 6, 32, env);
  var match_000 = subx / imgw;
  var match_001 = suby / imgh;
  var match_002 = subw / imgw;
  var match_003 = subh / imgh;
  var fsubh = match_003;
  var fsubw = match_002;
  var fsuby = match_001;
  var fsubx = match_000;
  var match_000$1 = x + width | 0;
  var match_001$1 = y + height | 0;
  var match_001$2 = y + height | 0;
  var match_000$2 = x + width | 0;
  var set = Reasongl.Gl[/* Bigarray */23][/* set */4];
  var ii = env[/* batch */10][/* vertexPtr */2];
  var vertexArray = env[/* batch */10][/* vertexArray */0];
  Curry._3(set, vertexArray, ii + 0 | 0, match_000$1);
  Curry._3(set, vertexArray, ii + 1 | 0, match_001$1);
  Curry._3(set, vertexArray, ii + 2 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 3 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 4 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 5 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 6 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 7 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 8 | 0, x);
  Curry._3(set, vertexArray, ii + 9 | 0, match_001$2);
  Curry._3(set, vertexArray, ii + 10 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 11 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 12 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 13 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 14 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 15 | 0, fsuby + fsubh);
  Curry._3(set, vertexArray, ii + 16 | 0, match_000$2);
  Curry._3(set, vertexArray, ii + 17 | 0, y);
  Curry._3(set, vertexArray, ii + 18 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 19 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 20 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 21 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 22 | 0, fsubx + fsubw);
  Curry._3(set, vertexArray, ii + 23 | 0, fsuby);
  Curry._3(set, vertexArray, ii + 24 | 0, x);
  Curry._3(set, vertexArray, ii + 25 | 0, y);
  Curry._3(set, vertexArray, ii + 26 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 27 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 28 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 29 | 0, 0.0);
  Curry._3(set, vertexArray, ii + 30 | 0, fsubx);
  Curry._3(set, vertexArray, ii + 31 | 0, fsuby);
  var jj = env[/* batch */10][/* elementPtr */3];
  var elementArray = env[/* batch */10][/* elementArray */1];
  Curry._3(set, elementArray, jj, Caml_int32.div(ii, Reprocessing_Common.vertexSize));
  Curry._3(set, elementArray, jj + 1 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 2 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 3 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 1 | 0);
  Curry._3(set, elementArray, jj + 4 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 2 | 0);
  Curry._3(set, elementArray, jj + 5 | 0, Caml_int32.div(ii, Reprocessing_Common.vertexSize) + 3 | 0);
  env[/* batch */10][/* vertexPtr */2] = ii + (Reprocessing_Common.vertexSize << 2) | 0;
  env[/* batch */10][/* elementPtr */3] = jj + 6 | 0;
  env[/* batch */10][/* currTex */4] = /* Some */[textureBuffer];
  return /* () */0;
}

function resetSize(env, width, height) {
  env[/* size */18][/* width */1] = width;
  env[/* size */18][/* height */0] = height;
  Curry._5(Reasongl.Gl[/* viewport */33], env[/* gl */2], 0, 0, width, height);
  Curry._5(Reasongl.Gl[/* clearColor */5], env[/* gl */2], 0, 0, 0, 1);
  Curry._7(Reasongl.Gl[/* Mat4 */39][/* ortho */6], env[/* camera */0][/* projectionMatrix */0], 0, width, height, 0, 0, 1);
  return Curry._3(Reasongl.Gl[/* uniformMatrix4fv */40], env[/* gl */2], env[/* pMatrixUniform */8], env[/* camera */0][/* projectionMatrix */0]);
}

var Matrix = 0;

exports.Matrix               = Matrix;
exports.getProgram           = getProgram;
exports.createCanvas         = createCanvas;
exports.drawGeometry         = drawGeometry;
exports.flushGlobalBatch     = flushGlobalBatch;
exports.maybeFlushBatch      = maybeFlushBatch;
exports.toColorFloat         = toColorFloat;
exports.addRectToGlobalBatch = addRectToGlobalBatch;
exports.drawTriangle         = drawTriangle;
exports.drawLine             = drawLine;
exports.drawArc              = drawArc;
exports.drawEllipse          = drawEllipse;
exports.drawArcStroke        = drawArcStroke;
exports.loadImage            = loadImage;
exports.drawImage            = drawImage;
exports.resetSize            = resetSize;
/* Reasongl Not a pure module */


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE



var pi = 4.0 * Math.atan(1.0);

var two_pi = 2.0 * pi;

var half_pi = 0.5 * pi;

var quarter_pi = 0.25 * pi;

var white = /* record */[
  /* r */255,
  /* g */255,
  /* b */255
];

var black = /* record */[
  /* r */0,
  /* g */0,
  /* b */0
];

var red = /* record */[
  /* r */255,
  /* g */0,
  /* b */0
];

var green = /* record */[
  /* r */0,
  /* g */255,
  /* b */0
];

var blue = /* record */[
  /* r */0,
  /* g */0,
  /* b */255
];

var tau = two_pi;

exports.white      = white;
exports.black      = black;
exports.red        = red;
exports.green      = green;
exports.blue       = blue;
exports.pi         = pi;
exports.half_pi    = half_pi;
exports.quarter_pi = quarter_pi;
exports.two_pi     = two_pi;
exports.tau        = tau;
/* pi Not a pure module */


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var Caml_builtin_exceptions = __webpack_require__(0);

function caml_sys_getenv(s) {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    var match$1 = match.env[s];
    if (match$1 !== undefined) {
      return match$1;
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function caml_sys_time() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.uptime();
  } else {
    return -1;
  }
}

function caml_sys_random_seed() {
  return /* array */[((Date.now() | 0) ^ 4294967295) * Math.random() | 0];
}

function caml_sys_system_command() {
  return 127;
}

function caml_sys_getcwd() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.cwd();
  } else {
    return "/";
  }
}

function caml_sys_get_argv() {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return /* tuple */[
            match.argv[0],
            match.argv
          ];
  } else {
    return /* tuple */[
            "",
            /* array */[""]
          ];
  }
}

function caml_sys_exit(exit_code) {
  var match = typeof (process) === "undefined" ? undefined : (process);
  if (match !== undefined) {
    return match.exit(exit_code);
  } else {
    return /* () */0;
  }
}

function caml_sys_is_directory() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_sys_is_directory not implemented"
      ];
}

function caml_sys_file_exists() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_sys_file_exists not implemented"
      ];
}

exports.caml_sys_getenv         = caml_sys_getenv;
exports.caml_sys_time           = caml_sys_time;
exports.caml_sys_random_seed    = caml_sys_random_seed;
exports.caml_sys_system_command = caml_sys_system_command;
exports.caml_sys_getcwd         = caml_sys_getcwd;
exports.caml_sys_get_argv       = caml_sys_get_argv;
exports.caml_sys_exit           = caml_sys_exit;
exports.caml_sys_is_directory   = caml_sys_is_directory;
exports.caml_sys_file_exists    = caml_sys_file_exists;
/* No side effect */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_obj                = __webpack_require__(4);
var Caml_int32              = __webpack_require__(5);
var Caml_utils              = __webpack_require__(26);
var Caml_builtin_exceptions = __webpack_require__(0);

var min_int = /* record */[
  /* hi */-2147483648,
  /* lo */0
];

var max_int = /* record */[
  /* hi */134217727,
  /* lo */1
];

var one = /* record */[
  /* hi */0,
  /* lo */1
];

var zero = /* record */[
  /* hi */0,
  /* lo */0
];

var neg_one = /* record */[
  /* hi */-1,
  /* lo */4294967295
];

function neg_signed(x) {
  return +((x & 2147483648) !== 0);
}

function add(param, param$1) {
  var other_low_ = param$1[/* lo */1];
  var this_low_ = param[/* lo */1];
  var lo = this_low_ + other_low_ & 4294967295;
  var overflow = neg_signed(this_low_) && (neg_signed(other_low_) || !neg_signed(lo)) || neg_signed(other_low_) && !neg_signed(lo) ? 1 : 0;
  var hi = param[/* hi */0] + param$1[/* hi */0] + overflow & 4294967295;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function not(param) {
  var hi = param[/* hi */0] ^ -1;
  var lo = param[/* lo */1] ^ -1;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function eq(x, y) {
  if (x[/* hi */0] === y[/* hi */0]) {
    return +(x[/* lo */1] === y[/* lo */1]);
  } else {
    return /* false */0;
  }
}

function neg(x) {
  if (eq(x, min_int)) {
    return min_int;
  } else {
    return add(not(x), one);
  }
}

function sub(x, y) {
  return add(x, neg(y));
}

function lsl_(x, numBits) {
  if (numBits) {
    var lo = x[/* lo */1];
    if (numBits >= 32) {
      return /* record */[
              /* hi */(lo << (numBits - 32 | 0)),
              /* lo */0
            ];
    } else {
      var hi = (lo >>> (32 - numBits | 0)) | (x[/* hi */0] << numBits);
      return /* record */[
              /* hi */hi,
              /* lo */((lo << numBits) >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function lsr_(x, numBits) {
  if (numBits) {
    var hi = x[/* hi */0];
    var offset = numBits - 32 | 0;
    if (offset) {
      if (offset > 0) {
        var lo = (hi >>> offset);
        return /* record */[
                /* hi */0,
                /* lo */(lo >>> 0)
              ];
      } else {
        var hi$1 = (hi >>> numBits);
        var lo$1 = (hi << (-offset | 0)) | (x[/* lo */1] >>> numBits);
        return /* record */[
                /* hi */hi$1,
                /* lo */(lo$1 >>> 0)
              ];
      }
    } else {
      return /* record */[
              /* hi */0,
              /* lo */(hi >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function asr_(x, numBits) {
  if (numBits) {
    var hi = x[/* hi */0];
    if (numBits < 32) {
      var hi$1 = (hi >> numBits);
      var lo = (hi << (32 - numBits | 0)) | (x[/* lo */1] >>> numBits);
      return /* record */[
              /* hi */hi$1,
              /* lo */(lo >>> 0)
            ];
    } else {
      var lo$1 = (hi >> (numBits - 32 | 0));
      return /* record */[
              /* hi */hi >= 0 ? 0 : -1,
              /* lo */(lo$1 >>> 0)
            ];
    }
  } else {
    return x;
  }
}

function is_zero(param) {
  if (param[/* hi */0] !== 0 || param[/* lo */1] !== 0) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function mul(_this, _other) {
  while(true) {
    var other = _other;
    var $$this = _this;
    var exit = 0;
    var lo;
    var this_hi = $$this[/* hi */0];
    var exit$1 = 0;
    var exit$2 = 0;
    var exit$3 = 0;
    if (this_hi !== 0) {
      exit$3 = 4;
    } else if ($$this[/* lo */1] !== 0) {
      exit$3 = 4;
    } else {
      return zero;
    }
    if (exit$3 === 4) {
      if (other[/* hi */0] !== 0) {
        exit$2 = 3;
      } else if (other[/* lo */1] !== 0) {
        exit$2 = 3;
      } else {
        return zero;
      }
    }
    if (exit$2 === 3) {
      if (this_hi !== -2147483648) {
        exit$1 = 2;
      } else if ($$this[/* lo */1] !== 0) {
        exit$1 = 2;
      } else {
        lo = other[/* lo */1];
        exit = 1;
      }
    }
    if (exit$1 === 2) {
      var other_hi = other[/* hi */0];
      var lo$1 = $$this[/* lo */1];
      var exit$4 = 0;
      if (other_hi !== -2147483648) {
        exit$4 = 3;
      } else if (other[/* lo */1] !== 0) {
        exit$4 = 3;
      } else {
        lo = lo$1;
        exit = 1;
      }
      if (exit$4 === 3) {
        var other_lo = other[/* lo */1];
        if (this_hi < 0) {
          if (other_hi < 0) {
            _other = neg(other);
            _this = neg($$this);
            continue ;
            
          } else {
            return neg(mul(neg($$this), other));
          }
        } else if (other_hi < 0) {
          return neg(mul($$this, neg(other)));
        } else {
          var a48 = (this_hi >>> 16);
          var a32 = this_hi & 65535;
          var a16 = (lo$1 >>> 16);
          var a00 = lo$1 & 65535;
          var b48 = (other_hi >>> 16);
          var b32 = other_hi & 65535;
          var b16 = (other_lo >>> 16);
          var b00 = other_lo & 65535;
          var c48 = 0;
          var c32 = 0;
          var c16 = 0;
          var c00 = a00 * b00;
          c16 = (c00 >>> 16) + a16 * b00;
          c32 = (c16 >>> 16);
          c16 = (c16 & 65535) + a00 * b16;
          c32 = c32 + (c16 >>> 16) + a32 * b00;
          c48 = (c32 >>> 16);
          c32 = (c32 & 65535) + a16 * b16;
          c48 += (c32 >>> 16);
          c32 = (c32 & 65535) + a00 * b32;
          c48 += (c32 >>> 16);
          c32 = c32 & 65535;
          c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;
          var hi = c32 | (c48 << 16);
          var lo$2 = c00 & 65535 | ((c16 & 65535) << 16);
          return /* record */[
                  /* hi */hi,
                  /* lo */(lo$2 >>> 0)
                ];
        }
      }
      
    }
    if (exit === 1) {
      if ((lo & 1) === 0) {
        return zero;
      } else {
        return min_int;
      }
    }
    
  };
}

function swap(param) {
  var hi = Caml_int32.caml_int32_bswap(param[/* lo */1]);
  var lo = Caml_int32.caml_int32_bswap(param[/* hi */0]);
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function xor(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] ^ param$1[/* hi */0],
          /* lo */((param[/* lo */1] ^ param$1[/* lo */1]) >>> 0)
        ];
}

function or_(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] | param$1[/* hi */0],
          /* lo */((param[/* lo */1] | param$1[/* lo */1]) >>> 0)
        ];
}

function and_(param, param$1) {
  return /* record */[
          /* hi */param[/* hi */0] & param$1[/* hi */0],
          /* lo */((param[/* lo */1] & param$1[/* lo */1]) >>> 0)
        ];
}

function ge(param, param$1) {
  var other_hi = param$1[/* hi */0];
  var hi = param[/* hi */0];
  if (hi > other_hi) {
    return /* true */1;
  } else if (hi < other_hi) {
    return /* false */0;
  } else {
    return +(param[/* lo */1] >= param$1[/* lo */1]);
  }
}

function neq(x, y) {
  return 1 - eq(x, y);
}

function lt(x, y) {
  return 1 - ge(x, y);
}

function gt(x, y) {
  if (x[/* hi */0] > y[/* hi */0]) {
    return /* true */1;
  } else if (x[/* hi */0] < y[/* hi */0]) {
    return /* false */0;
  } else {
    return +(x[/* lo */1] > y[/* lo */1]);
  }
}

function le(x, y) {
  return 1 - gt(x, y);
}

function to_float(param) {
  return param[/* hi */0] * (0x100000000) + param[/* lo */1];
}

var two_ptr_32_dbl = Math.pow(2, 32);

var two_ptr_63_dbl = Math.pow(2, 63);

var neg_two_ptr_63 = -Math.pow(2, 63);

function of_float(x) {
  if (isNaN(x) || !isFinite(x)) {
    return zero;
  } else if (x <= neg_two_ptr_63) {
    return min_int;
  } else if (x + 1 >= two_ptr_63_dbl) {
    return max_int;
  } else if (x < 0) {
    return neg(of_float(-x));
  } else {
    var hi = x / two_ptr_32_dbl | 0;
    var lo = x % two_ptr_32_dbl | 0;
    return /* record */[
            /* hi */hi,
            /* lo */(lo >>> 0)
          ];
  }
}

function div(_self, _other) {
  while(true) {
    var other = _other;
    var self = _self;
    var self_hi = self[/* hi */0];
    var exit = 0;
    var exit$1 = 0;
    if (other[/* hi */0] !== 0) {
      exit$1 = 2;
    } else if (other[/* lo */1] !== 0) {
      exit$1 = 2;
    } else {
      throw Caml_builtin_exceptions.division_by_zero;
    }
    if (exit$1 === 2) {
      if (self_hi !== -2147483648) {
        if (self_hi !== 0) {
          exit = 1;
        } else if (self[/* lo */1] !== 0) {
          exit = 1;
        } else {
          return zero;
        }
      } else if (self[/* lo */1] !== 0) {
        exit = 1;
      } else if (eq(other, one) || eq(other, neg_one)) {
        return self;
      } else if (eq(other, min_int)) {
        return one;
      } else {
        var other_hi = other[/* hi */0];
        var half_this = asr_(self, 1);
        var approx = lsl_(div(half_this, other), 1);
        var exit$2 = 0;
        if (approx[/* hi */0] !== 0) {
          exit$2 = 3;
        } else if (approx[/* lo */1] !== 0) {
          exit$2 = 3;
        } else if (other_hi < 0) {
          return one;
        } else {
          return neg(one);
        }
        if (exit$2 === 3) {
          var y = mul(other, approx);
          var rem = add(self, neg(y));
          return add(approx, div(rem, other));
        }
        
      }
    }
    if (exit === 1) {
      var other_hi$1 = other[/* hi */0];
      var exit$3 = 0;
      if (other_hi$1 !== -2147483648) {
        exit$3 = 2;
      } else if (other[/* lo */1] !== 0) {
        exit$3 = 2;
      } else {
        return zero;
      }
      if (exit$3 === 2) {
        if (self_hi < 0) {
          if (other_hi$1 < 0) {
            _other = neg(other);
            _self = neg(self);
            continue ;
            
          } else {
            return neg(div(neg(self), other));
          }
        } else if (other_hi$1 < 0) {
          return neg(div(self, neg(other)));
        } else {
          var res = zero;
          var rem$1 = self;
          while(ge(rem$1, other)) {
            var approx$1 = Math.max(1, Math.floor(to_float(rem$1) / to_float(other)));
            var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);
            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
            var approxRes = of_float(approx$1);
            var approxRem = mul(approxRes, other);
            while(approxRem[/* hi */0] < 0 || gt(approxRem, rem$1)) {
              approx$1 -= delta;
              approxRes = of_float(approx$1);
              approxRem = mul(approxRes, other);
            };
            if (is_zero(approxRes)) {
              approxRes = one;
            }
            res = add(res, approxRes);
            rem$1 = add(rem$1, neg(approxRem));
          };
          return res;
        }
      }
      
    }
    
  };
}

function mod_(self, other) {
  var y = mul(div(self, other), other);
  return add(self, neg(y));
}

function div_mod(self, other) {
  var quotient = div(self, other);
  var y = mul(quotient, other);
  return /* tuple */[
          quotient,
          add(self, neg(y))
        ];
}

function compare(self, other) {
  var v = Caml_obj.caml_nativeint_compare(self[/* hi */0], other[/* hi */0]);
  if (v) {
    return v;
  } else {
    return Caml_obj.caml_nativeint_compare(self[/* lo */1], other[/* lo */1]);
  }
}

function of_int32(lo) {
  return /* record */[
          /* hi */lo < 0 ? -1 : 0,
          /* lo */(lo >>> 0)
        ];
}

function to_int32(x) {
  return x[/* lo */1] | 0;
}

function to_hex(x) {
  var aux = function (v) {
    return (v >>> 0).toString(16);
  };
  var match = x[/* hi */0];
  var match$1 = x[/* lo */1];
  var exit = 0;
  if (match !== 0) {
    exit = 1;
  } else if (match$1 !== 0) {
    exit = 1;
  } else {
    return "0";
  }
  if (exit === 1) {
    if (match$1 !== 0) {
      if (match !== 0) {
        var lo = aux(x[/* lo */1]);
        var pad = 8 - lo.length | 0;
        if (pad <= 0) {
          return aux(x[/* hi */0]) + lo;
        } else {
          return aux(x[/* hi */0]) + (Caml_utils.repeat(pad, "0") + lo);
        }
      } else {
        return aux(x[/* lo */1]);
      }
    } else {
      return aux(x[/* hi */0]) + "00000000";
    }
  }
  
}

function discard_sign(x) {
  return /* record */[
          /* hi */2147483647 & x[/* hi */0],
          /* lo */x[/* lo */1]
        ];
}

function float_of_bits(x) {
  var int32 = new Int32Array(/* array */[
        x[/* lo */1],
        x[/* hi */0]
      ]);
  return new Float64Array(int32.buffer)[0];
}

function bits_of_float(x) {
  var u = new Float64Array(/* float array */[x]);
  var int32 = new Int32Array(u.buffer);
  var x$1 = int32[1];
  var hi = x$1;
  var x$2 = int32[0];
  var lo = x$2;
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

function get64(s, i) {
  var hi = (s.charCodeAt(i + 4 | 0) << 32) | (s.charCodeAt(i + 5 | 0) << 40) | (s.charCodeAt(i + 6 | 0) << 48) | (s.charCodeAt(i + 7 | 0) << 56);
  var lo = s.charCodeAt(i) | (s.charCodeAt(i + 1 | 0) << 8) | (s.charCodeAt(i + 2 | 0) << 16) | (s.charCodeAt(i + 3 | 0) << 24);
  return /* record */[
          /* hi */hi,
          /* lo */(lo >>> 0)
        ];
}

exports.min_int       = min_int;
exports.max_int       = max_int;
exports.one           = one;
exports.zero          = zero;
exports.not           = not;
exports.of_int32      = of_int32;
exports.to_int32      = to_int32;
exports.add           = add;
exports.neg           = neg;
exports.sub           = sub;
exports.lsl_          = lsl_;
exports.lsr_          = lsr_;
exports.asr_          = asr_;
exports.is_zero       = is_zero;
exports.mul           = mul;
exports.xor           = xor;
exports.or_           = or_;
exports.and_          = and_;
exports.swap          = swap;
exports.ge            = ge;
exports.eq            = eq;
exports.neq           = neq;
exports.lt            = lt;
exports.gt            = gt;
exports.le            = le;
exports.to_float      = to_float;
exports.of_float      = of_float;
exports.div           = div;
exports.mod_          = mod_;
exports.div_mod       = div_mod;
exports.compare       = compare;
exports.to_hex        = to_hex;
exports.discard_sign  = discard_sign;
exports.float_of_bits = float_of_bits;
exports.bits_of_float = bits_of_float;
exports.get64         = get64;
/* two_ptr_32_dbl Not a pure module */


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var List        = __webpack_require__(9);
var Bytes       = __webpack_require__(40);
var Caml_int32  = __webpack_require__(5);
var Caml_string = __webpack_require__(6);

function make(n, c) {
  return Caml_string.bytes_to_string(Bytes.make(n, c));
}

function init(n, f) {
  return Caml_string.bytes_to_string(Bytes.init(n, f));
}

function copy(s) {
  return Caml_string.bytes_to_string(Bytes.copy(Caml_string.bytes_of_string(s)));
}

function sub(s, ofs, len) {
  return Caml_string.bytes_to_string(Bytes.sub(Caml_string.bytes_of_string(s), ofs, len));
}

function concat(sep, l) {
  if (l) {
    var hd = l[0];
    var num = [0];
    var len = [0];
    List.iter((function (s) {
            num[0] = num[0] + 1 | 0;
            len[0] = len[0] + s.length | 0;
            return /* () */0;
          }), l);
    var r = Caml_string.caml_create_string(len[0] + Caml_int32.imul(sep.length, num[0] - 1 | 0) | 0);
    Caml_string.caml_blit_string(hd, 0, r, 0, hd.length);
    var pos = [hd.length];
    List.iter((function (s) {
            Caml_string.caml_blit_string(sep, 0, r, pos[0], sep.length);
            pos[0] = pos[0] + sep.length | 0;
            Caml_string.caml_blit_string(s, 0, r, pos[0], s.length);
            pos[0] = pos[0] + s.length | 0;
            return /* () */0;
          }), l[1]);
    return Caml_string.bytes_to_string(r);
  } else {
    return "";
  }
}

function iter(f, s) {
  return Bytes.iter(f, Caml_string.bytes_of_string(s));
}

function iteri(f, s) {
  return Bytes.iteri(f, Caml_string.bytes_of_string(s));
}

function map(f, s) {
  return Caml_string.bytes_to_string(Bytes.map(f, Caml_string.bytes_of_string(s)));
}

function mapi(f, s) {
  return Caml_string.bytes_to_string(Bytes.mapi(f, Caml_string.bytes_of_string(s)));
}

function is_space(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    if (switcher !== 23) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (switcher !== 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function trim(s) {
  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return Caml_string.bytes_to_string(Bytes.trim(Caml_string.bytes_of_string(s)));
  }
}

function escaped(s) {
  var needs_escape = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return /* false */0;
      } else {
        var match = s.charCodeAt(i);
        if (match >= 32) {
          var switcher = match - 34 | 0;
          if (switcher > 58 || switcher < 0) {
            if (switcher >= 93) {
              return /* true */1;
            } else {
              _i = i + 1 | 0;
              continue ;
              
            }
          } else if (switcher > 57 || switcher < 1) {
            return /* true */1;
          } else {
            _i = i + 1 | 0;
            continue ;
            
          }
        } else {
          return /* true */1;
        }
      }
    };
  };
  if (needs_escape(0)) {
    return Caml_string.bytes_to_string(Bytes.escaped(Caml_string.bytes_of_string(s)));
  } else {
    return s;
  }
}

function index(s, c) {
  return Bytes.index(Caml_string.bytes_of_string(s), c);
}

function rindex(s, c) {
  return Bytes.rindex(Caml_string.bytes_of_string(s), c);
}

function index_from(s, i, c) {
  return Bytes.index_from(Caml_string.bytes_of_string(s), i, c);
}

function rindex_from(s, i, c) {
  return Bytes.rindex_from(Caml_string.bytes_of_string(s), i, c);
}

function contains(s, c) {
  return Bytes.contains(Caml_string.bytes_of_string(s), c);
}

function contains_from(s, i, c) {
  return Bytes.contains_from(Caml_string.bytes_of_string(s), i, c);
}

function rcontains_from(s, i, c) {
  return Bytes.rcontains_from(Caml_string.bytes_of_string(s), i, c);
}

function uppercase(s) {
  return Caml_string.bytes_to_string(Bytes.uppercase(Caml_string.bytes_of_string(s)));
}

function lowercase(s) {
  return Caml_string.bytes_to_string(Bytes.lowercase(Caml_string.bytes_of_string(s)));
}

function capitalize(s) {
  return Caml_string.bytes_to_string(Bytes.capitalize(Caml_string.bytes_of_string(s)));
}

function uncapitalize(s) {
  return Caml_string.bytes_to_string(Bytes.uncapitalize(Caml_string.bytes_of_string(s)));
}

var compare = Caml_string.caml_string_compare;

var fill = Bytes.fill;

var blit = Bytes.blit_string;

exports.make           = make;
exports.init           = init;
exports.copy           = copy;
exports.sub            = sub;
exports.fill           = fill;
exports.blit           = blit;
exports.concat         = concat;
exports.iter           = iter;
exports.iteri          = iteri;
exports.map            = map;
exports.mapi           = mapi;
exports.trim           = trim;
exports.escaped        = escaped;
exports.index          = index;
exports.rindex         = rindex;
exports.index_from     = index_from;
exports.rindex_from    = rindex_from;
exports.contains       = contains;
exports.contains_from  = contains_from;
exports.rcontains_from = rcontains_from;
exports.uppercase      = uppercase;
exports.lowercase      = lowercase;
exports.capitalize     = capitalize;
exports.uncapitalize   = uncapitalize;
exports.compare        = compare;
/* No side effect */


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                 = __webpack_require__(1);
var Reasongl              = __webpack_require__(10);
var Reprocessing_Internal = __webpack_require__(13);

function width(env) {
  return env[/* size */18][/* width */1];
}

function height(env) {
  return env[/* size */18][/* height */0];
}

function mouse(env) {
  return env[/* mouse */12][/* pos */0];
}

function pmouse(env) {
  return env[/* mouse */12][/* prevPos */1];
}

function mousePressed(env) {
  return env[/* mouse */12][/* pressed */2];
}

function keyCode(env) {
  return env[/* keyboard */11][/* keyCode */0];
}

function size(width, height, env) {
  Curry._3(Reasongl.Gl[/* Window */2][/* setWindowSize */3], env[/* window */1], width, height);
  return Reprocessing_Internal.resetSize(env, width, height);
}

function resizeable(resizeable$1, env) {
  env[/* size */18][/* resizeable */2] = resizeable$1;
  return /* () */0;
}

function frameRate(env) {
  return env[/* frame */15][/* rate */1];
}

function frameCount(env) {
  return env[/* frame */15][/* count */0];
}

exports.width        = width;
exports.height       = height;
exports.mouse        = mouse;
exports.pmouse       = pmouse;
exports.mousePressed = mousePressed;
exports.keyCode      = keyCode;
exports.size         = size;
exports.resizeable   = resizeable;
exports.frameRate    = frameRate;
exports.frameCount   = frameCount;
/* Reasongl Not a pure module */


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var List                    = __webpack_require__(9);
var Curry                   = __webpack_require__(1);
var $$String                = __webpack_require__(17);
var Pervasives              = __webpack_require__(2);
var Caml_string             = __webpack_require__(6);
var Caml_builtin_exceptions = __webpack_require__(0);

function peekch(param) {
  var i = param[1];
  var str = param[0];
  if (i < str.length) {
    return /* Some */[Caml_string.get(str, i)];
  } else {
    return /* None */0;
  }
}

function popch(param) {
  return /* tuple */[
          param[0],
          param[1] + 1 | 0
        ];
}

function peekn(param, len) {
  var i = param[1];
  var str = param[0];
  if ((i + len | 0) < str.length) {
    return /* Some */[$$String.sub(str, i, len)];
  } else {
    return /* None */0;
  }
}

function popn(param, len) {
  return /* tuple */[
          param[0],
          param[1] + len | 0
        ];
}

function $$switch(stream, matchstr) {
  var len = matchstr.length;
  var match = peekn(stream, len);
  if (match) {
    var peek = match[0];
    if (peek === matchstr) {
      return popn(stream, len);
    } else {
      return Pervasives.failwith("Could not match '" + (matchstr + ("', got '" + (peek + "' instead."))));
    }
  } else {
    return Pervasives.failwith("Could not match " + matchstr);
  }
}

function charsRemaining(param) {
  return param[0].length - param[1] | 0;
}

function create(str) {
  return /* tuple */[
          str,
          0
        ];
}

var Stream = /* module */[
  /* empty : [] */0,
  /* peekch */peekch,
  /* popch */popch,
  /* peekn */peekn,
  /* popn */popn,
  /* switch */$$switch,
  /* charsRemaining */charsRemaining,
  /* create */create
];

function read(name) {
  var ic = Pervasives.open_in(name);
  var try_read = function () {
    var exit = 0;
    var x;
    try {
      x = Pervasives.input_line(ic);
      exit = 1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.end_of_file) {
        return /* None */0;
      } else {
        throw exn;
      }
    }
    if (exit === 1) {
      return /* Some */[x];
    }
    
  };
  var loop = function (_acc) {
    while(true) {
      var acc = _acc;
      var match = try_read(/* () */0);
      if (match) {
        _acc = /* :: */[
          $$String.make(1, /* "\n" */10),
          /* :: */[
            match[0],
            acc
          ]
        ];
        continue ;
        
      } else {
        Curry._1(Pervasives.close_in, ic);
        return List.rev(acc);
      }
    };
  };
  return $$String.concat("", loop(/* [] */0));
}

function append_char(s, c) {
  return s + $$String.make(1, c);
}

function split(str, sep) {
  var _stream = /* tuple */[
    str,
    0
  ];
  var sep$1 = sep;
  var _accstr = "";
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var accstr = _accstr;
    var stream = _stream;
    var match = peekch(stream);
    if (match) {
      var c = match[0];
      if (c === sep$1) {
        _acc = /* :: */[
          accstr,
          acc
        ];
        _accstr = "";
        _stream = popch(stream);
        continue ;
        
      } else {
        _accstr = append_char(accstr, c);
        _stream = popch(stream);
        continue ;
        
      }
    } else {
      return List.rev(/* :: */[
                  accstr,
                  acc
                ]);
    }
  };
}

var Constants = 0;

var circularBufferSize = 60000;

var vertexSize = 8;

exports.Constants          = Constants;
exports.circularBufferSize = circularBufferSize;
exports.vertexSize         = vertexSize;
exports.Stream             = Stream;
exports.read               = read;
exports.append_char        = append_char;
exports.split              = split;
/* No side effect */


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Caml_array              = __webpack_require__(7);
var Caml_builtin_exceptions = __webpack_require__(0);

var identity = /* float array */[
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1
];

function createIdentity() {
  return /* float array */[
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
}

function createTranslation(dx, dy) {
  return /* float array */[
          1,
          0,
          dx,
          0,
          1,
          dy,
          0,
          0,
          1
        ];
}

function createRotation(theta) {
  return /* float array */[
          Math.cos(theta),
          -Math.sin(theta),
          0,
          Math.sin(theta),
          Math.cos(theta),
          0,
          0,
          0,
          1
        ];
}

function copyInto(src, dst) {
  Caml_array.caml_array_set(dst, 0, Caml_array.caml_array_get(src, 0));
  Caml_array.caml_array_set(dst, 1, Caml_array.caml_array_get(src, 1));
  Caml_array.caml_array_set(dst, 2, Caml_array.caml_array_get(src, 2));
  Caml_array.caml_array_set(dst, 3, Caml_array.caml_array_get(src, 3));
  Caml_array.caml_array_set(dst, 4, Caml_array.caml_array_get(src, 4));
  Caml_array.caml_array_set(dst, 5, Caml_array.caml_array_get(src, 5));
  Caml_array.caml_array_set(dst, 6, Caml_array.caml_array_get(src, 6));
  Caml_array.caml_array_set(dst, 7, Caml_array.caml_array_get(src, 7));
  return Caml_array.caml_array_set(dst, 8, Caml_array.caml_array_get(src, 8));
}

function matmatmul(mat1, mat2) {
  if (mat1.length !== 9) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "Reprocessing_Matrix.re",
            52,
            9
          ]
        ];
  } else {
    var m0 = mat1[0];
    var m1 = mat1[1];
    var m2 = mat1[2];
    var m3 = mat1[3];
    var m4 = mat1[4];
    var m5 = mat1[5];
    var m6 = mat1[6];
    var m7 = mat1[7];
    var m8 = mat1[8];
    if (mat2.length !== 9) {
      throw [
            Caml_builtin_exceptions.assert_failure,
            [
              "Reprocessing_Matrix.re",
              52,
              9
            ]
          ];
    } else {
      var ma = mat2[0];
      var mb = mat2[1];
      var mc = mat2[2];
      var md = mat2[3];
      var me = mat2[4];
      var mf = mat2[5];
      var mg = mat2[6];
      var mh = mat2[7];
      var mi = mat2[8];
      Caml_array.caml_array_set(mat1, 0, ma * m0 + md * m1 + mg * m2);
      Caml_array.caml_array_set(mat1, 1, mb * m0 + me * m1 + mh * m2);
      Caml_array.caml_array_set(mat1, 2, mc * m0 + mf * m1 + mi * m2);
      Caml_array.caml_array_set(mat1, 3, ma * m3 + md * m4 + mg * m5);
      Caml_array.caml_array_set(mat1, 4, mb * m3 + me * m4 + mh * m5);
      Caml_array.caml_array_set(mat1, 5, mc * m3 + mf * m4 + mi * m5);
      Caml_array.caml_array_set(mat1, 6, ma * m6 + md * m7 + mg * m8);
      Caml_array.caml_array_set(mat1, 7, mb * m6 + me * m7 + mh * m8);
      return Caml_array.caml_array_set(mat1, 8, mc * m6 + mf * m7 + mi * m8);
    }
  }
}

function matvecmul(m, v) {
  var a = Caml_array.caml_array_get(v, 0);
  var b = Caml_array.caml_array_get(v, 1);
  var c = Caml_array.caml_array_get(v, 2);
  Caml_array.caml_array_set(v, 0, a * Caml_array.caml_array_get(m, 0) + b * Caml_array.caml_array_get(m, 1) + c * Caml_array.caml_array_get(m, 2));
  Caml_array.caml_array_set(v, 1, a * Caml_array.caml_array_get(m, 3) + b * Caml_array.caml_array_get(m, 4) + c * Caml_array.caml_array_get(m, 5));
  return Caml_array.caml_array_set(v, 2, a * Caml_array.caml_array_get(m, 6) + b * Caml_array.caml_array_get(m, 7) + c * Caml_array.caml_array_get(m, 8));
}

function matptmul(m, param) {
  var y = param[1];
  var x = param[0];
  return /* tuple */[
          x * Caml_array.caml_array_get(m, 0) + y * Caml_array.caml_array_get(m, 1) + Caml_array.caml_array_get(m, 2),
          x * Caml_array.caml_array_get(m, 3) + y * Caml_array.caml_array_get(m, 4) + Caml_array.caml_array_get(m, 5)
        ];
}

exports.identity          = identity;
exports.createIdentity    = createIdentity;
exports.createTranslation = createTranslation;
exports.createRotation    = createRotation;
exports.copyInto          = copyInto;
exports.matmatmul         = matmatmul;
exports.matvecmul         = matvecmul;
exports.matptmul          = matptmul;
/* No side effect */


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_sys        = __webpack_require__(15);
var Caml_exceptions = __webpack_require__(11);

var is_js = /* true */1;

var match = Caml_sys.caml_sys_get_argv(/* () */0);

var big_endian = /* false */0;

var unix = /* true */1;

var win32 = /* false */0;

var cygwin = /* false */0;

var max_array_length = 2147483647;

var max_string_length = 2147483647;

var interactive = [/* false */0];

function set_signal(_, _$1) {
  return /* () */0;
}

var Break = Caml_exceptions.create("Sys.Break");

function catch_break() {
  return /* () */0;
}

var argv = match[1];

var executable_name = match[0];

var os_type = "Unix";

var word_size = 32;

var sigabrt = -1;

var sigalrm = -2;

var sigfpe = -3;

var sighup = -4;

var sigill = -5;

var sigint = -6;

var sigkill = -7;

var sigpipe = -8;

var sigquit = -9;

var sigsegv = -10;

var sigterm = -11;

var sigusr1 = -12;

var sigusr2 = -13;

var sigchld = -14;

var sigcont = -15;

var sigstop = -16;

var sigtstp = -17;

var sigttin = -18;

var sigttou = -19;

var sigvtalrm = -20;

var sigprof = -21;

var ocaml_version = "4.02.3+dev1-2015-07-10";

exports.argv              = argv;
exports.executable_name   = executable_name;
exports.interactive       = interactive;
exports.os_type           = os_type;
exports.unix              = unix;
exports.win32             = win32;
exports.cygwin            = cygwin;
exports.word_size         = word_size;
exports.big_endian        = big_endian;
exports.is_js             = is_js;
exports.max_string_length = max_string_length;
exports.max_array_length  = max_array_length;
exports.set_signal        = set_signal;
exports.sigabrt           = sigabrt;
exports.sigalrm           = sigalrm;
exports.sigfpe            = sigfpe;
exports.sighup            = sighup;
exports.sigill            = sigill;
exports.sigint            = sigint;
exports.sigkill           = sigkill;
exports.sigpipe           = sigpipe;
exports.sigquit           = sigquit;
exports.sigsegv           = sigsegv;
exports.sigterm           = sigterm;
exports.sigusr1           = sigusr1;
exports.sigusr2           = sigusr2;
exports.sigchld           = sigchld;
exports.sigcont           = sigcont;
exports.sigstop           = sigstop;
exports.sigtstp           = sigtstp;
exports.sigttin           = sigttin;
exports.sigttou           = sigttou;
exports.sigvtalrm         = sigvtalrm;
exports.sigprof           = sigprof;
exports.Break             = Break;
exports.catch_break       = catch_break;
exports.ocaml_version     = ocaml_version;
/* No side effect */


/***/ }),
/* 22 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $$Array                 = __webpack_require__(24);
var Curry                   = __webpack_require__(1);
var Int32                   = __webpack_require__(35);
var Int64                   = __webpack_require__(36);
var Digest                  = __webpack_require__(37);
var Caml_sys                = __webpack_require__(15);
var Nativeint               = __webpack_require__(42);
var Caml_array              = __webpack_require__(7);
var Caml_int64              = __webpack_require__(16);
var Pervasives              = __webpack_require__(2);
var Caml_string             = __webpack_require__(6);
var Caml_builtin_exceptions = __webpack_require__(0);

function assign(st1, st2) {
  $$Array.blit(st2[/* st */0], 0, st1[/* st */0], 0, 55);
  st1[/* idx */1] = st2[/* idx */1];
  return /* () */0;
}

function full_init(s, seed) {
  var combine = function (accu, x) {
    return Digest.string(accu + x);
  };
  var extract = function (d) {
    return ((Caml_string.get(d, 0) + (Caml_string.get(d, 1) << 8) | 0) + (Caml_string.get(d, 2) << 16) | 0) + (Caml_string.get(d, 3) << 24) | 0;
  };
  var seed$1 = seed.length ? seed : /* int array */[0];
  var l = seed$1.length;
  for(var i = 0; i <= 54; ++i){
    Caml_array.caml_array_set(s[/* st */0], i, i);
  }
  var accu = "x";
  for(var i$1 = 0 ,i_finish = 54 + Pervasives.max(55, l) | 0; i$1 <= i_finish; ++i$1){
    var j = i$1 % 55;
    var k = i$1 % l;
    accu = combine(accu, Caml_array.caml_array_get(seed$1, k));
    Caml_array.caml_array_set(s[/* st */0], j, (Caml_array.caml_array_get(s[/* st */0], j) ^ extract(accu)) & 1073741823);
  }
  s[/* idx */1] = 0;
  return /* () */0;
}

function make(seed) {
  var result = /* record */[
    /* st */Caml_array.caml_make_vect(55, 0),
    /* idx */0
  ];
  full_init(result, seed);
  return result;
}

function make_self_init() {
  return make(Caml_sys.caml_sys_random_seed(/* () */0));
}

function copy(s) {
  var result = /* record */[
    /* st */Caml_array.caml_make_vect(55, 0),
    /* idx */0
  ];
  assign(result, s);
  return result;
}

function bits(s) {
  s[/* idx */1] = (s[/* idx */1] + 1 | 0) % 55;
  var curval = Caml_array.caml_array_get(s[/* st */0], s[/* idx */1]);
  var newval = Caml_array.caml_array_get(s[/* st */0], (s[/* idx */1] + 24 | 0) % 55) + (curval ^ (curval >>> 25) & 31) | 0;
  var newval30 = newval & 1073741823;
  Caml_array.caml_array_set(s[/* st */0], s[/* idx */1], newval30);
  return newval30;
}

function $$int(s, bound) {
  if (bound > 1073741823 || bound <= 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Random.int"
        ];
  } else {
    var s$1 = s;
    var n = bound;
    while(true) {
      var r = bits(s$1);
      var v = r % n;
      if ((r - v | 0) > ((1073741823 - n | 0) + 1 | 0)) {
        continue ;
        
      } else {
        return v;
      }
    };
  }
}

function int32(s, bound) {
  if (bound <= 0) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Random.int32"
        ];
  } else {
    var s$1 = s;
    var n = bound;
    while(true) {
      var b1 = bits(s$1);
      var b2 = ((bits(s$1) & 1) << 30);
      var r = b1 | b2;
      var v = r % n;
      if ((r - v | 0) > ((Int32.max_int - n | 0) + 1 | 0)) {
        continue ;
        
      } else {
        return v;
      }
    };
  }
}

function int64(s, bound) {
  if (Caml_int64.le(bound, /* int64 */[
          /* hi */0,
          /* lo */0
        ])) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Random.int64"
        ];
  } else {
    var s$1 = s;
    var n = bound;
    while(true) {
      var b1 = Caml_int64.of_int32(bits(s$1));
      var b2 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s$1)), 30);
      var b3 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s$1) & 7), 60);
      var r = Caml_int64.or_(b1, /* int64 */[
            /* hi */b2[0] | b3[0],
            /* lo */((b2[1] | b3[1]) >>> 0)
          ]);
      var v = Caml_int64.mod_(r, n);
      if (Caml_int64.gt(Caml_int64.sub(r, v), Caml_int64.add(Caml_int64.sub(Int64.max_int, n), /* int64 */[
                  /* hi */0,
                  /* lo */1
                ]))) {
        continue ;
        
      } else {
        return v;
      }
    };
  }
}

var nativeint = Nativeint.size === 32 ? int32 : (function (s, bound) {
      return int64(s, Caml_int64.of_int32(bound))[1] | 0;
    });

function rawfloat(s) {
  var r1 = bits(s);
  var r2 = bits(s);
  return (r1 / 1073741824.0 + r2) / 1073741824.0;
}

function $$float(s, bound) {
  return rawfloat(s) * bound;
}

function bool(s) {
  return +((bits(s) & 1) === 0);
}

var $$default = /* record */[
  /* st : array */[
    987910699,
    495797812,
    364182224,
    414272206,
    318284740,
    990407751,
    383018966,
    270373319,
    840823159,
    24560019,
    536292337,
    512266505,
    189156120,
    730249596,
    143776328,
    51606627,
    140166561,
    366354223,
    1003410265,
    700563762,
    981890670,
    913149062,
    526082594,
    1021425055,
    784300257,
    667753350,
    630144451,
    949649812,
    48546892,
    415514493,
    258888527,
    511570777,
    89983870,
    283659902,
    308386020,
    242688715,
    482270760,
    865188196,
    1027664170,
    207196989,
    193777847,
    619708188,
    671350186,
    149669678,
    257044018,
    87658204,
    558145612,
    183450813,
    28133145,
    901332182,
    710253903,
    510646120,
    652377910,
    409934019,
    801085050
  ],
  /* idx */0
];

function bits$1() {
  return bits($$default);
}

function $$int$1(bound) {
  return $$int($$default, bound);
}

function int32$1(bound) {
  return int32($$default, bound);
}

function nativeint$1(bound) {
  return Curry._2(nativeint, $$default, bound);
}

function int64$1(bound) {
  return int64($$default, bound);
}

function $$float$1(scale) {
  return rawfloat($$default) * scale;
}

function bool$1() {
  return bool($$default);
}

function full_init$1(seed) {
  return full_init($$default, seed);
}

function init(seed) {
  return full_init($$default, /* int array */[seed]);
}

function self_init() {
  return full_init$1(Caml_sys.caml_sys_random_seed(/* () */0));
}

function get_state() {
  return copy($$default);
}

function set_state(s) {
  return assign($$default, s);
}

var State = [
  make,
  make_self_init,
  copy,
  bits,
  $$int,
  int32,
  nativeint,
  int64,
  $$float,
  bool
];

exports.init      = init;
exports.full_init = full_init$1;
exports.self_init = self_init;
exports.bits      = bits$1;
exports.$$int     = $$int$1;
exports.int32     = int32$1;
exports.nativeint = nativeint$1;
exports.int64     = int64$1;
exports.$$float   = $$float$1;
exports.bool      = bool$1;
exports.State     = State;
exports.get_state = get_state;
exports.set_state = set_state;
/* No side effect */


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Curry                   = __webpack_require__(1);
var Js_exn                  = __webpack_require__(34);
var Caml_array              = __webpack_require__(7);
var Caml_exceptions         = __webpack_require__(11);
var Caml_builtin_exceptions = __webpack_require__(0);

function init(l, f) {
  if (l) {
    if (l < 0) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Array.init"
          ];
    } else {
      var res = Caml_array.caml_make_vect(l, Curry._1(f, 0));
      for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
        res[i] = Curry._1(f, i);
      }
      return res;
    }
  } else {
    return /* array */[];
  }
}

function make_matrix(sx, sy, init) {
  var res = Caml_array.caml_make_vect(sx, /* array */[]);
  for(var x = 0 ,x_finish = sx - 1 | 0; x <= x_finish; ++x){
    res[x] = Caml_array.caml_make_vect(sy, init);
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l) {
    return Caml_array.caml_array_sub(a, 0, l);
  } else {
    return /* array */[];
  }
}

function append(a1, a2) {
  var l1 = a1.length;
  if (l1) {
    if (a2.length) {
      return a1.concat(a2);
    } else {
      return Caml_array.caml_array_sub(a1, 0, l1);
    }
  } else {
    return copy(a2);
  }
}

function sub(a, ofs, len) {
  if (len < 0 || ofs > (a.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.sub"
        ];
  } else {
    return Caml_array.caml_array_sub(a, ofs, len);
  }
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.fill"
        ];
  } else {
    for(var i = ofs ,i_finish = (ofs + len | 0) - 1 | 0; i <= i_finish; ++i){
      a[i] = v;
    }
    return /* () */0;
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Array.blit"
        ];
  } else {
    return Caml_array.caml_array_blit(a1, ofs1, a2, ofs2, len);
  }
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._1(f, a[i]);
  }
  return /* () */0;
}

function map(f, a) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._1(f, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._1(f, a[i]);
    }
    return r;
  } else {
    return /* array */[];
  }
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
  return /* () */0;
}

function mapi(f, a) {
  var l = a.length;
  if (l) {
    var r = Caml_array.caml_make_vect(l, Curry._2(f, 0, a[0]));
    for(var i = 1 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._2(f, i, a[i]);
    }
    return r;
  } else {
    return /* array */[];
  }
}

function to_list(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    } else {
      _res = /* :: */[
        a[i],
        res
      ];
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[1];
      _accu = accu + 1 | 0;
      continue ;
      
    } else {
      return accu;
    }
  };
}

function of_list(l) {
  if (l) {
    var a = Caml_array.caml_make_vect(list_length(0, l), l[0]);
    var _i = 1;
    var _param = l[1];
    while(true) {
      var param = _param;
      var i = _i;
      if (param) {
        a[i] = param[0];
        _param = param[1];
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return a;
      }
    };
  } else {
    return /* array */[];
  }
}

function fold_left(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

var Bottom = Caml_exceptions.create("Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.caml_array_get(a, i31), Caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.caml_array_get(a, x), Caml_array.caml_array_get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    } else if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.caml_array_get(a, i31), Caml_array.caml_array_get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    } else if (i31 < l) {
      return i31;
    } else {
      throw [
            Bottom,
            i
          ];
    }
  };
  var trickle = function (l, i, e) {
    try {
      var l$1 = l;
      var _i = i;
      var e$1 = e;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        if (Curry._2(cmp, Caml_array.caml_array_get(a, j), e$1) > 0) {
          Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, j));
          _i = j;
          continue ;
          
        } else {
          return Caml_array.caml_array_set(a, i$1, e$1);
        }
      };
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return Caml_array.caml_array_set(a, exn[1], e);
      } else {
        throw exn;
      }
    }
  };
  var bubble = function (l, i) {
    try {
      var l$1 = l;
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l$1, i$1);
        Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, j));
        _i = j;
        continue ;
        
      };
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Bottom) {
        return exn[1];
      } else {
        throw exn;
      }
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "array.ml",
                168,
                4
              ]
            ];
      }
      if (Curry._2(cmp, Caml_array.caml_array_get(a, father), e) < 0) {
        Caml_array.caml_array_set(a, i, Caml_array.caml_array_get(a, father));
        if (father > 0) {
          _i = father;
          continue ;
          
        } else {
          return Caml_array.caml_array_set(a, 0, e);
        }
      } else {
        return Caml_array.caml_array_set(a, i, e);
      }
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.caml_array_get(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Caml_array.caml_array_get(a, i$1);
    Caml_array.caml_array_set(a, i$1, Caml_array.caml_array_get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l > 1) {
    var e$1 = Caml_array.caml_array_get(a, 1);
    Caml_array.caml_array_set(a, 1, Caml_array.caml_array_get(a, 0));
    return Caml_array.caml_array_set(a, 0, e$1);
  } else {
    return 0;
  }
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Caml_array.caml_array_get(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Caml_array.caml_array_get(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.caml_array_set(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 < src1r) {
          _d = d + 1 | 0;
          _s1 = Caml_array.caml_array_get(a, i1$1);
          _i1 = i1$1;
          continue ;
          
        } else {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
      } else {
        Caml_array.caml_array_set(dst, d, s2);
        var i2$1 = i2 + 1 | 0;
        if (i2$1 < src2r) {
          _d = d + 1 | 0;
          _s2 = Caml_array.caml_array_get(src2, i2$1);
          _i2 = i2$1;
          continue ;
          
        } else {
          return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
        }
      }
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
      var e = Caml_array.caml_array_get(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.caml_array_get(dst, j), e) > 0) {
        Caml_array.caml_array_set(dst, j + 1 | 0, Caml_array.caml_array_get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.caml_array_set(dst, j + 1 | 0, e);
    }
    return /* () */0;
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    } else {
      var l1 = len / 2 | 0;
      var l2 = len - l1 | 0;
      sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
      sortto(srcofs, a, srcofs + l2 | 0, l1);
      return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
    }
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  } else {
    var l1 = l / 2 | 0;
    var l2 = l - l1 | 0;
    var t = Caml_array.caml_make_vect(l2, Caml_array.caml_array_get(a, 0));
    sortto(l1, t, 0, l2);
    sortto(0, a, l2, l1);
    return merge(l2, l1, t, 0, l2, a, 0);
  }
}

var create_matrix = make_matrix;

var concat = Caml_array.caml_array_concat;

var fast_sort = stable_sort;

exports.init          = init;
exports.make_matrix   = make_matrix;
exports.create_matrix = create_matrix;
exports.append        = append;
exports.concat        = concat;
exports.sub           = sub;
exports.copy          = copy;
exports.fill          = fill;
exports.blit          = blit;
exports.to_list       = to_list;
exports.of_list       = of_list;
exports.iter          = iter;
exports.map           = map;
exports.iteri         = iteri;
exports.mapi          = mapi;
exports.fold_left     = fold_left;
exports.fold_right    = fold_right;
exports.sort          = sort;
exports.stable_sort   = stable_sort;
exports.fast_sort     = fast_sort;
/* No side effect */


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



function __(tag, block) {
  block.tag = tag;
  return block;
}

exports.__ = __;
/* No side effect */


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var repeat = ( (String.prototype.repeat && function (count,self){return self.repeat(count)}) ||
                                                  function(count , self) {
        if (self.length == 0 || count == 0) {
            return '';
        }
        // Ensuring count is a 31-bit integer allows us to heavily optimize the
        // main part. But anyway, most current (August 2014) browsers can't handle
        // strings 1 << 28 chars or longer, so:
        if (self.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += self;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            self += self;
        }
        return rpt;
    }
);

exports.repeat = repeat;
/* repeat Not a pure module */


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_string             = __webpack_require__(6);
var Caml_builtin_exceptions = __webpack_require__(0);

function chr(n) {
  if (n < 0 || n > 255) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Char.chr"
        ];
  } else {
    return n;
  }
}

function escaped(c) {
  var exit = 0;
  if (c >= 40) {
    if (c !== 92) {
      exit = c >= 127 ? 1 : 2;
    } else {
      return "\\\\";
    }
  } else if (c >= 32) {
    if (c >= 39) {
      return "\\'";
    } else {
      exit = 2;
    }
  } else if (c >= 14) {
    exit = 1;
  } else {
    switch (c) {
      case 8 : 
          return "\\b";
      case 9 : 
          return "\\t";
      case 10 : 
          return "\\n";
      case 0 : 
      case 1 : 
      case 2 : 
      case 3 : 
      case 4 : 
      case 5 : 
      case 6 : 
      case 7 : 
      case 11 : 
      case 12 : 
          exit = 1;
          break;
      case 13 : 
          return "\\r";
      
    }
  }
  switch (exit) {
    case 1 : 
        var s = new Array(4);
        s[0] = /* "\\" */92;
        s[1] = 48 + (c / 100 | 0) | 0;
        s[2] = 48 + (c / 10 | 0) % 10 | 0;
        s[3] = 48 + c % 10 | 0;
        return Caml_string.bytes_to_string(s);
    case 2 : 
        var s$1 = new Array(1);
        s$1[0] = c;
        return Caml_string.bytes_to_string(s$1);
    
  }
}

function lowercase(c) {
  if (c >= /* "A" */65 && c <= /* "Z" */90 || c >= /* "\192" */192 && c <= /* "\214" */214 || c >= /* "\216" */216 && c <= /* "\222" */222) {
    return c + 32 | 0;
  } else {
    return c;
  }
}

function uppercase(c) {
  if (c >= /* "a" */97 && c <= /* "z" */122 || c >= /* "\224" */224 && c <= /* "\246" */246 || c >= /* "\248" */248 && c <= /* "\254" */254) {
    return c - 32 | 0;
  } else {
    return c;
  }
}

function compare(c1, c2) {
  return c1 - c2 | 0;
}

exports.chr       = chr;
exports.escaped   = escaped;
exports.lowercase = lowercase;
exports.uppercase = uppercase;
exports.compare   = compare;
/* No side effect */


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var not_implemented = (function (s){ throw new Error(s)});

exports.not_implemented = not_implemented;
/* not_implemented Not a pure module */


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Game                   = __webpack_require__(106);
var Tile                   = __webpack_require__(108);
var Curry                  = __webpack_require__(1);
var Immutable              = __webpack_require__(86);
var Caml_int32             = __webpack_require__(5);
var Reprocessing           = __webpack_require__(33);
var Reprocessing_Env       = __webpack_require__(18);
var Reprocessing_Draw      = __webpack_require__(52);
var Reprocessing_Constants = __webpack_require__(14);

function setup(env) {
  Reprocessing_Env.size(600, 600, env);
  Reprocessing_Draw.fill(Reprocessing_Constants.red, env);
  Reprocessing_Draw.noStroke(env);
  return /* record */[
          /* game */Game.initialState(/* tuple */[
                30,
                30
              ]),
          /* tick */0
        ];
}

function draw(state, env) {
  Reprocessing_Draw.background(Reprocessing_Constants.black, env);
  Curry._4(Immutable.HashMap[/* reduce */8], /* None */0, (function (_, param, tile) {
          Reprocessing_Draw.fill(Tile.tileColor(tile), env);
          Reprocessing_Draw.rect(/* tuple */[
                Caml_int32.imul(param[0], 20),
                Caml_int32.imul(param[1], 20)
              ], 20, 20, env);
          return /* () */0;
        }), /* () */0, state[/* game */0][/* tiles */0]);
  var state_000 = /* game */state[/* game */0];
  var state_001 = /* tick */state[/* tick */1] + 1 | 0;
  var state$1 = /* record */[
    state_000,
    state_001
  ];
  if (state_001 % 5) {
    return state$1;
  } else {
    return /* record */[
            /* game */Game.step(state_000),
            state_001
          ];
  }
}

Reprocessing.run(setup, /* Some */[draw], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* () */0);

var Vector = 0;

var HashMap = 0;

var scale = 20;

exports.Vector  = Vector;
exports.HashMap = HashMap;
exports.setup   = setup;
exports.scale   = scale;
exports.draw    = draw;
/*  Not a pure module */


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Sys                   = __webpack_require__(21);
var Curry                 = __webpack_require__(1);
var Random                = __webpack_require__(23);
var Reasongl              = __webpack_require__(10);
var RGLConstants          = __webpack_require__(12);
var Reprocessing_Env      = __webpack_require__(18);
var Reprocessing_Utils    = __webpack_require__(51);
var Reprocessing_Matrix   = __webpack_require__(20);
var Reprocessing_Internal = __webpack_require__(13);

function run(setup, draw, mouseMove, mouseDragged, mouseDown, mouseUp, keyPressed, keyReleased, keyTyped, _) {
  Random.self_init(/* () */0);
  Reprocessing_Utils.noiseSeed(Random.$$int(Reprocessing_Utils.pow(2, 29)));
  var env = Reprocessing_Internal.createCanvas(Curry._1(Reasongl.Gl[/* Window */2][/* init */2], Sys.argv), 200, 200);
  var userState = [Curry._1(setup, env)];
  var width = Curry._1(Reasongl.Gl[/* Window */2][/* getWidth */0], env[/* window */1]);
  var height = Curry._1(Reasongl.Gl[/* Window */2][/* getHeight */1], env[/* window */1]);
  var data = Curry._5(Reasongl.Gl[/* readPixels_RGBA */24], env[/* gl */2], 0, 0, width, height);
  var textureBuffer = Curry._1(Reasongl.Gl[/* createTexture */16], env[/* gl */2]);
  Curry._3(Reasongl.Gl[/* bindTexture */18], env[/* gl */2], RGLConstants.texture_2d, textureBuffer);
  Curry._7(Reasongl.Gl[/* texImage2D_RGBA */31], env[/* gl */2], RGLConstants.texture_2d, 0, width, height, 0, data);
  Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_mag_filter, RGLConstants.linear);
  Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_min_filter, RGLConstants.linear);
  Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_s, RGLConstants.clamp_to_edge);
  Curry._4(Reasongl.Gl[/* texParameteri */19], env[/* gl */2], RGLConstants.texture_2d, RGLConstants.texture_wrap_t, RGLConstants.clamp_to_edge);
  var reDrawPreviousBufferOnSecondFrame = function () {
    var match_000 = 0 + width | 0;
    var match_000$1 = 0 + width | 0;
    var match_001 = 0 + height | 0;
    var match_001$1 = 0 + height | 0;
    var verticesColorAndTexture = /* float array */[
      match_000,
      0,
      0.0,
      0.0,
      0.0,
      0.0,
      1,
      1.0,
      1.0,
      0,
      0,
      0.0,
      0.0,
      0.0,
      0.0,
      1,
      0.0,
      1.0,
      match_000$1,
      match_001,
      0.0,
      0.0,
      0.0,
      0.0,
      1,
      1.0,
      0.0,
      0,
      match_001$1,
      0.0,
      0.0,
      0.0,
      0.0,
      1,
      0.0,
      0.0
    ];
    return Reprocessing_Internal.drawGeometry(Curry._2(Reasongl.Gl[/* Bigarray */23][/* of_array */1], /* Float32 */1, verticesColorAndTexture), Curry._2(Reasongl.Gl[/* Bigarray */23][/* of_array */1], /* Uint16 */3, /* array */[
                    0,
                    1,
                    2,
                    1,
                    2,
                    3
                  ]), RGLConstants.triangles, 6, textureBuffer, env);
  };
  return Curry.app(Reasongl.Gl[/* render */4], [
              env[/* window */1],
              /* Some */[(function (_, _$1, x, y) {
                    env[/* mouse */12][/* pos */0] = /* tuple */[
                      x,
                      y
                    ];
                    env[/* mouse */12][/* pressed */2] = /* true */1;
                    if (mouseDown) {
                      userState[0] = Curry._2(mouseDown[0], userState[0], env);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  })],
              /* Some */[(function (_, _$1, x, y) {
                    env[/* mouse */12][/* pos */0] = /* tuple */[
                      x,
                      y
                    ];
                    env[/* mouse */12][/* pressed */2] = /* false */0;
                    if (mouseUp) {
                      userState[0] = Curry._2(mouseUp[0], userState[0], env);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  })],
              /* Some */[(function (x, y) {
                    env[/* mouse */12][/* pos */0] = /* tuple */[
                      x,
                      y
                    ];
                    if (env[/* mouse */12][/* pressed */2]) {
                      if (mouseDragged) {
                        userState[0] = Curry._2(mouseDragged[0], userState[0], env);
                        return /* () */0;
                      } else {
                        return /* () */0;
                      }
                    } else if (mouseMove) {
                      userState[0] = Curry._2(mouseMove[0], userState[0], env);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  })],
              /* Some */[(function (keycode, repeat) {
                    env[/* keyboard */11][/* keyCode */0] = keycode;
                    if (!repeat) {
                      if (keyPressed) {
                        userState[0] = Curry._2(keyPressed[0], userState[0], env);
                      }
                      
                    }
                    if (keyTyped) {
                      userState[0] = Curry._2(keyTyped[0], userState[0], env);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  })],
              /* Some */[(function (keycode) {
                    env[/* keyboard */11][/* keyCode */0] = keycode;
                    if (keyReleased) {
                      userState[0] = Curry._2(keyReleased[0], userState[0], env);
                      return /* () */0;
                    } else {
                      return /* () */0;
                    }
                  })],
              /* Some */[(function () {
                    if (env[/* size */18][/* resizeable */2]) {
                      var height = Curry._1(Reasongl.Gl[/* Window */2][/* getHeight */1], env[/* window */1]);
                      var width = Curry._1(Reasongl.Gl[/* Window */2][/* getWidth */0], env[/* window */1]);
                      return Reprocessing_Internal.resetSize(env, width, height);
                    } else {
                      return Reprocessing_Env.size(Reprocessing_Env.width(env), Reprocessing_Env.height(env), env);
                    }
                  })],
              (function (f) {
                  if (env[/* frame */15][/* count */0] === 2) {
                    reDrawPreviousBufferOnSecondFrame(/* () */0);
                  }
                  if (draw) {
                    userState[0] = Curry._2(draw[0], userState[0], env);
                  }
                  var f$1 = f;
                  var env$1 = env;
                  var rate = 1000 / f$1 | 0;
                  env$1[/* mouse */12][/* prevPos */1] = env$1[/* mouse */12][/* pos */0];
                  env$1[/* frame */15] = /* record */[
                    /* count */env$1[/* frame */15][/* count */0] + 1 | 0,
                    /* rate */rate
                  ];
                  Reprocessing_Matrix.copyInto(Reprocessing_Matrix.identity, env$1[/* matrix */16]);
                  if (env$1[/* batch */10][/* elementPtr */3] > 0) {
                    return Reprocessing_Internal.flushGlobalBatch(env$1);
                  } else {
                    return 0;
                  }
                }),
              /* () */0
            ]);
}

var Draw = 0;

var Env = 0;

var Events = 0;

var Utils = 0;

var Constants = 0;

exports.Draw      = Draw;
exports.Env       = Env;
exports.Events    = Events;
exports.Utils     = Utils;
exports.Constants = Constants;
exports.run       = run;
/* Reasongl Not a pure module */


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_exceptions = __webpack_require__(11);

var $$Error = Caml_exceptions.create("Js_exn.Error");

function internalToOCamlException(e) {
  if (Caml_exceptions.isCamlExceptionOrOpenVariant(e)) {
    return e;
  } else {
    return [
            $$Error,
            e
          ];
  }
}

function raiseError(str) {
  throw new Error(str);
}

function raiseEvalError(str) {
  throw new EvalError(str);
}

function raiseRangeError(str) {
  throw new RangeError(str);
}

function raiseReferenceError(str) {
  throw new ReferenceError(str);
}

function raiseSyntaxError(str) {
  throw new SyntaxError(str);
}

function raiseTypeError(str) {
  throw new TypeError(str);
}

function raiseUriError(str) {
  throw new URIError(str);
}

exports.$$Error                  = $$Error;
exports.internalToOCamlException = internalToOCamlException;
exports.raiseError               = raiseError;
exports.raiseEvalError           = raiseEvalError;
exports.raiseRangeError          = raiseRangeError;
exports.raiseReferenceError      = raiseReferenceError;
exports.raiseSyntaxError         = raiseSyntaxError;
exports.raiseTypeError           = raiseTypeError;
exports.raiseUriError            = raiseUriError;
/* No side effect */


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_obj    = __webpack_require__(4);
var Caml_format = __webpack_require__(8);

function succ(n) {
  return n + 1 | 0;
}

function pred(n) {
  return n - 1 | 0;
}

function abs(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n | 0;
  }
}

function lognot(n) {
  return n ^ -1;
}

function to_string(n) {
  return Caml_format.caml_int32_format("%d", n);
}

var compare = Caml_obj.caml_int32_compare;

var zero = 0;

var one = 1;

var minus_one = -1;

var max_int = 2147483647;

var min_int = -2147483648;

exports.zero      = zero;
exports.one       = one;
exports.minus_one = minus_one;
exports.succ      = succ;
exports.pred      = pred;
exports.abs       = abs;
exports.max_int   = max_int;
exports.min_int   = min_int;
exports.lognot    = lognot;
exports.to_string = to_string;
exports.compare   = compare;
/* No side effect */


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_int64  = __webpack_require__(16);
var Caml_format = __webpack_require__(8);

function succ(n) {
  return Caml_int64.add(n, /* int64 */[
              /* hi */0,
              /* lo */1
            ]);
}

function pred(n) {
  return Caml_int64.sub(n, /* int64 */[
              /* hi */0,
              /* lo */1
            ]);
}

function abs(n) {
  if (Caml_int64.ge(n, /* int64 */[
          /* hi */0,
          /* lo */0
        ])) {
    return n;
  } else {
    return Caml_int64.neg(n);
  }
}

function lognot(n) {
  return Caml_int64.xor(n, /* int64 */[
              /* hi */-1,
              /* lo */4294967295
            ]);
}

function to_string(n) {
  return Caml_format.caml_int64_format("%d", n);
}

var compare = Caml_int64.compare;

var zero = /* int64 */[
  /* hi */0,
  /* lo */0
];

var one = /* int64 */[
  /* hi */0,
  /* lo */1
];

var minus_one = /* int64 */[
  /* hi */-1,
  /* lo */4294967295
];

var max_int = /* int64 */[
  /* hi */2147483647,
  /* lo */4294967295
];

var min_int = /* int64 */[
  /* hi */-2147483648,
  /* lo */0
];

exports.zero      = zero;
exports.one       = one;
exports.minus_one = minus_one;
exports.succ      = succ;
exports.pred      = pred;
exports.abs       = abs;
exports.max_int   = max_int;
exports.min_int   = min_int;
exports.lognot    = lognot;
exports.to_string = to_string;
exports.compare   = compare;
/* No side effect */


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Char                    = __webpack_require__(27);
var $$String                = __webpack_require__(17);
var Caml_md5                = __webpack_require__(41);
var Pervasives              = __webpack_require__(2);
var Caml_string             = __webpack_require__(6);
var Caml_missing_polyfill   = __webpack_require__(28);
var Caml_builtin_exceptions = __webpack_require__(0);

function string(str) {
  return Caml_md5.caml_md5_string(str, 0, str.length);
}

function bytes(b) {
  return string(Caml_string.bytes_to_string(b));
}

function substring(str, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (str.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Digest.substring"
        ];
  } else {
    return Caml_md5.caml_md5_string(str, ofs, len);
  }
}

function subbytes(b, ofs, len) {
  return substring(Caml_string.bytes_to_string(b), ofs, len);
}

function file(filename) {
  Pervasives.open_in_bin(filename);
  var exit = 0;
  var d;
  try {
    d = Caml_missing_polyfill.not_implemented("caml_md5_chan not implemented by bucklescript yet\n");
    exit = 1;
  }
  catch (e){
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
    throw e;
  }
  if (exit === 1) {
    Caml_missing_polyfill.not_implemented("caml_ml_close_channel not implemented by bucklescript yet\n");
    return d;
  }
  
}

var output = Pervasives.output_string;

function input(chan) {
  return Pervasives.really_input_string(chan, 16);
}

function char_hex(n) {
  return n + (
          n < 10 ? /* "0" */48 : 87
        ) | 0;
}

function to_hex(d) {
  var result = new Array(32);
  for(var i = 0; i <= 15; ++i){
    var x = Caml_string.get(d, i);
    result[(i << 1)] = char_hex((x >>> 4));
    result[(i << 1) + 1 | 0] = char_hex(x & 15);
  }
  return Caml_string.bytes_to_string(result);
}

function from_hex(s) {
  if (s.length !== 32) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Digest.from_hex"
        ];
  }
  var digit = function (c) {
    if (c >= 65) {
      if (c >= 97) {
        if (c >= 103) {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Digest.from_hex"
              ];
        } else {
          return (c - /* "a" */97 | 0) + 10 | 0;
        }
      } else if (c >= 71) {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Digest.from_hex"
            ];
      } else {
        return (c - /* "A" */65 | 0) + 10 | 0;
      }
    } else if (c > 57 || c < 48) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Digest.from_hex"
          ];
    } else {
      return c - /* "0" */48 | 0;
    }
  };
  var $$byte = function (i) {
    return (digit(Caml_string.get(s, i)) << 4) + digit(Caml_string.get(s, i + 1 | 0)) | 0;
  };
  var result = new Array(16);
  for(var i = 0; i <= 15; ++i){
    result[i] = Char.chr($$byte((i << 1)));
  }
  return Caml_string.bytes_to_string(result);
}

var compare = $$String.compare;

exports.compare   = compare;
exports.string    = string;
exports.bytes     = bytes;
exports.substring = substring;
exports.subbytes  = subbytes;
exports.file      = file;
exports.output    = output;
exports.input     = input;
exports.to_hex    = to_hex;
exports.from_hex  = from_hex;
/* No side effect */


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var Curry                   = __webpack_require__(1);
var Caml_builtin_exceptions = __webpack_require__(0);

function $caret(prim, prim$1) {
  return prim + prim$1;
}

var stdin = undefined;

var stdout = /* record */[
  /* buffer */"",
  /* output */(function (_, s) {
      var v = s.length - 1 | 0;
      if (( (typeof process !== "undefined") && process.stdout && process.stdout.write)) {
        return ( process.stdout.write )(s);
      } else if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
];

var stderr = /* record */[
  /* buffer */"",
  /* output */(function (_, s) {
      var v = s.length - 1 | 0;
      if (s[v] === "\n") {
        console.log(s.slice(0, v));
        return /* () */0;
      } else {
        console.log(s);
        return /* () */0;
      }
    })
];

function caml_ml_open_descriptor_in() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_open_descriptor_in not implemented"
      ];
}

function caml_ml_open_descriptor_out() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_open_descriptor_out not implemented"
      ];
}

function caml_ml_flush(oc) {
  if (oc[/* buffer */0] !== "") {
    Curry._2(oc[/* output */1], oc, oc[/* buffer */0]);
    oc[/* buffer */0] = "";
    return /* () */0;
  } else {
    return 0;
  }
}

var node_std_output = (function (s){
   return (typeof process !== "undefined") && process.stdout && (process.stdout.write(s), true);
   }
);

function caml_ml_output(oc, str, offset, len) {
  var str$1 = offset === 0 && len === str.length ? str : str.slice(offset, len);
  if (( (typeof process !== "undefined") && process.stdout && process.stdout.write ) && oc === stdout) {
    return ( process.stdout.write )(str$1);
  } else {
    var id = str$1.lastIndexOf("\n");
    if (id < 0) {
      oc[/* buffer */0] = oc[/* buffer */0] + str$1;
      return /* () */0;
    } else {
      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(0, id + 1 | 0);
      caml_ml_flush(oc);
      oc[/* buffer */0] = oc[/* buffer */0] + str$1.slice(id + 1 | 0);
      return /* () */0;
    }
  }
}

function caml_ml_output_char(oc, $$char) {
  return caml_ml_output(oc, String.fromCharCode($$char), 0, 1);
}

function caml_ml_input(_, _$1, _$2, _$3) {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_input ic not implemented"
      ];
}

function caml_ml_input_char() {
  throw [
        Caml_builtin_exceptions.failure,
        "caml_ml_input_char not implemnted"
      ];
}

function caml_ml_out_channels_list() {
  return /* :: */[
          stdout,
          /* :: */[
            stderr,
            /* [] */0
          ]
        ];
}

exports.$caret                      = $caret;
exports.stdin                       = stdin;
exports.stdout                      = stdout;
exports.stderr                      = stderr;
exports.caml_ml_open_descriptor_in  = caml_ml_open_descriptor_in;
exports.caml_ml_open_descriptor_out = caml_ml_open_descriptor_out;
exports.caml_ml_flush               = caml_ml_flush;
exports.node_std_output             = node_std_output;
exports.caml_ml_output              = caml_ml_output;
exports.caml_ml_output_char         = caml_ml_output_char;
exports.caml_ml_input               = caml_ml_input;
exports.caml_ml_input_char          = caml_ml_input_char;
exports.caml_ml_out_channels_list   = caml_ml_out_channels_list;
/* stdin Not a pure module */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Block = __webpack_require__(25);

function erase_rel(param) {
  if (typeof param === "number") {
    return /* End_of_fmtty */0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* Char_ty */Block.__(0, [erase_rel(param[0])]);
      case 1 : 
          return /* String_ty */Block.__(1, [erase_rel(param[0])]);
      case 2 : 
          return /* Int_ty */Block.__(2, [erase_rel(param[0])]);
      case 3 : 
          return /* Int32_ty */Block.__(3, [erase_rel(param[0])]);
      case 4 : 
          return /* Nativeint_ty */Block.__(4, [erase_rel(param[0])]);
      case 5 : 
          return /* Int64_ty */Block.__(5, [erase_rel(param[0])]);
      case 6 : 
          return /* Float_ty */Block.__(6, [erase_rel(param[0])]);
      case 7 : 
          return /* Bool_ty */Block.__(7, [erase_rel(param[0])]);
      case 8 : 
          return /* Format_arg_ty */Block.__(8, [
                    param[0],
                    erase_rel(param[1])
                  ]);
      case 9 : 
          var ty1 = param[0];
          return /* Format_subst_ty */Block.__(9, [
                    ty1,
                    ty1,
                    erase_rel(param[2])
                  ]);
      case 10 : 
          return /* Alpha_ty */Block.__(10, [erase_rel(param[0])]);
      case 11 : 
          return /* Theta_ty */Block.__(11, [erase_rel(param[0])]);
      case 12 : 
          return /* Any_ty */Block.__(12, [erase_rel(param[0])]);
      case 13 : 
          return /* Reader_ty */Block.__(13, [erase_rel(param[0])]);
      case 14 : 
          return /* Ignored_reader_ty */Block.__(14, [erase_rel(param[0])]);
      
    }
  }
}

function concat_fmtty(fmtty1, fmtty2) {
  if (typeof fmtty1 === "number") {
    return fmtty2;
  } else {
    switch (fmtty1.tag | 0) {
      case 0 : 
          return /* Char_ty */Block.__(0, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 1 : 
          return /* String_ty */Block.__(1, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 2 : 
          return /* Int_ty */Block.__(2, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 3 : 
          return /* Int32_ty */Block.__(3, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 4 : 
          return /* Nativeint_ty */Block.__(4, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 5 : 
          return /* Int64_ty */Block.__(5, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 6 : 
          return /* Float_ty */Block.__(6, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 7 : 
          return /* Bool_ty */Block.__(7, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 8 : 
          return /* Format_arg_ty */Block.__(8, [
                    fmtty1[0],
                    concat_fmtty(fmtty1[1], fmtty2)
                  ]);
      case 9 : 
          return /* Format_subst_ty */Block.__(9, [
                    fmtty1[0],
                    fmtty1[1],
                    concat_fmtty(fmtty1[2], fmtty2)
                  ]);
      case 10 : 
          return /* Alpha_ty */Block.__(10, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 11 : 
          return /* Theta_ty */Block.__(11, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 12 : 
          return /* Any_ty */Block.__(12, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 13 : 
          return /* Reader_ty */Block.__(13, [concat_fmtty(fmtty1[0], fmtty2)]);
      case 14 : 
          return /* Ignored_reader_ty */Block.__(14, [concat_fmtty(fmtty1[0], fmtty2)]);
      
    }
  }
}

function concat_fmt(fmt1, fmt2) {
  if (typeof fmt1 === "number") {
    return fmt2;
  } else {
    switch (fmt1.tag | 0) {
      case 0 : 
          return /* Char */Block.__(0, [concat_fmt(fmt1[0], fmt2)]);
      case 1 : 
          return /* Caml_char */Block.__(1, [concat_fmt(fmt1[0], fmt2)]);
      case 2 : 
          return /* String */Block.__(2, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 3 : 
          return /* Caml_string */Block.__(3, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 4 : 
          return /* Int */Block.__(4, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 5 : 
          return /* Int32 */Block.__(5, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 6 : 
          return /* Nativeint */Block.__(6, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 7 : 
          return /* Int64 */Block.__(7, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 8 : 
          return /* Float */Block.__(8, [
                    fmt1[0],
                    fmt1[1],
                    fmt1[2],
                    concat_fmt(fmt1[3], fmt2)
                  ]);
      case 9 : 
          return /* Bool */Block.__(9, [concat_fmt(fmt1[0], fmt2)]);
      case 10 : 
          return /* Flush */Block.__(10, [concat_fmt(fmt1[0], fmt2)]);
      case 11 : 
          return /* String_literal */Block.__(11, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 12 : 
          return /* Char_literal */Block.__(12, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 13 : 
          return /* Format_arg */Block.__(13, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 14 : 
          return /* Format_subst */Block.__(14, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 15 : 
          return /* Alpha */Block.__(15, [concat_fmt(fmt1[0], fmt2)]);
      case 16 : 
          return /* Theta */Block.__(16, [concat_fmt(fmt1[0], fmt2)]);
      case 17 : 
          return /* Formatting_lit */Block.__(17, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 18 : 
          return /* Formatting_gen */Block.__(18, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 19 : 
          return /* Reader */Block.__(19, [concat_fmt(fmt1[0], fmt2)]);
      case 20 : 
          return /* Scan_char_set */Block.__(20, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      case 21 : 
          return /* Scan_get_counter */Block.__(21, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 22 : 
          return /* Scan_next_char */Block.__(22, [concat_fmt(fmt1[0], fmt2)]);
      case 23 : 
          return /* Ignored_param */Block.__(23, [
                    fmt1[0],
                    concat_fmt(fmt1[1], fmt2)
                  ]);
      case 24 : 
          return /* Custom */Block.__(24, [
                    fmt1[0],
                    fmt1[1],
                    concat_fmt(fmt1[2], fmt2)
                  ]);
      
    }
  }
}

exports.concat_fmtty = concat_fmtty;
exports.erase_rel    = erase_rel;
exports.concat_fmt   = concat_fmt;
/* No side effect */


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Char                    = __webpack_require__(27);
var List                    = __webpack_require__(9);
var Curry                   = __webpack_require__(1);
var Caml_obj                = __webpack_require__(4);
var Caml_int32              = __webpack_require__(5);
var Pervasives              = __webpack_require__(2);
var Caml_string             = __webpack_require__(6);
var Caml_builtin_exceptions = __webpack_require__(0);

function make(n, c) {
  var s = Caml_string.caml_create_string(n);
  Caml_string.caml_fill_string(s, 0, n, c);
  return s;
}

function init(n, f) {
  var s = Caml_string.caml_create_string(n);
  for(var i = 0 ,i_finish = n - 1 | 0; i <= i_finish; ++i){
    s[i] = Curry._1(f, i);
  }
  return s;
}

var empty = [];

function copy(s) {
  var len = s.length;
  var r = Caml_string.caml_create_string(len);
  Caml_string.caml_blit_bytes(s, 0, r, 0, len);
  return r;
}

function to_string(b) {
  return Caml_string.bytes_to_string(copy(b));
}

function of_string(s) {
  return copy(Caml_string.bytes_of_string(s));
}

function sub(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.sub / Bytes.sub"
        ];
  } else {
    var r = Caml_string.caml_create_string(len);
    Caml_string.caml_blit_bytes(s, ofs, r, 0, len);
    return r;
  }
}

function sub_string(b, ofs, len) {
  return Caml_string.bytes_to_string(sub(b, ofs, len));
}

function extend(s, left, right) {
  var len = (s.length + left | 0) + right | 0;
  var r = Caml_string.caml_create_string(len);
  var match = left < 0 ? /* tuple */[
      -left | 0,
      0
    ] : /* tuple */[
      0,
      left
    ];
  var dstoff = match[1];
  var srcoff = match[0];
  var cpylen = Pervasives.min(s.length - srcoff | 0, len - dstoff | 0);
  if (cpylen > 0) {
    Caml_string.caml_blit_bytes(s, srcoff, r, dstoff, cpylen);
  }
  return r;
}

function fill(s, ofs, len, c) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.fill / Bytes.fill"
        ];
  } else {
    return Caml_string.caml_fill_string(s, ofs, len, c);
  }
}

function blit(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Bytes.blit"
        ];
  } else {
    return Caml_string.caml_blit_bytes(s1, ofs1, s2, ofs2, len);
  }
}

function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.blit / Bytes.blit_string"
        ];
  } else {
    return Caml_string.caml_blit_string(s1, ofs1, s2, ofs2, len);
  }
}

function iter(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._1(f, a[i]);
  }
  return /* () */0;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length - 1 | 0; i <= i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
  return /* () */0;
}

function concat(sep, l) {
  if (l) {
    var hd = l[0];
    var num = [0];
    var len = [0];
    List.iter((function (s) {
            num[0] = num[0] + 1 | 0;
            len[0] = len[0] + s.length | 0;
            return /* () */0;
          }), l);
    var r = Caml_string.caml_create_string(len[0] + Caml_int32.imul(sep.length, num[0] - 1 | 0) | 0);
    Caml_string.caml_blit_bytes(hd, 0, r, 0, hd.length);
    var pos = [hd.length];
    List.iter((function (s) {
            Caml_string.caml_blit_bytes(sep, 0, r, pos[0], sep.length);
            pos[0] = pos[0] + sep.length | 0;
            Caml_string.caml_blit_bytes(s, 0, r, pos[0], s.length);
            pos[0] = pos[0] + s.length | 0;
            return /* () */0;
          }), l[1]);
    return r;
  } else {
    return empty;
  }
}

function cat(a, b) {
  return a.concat(b);
}

function is_space(param) {
  var switcher = param - 9 | 0;
  if (switcher > 4 || switcher < 0) {
    if (switcher !== 23) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  } else if (switcher !== 2) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function trim(s) {
  var len = s.length;
  var i = 0;
  while(i < len && is_space(s[i])) {
    i = i + 1 | 0;
  };
  var j = len - 1 | 0;
  while(j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  };
  if (j >= i) {
    return sub(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}

function escaped(s) {
  var n = 0;
  for(var i = 0 ,i_finish = s.length - 1 | 0; i <= i_finish; ++i){
    var match = s[i];
    var $js;
    if (match >= 32) {
      var switcher = match - 34 | 0;
      $js = switcher > 58 || switcher < 0 ? (
          switcher >= 93 ? 4 : 1
        ) : (
          switcher > 57 || switcher < 1 ? 2 : 1
        );
    } else {
      $js = match >= 11 ? (
          match !== 13 ? 4 : 2
        ) : (
          match >= 8 ? 2 : 4
        );
    }
    n = n + $js | 0;
  }
  if (n === s.length) {
    return copy(s);
  } else {
    var s$prime = Caml_string.caml_create_string(n);
    n = 0;
    for(var i$1 = 0 ,i_finish$1 = s.length - 1 | 0; i$1 <= i_finish$1; ++i$1){
      var c = s[i$1];
      var exit = 0;
      if (c >= 35) {
        if (c !== 92) {
          if (c >= 127) {
            exit = 1;
          } else {
            s$prime[n] = c;
          }
        } else {
          exit = 2;
        }
      } else if (c >= 32) {
        if (c >= 34) {
          exit = 2;
        } else {
          s$prime[n] = c;
        }
      } else if (c >= 14) {
        exit = 1;
      } else {
        switch (c) {
          case 8 : 
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "b" */98;
              break;
          case 9 : 
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "t" */116;
              break;
          case 10 : 
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "n" */110;
              break;
          case 0 : 
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 5 : 
          case 6 : 
          case 7 : 
          case 11 : 
          case 12 : 
              exit = 1;
              break;
          case 13 : 
              s$prime[n] = /* "\\" */92;
              n = n + 1 | 0;
              s$prime[n] = /* "r" */114;
              break;
          
        }
      }
      switch (exit) {
        case 1 : 
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = 48 + (c / 100 | 0) | 0;
            n = n + 1 | 0;
            s$prime[n] = 48 + (c / 10 | 0) % 10 | 0;
            n = n + 1 | 0;
            s$prime[n] = 48 + c % 10 | 0;
            break;
        case 2 : 
            s$prime[n] = /* "\\" */92;
            n = n + 1 | 0;
            s$prime[n] = c;
            break;
        
      }
      n = n + 1 | 0;
    }
    return s$prime;
  }
}

function map(f, s) {
  var l = s.length;
  if (l) {
    var r = Caml_string.caml_create_string(l);
    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._1(f, s[i]);
    }
    return r;
  } else {
    return s;
  }
}

function mapi(f, s) {
  var l = s.length;
  if (l) {
    var r = Caml_string.caml_create_string(l);
    for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
      r[i] = Curry._2(f, i, s[i]);
    }
    return r;
  } else {
    return s;
  }
}

function uppercase(s) {
  return map(Char.uppercase, s);
}

function lowercase(s) {
  return map(Char.lowercase, s);
}

function apply1(f, s) {
  if (s.length) {
    var r = copy(s);
    r[0] = Curry._1(f, s[0]);
    return r;
  } else {
    return s;
  }
}

function capitalize(s) {
  return apply1(Char.uppercase, s);
}

function uncapitalize(s) {
  return apply1(Char.lowercase, s);
}

function index_rec(s, lim, _i, c) {
  while(true) {
    var i = _i;
    if (i >= lim) {
      throw Caml_builtin_exceptions.not_found;
    } else if (s[i] === c) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.index_from / Bytes.index_from"
        ];
  } else {
    return index_rec(s, l, i, c);
  }
}

function rindex_rec(s, _i, c) {
  while(true) {
    var i = _i;
    if (i < 0) {
      throw Caml_builtin_exceptions.not_found;
    } else if (s[i] === c) {
      return i;
    } else {
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.rindex_from / Bytes.rindex_from"
        ];
  } else {
    return rindex_rec(s, i, c);
  }
}

function contains_from(s, i, c) {
  var l = s.length;
  if (i < 0 || i > l) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.contains_from / Bytes.contains_from"
        ];
  } else {
    try {
      index_rec(s, l, i, c);
      return /* true */1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "String.rcontains_from / Bytes.rcontains_from"
        ];
  } else {
    try {
      rindex_rec(s, i, c);
      return /* true */1;
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        return /* false */0;
      } else {
        throw exn;
      }
    }
  }
}

var compare = Caml_obj.caml_compare;

var unsafe_to_string = Caml_string.bytes_to_string;

var unsafe_of_string = Caml_string.bytes_of_string;

exports.make             = make;
exports.init             = init;
exports.empty            = empty;
exports.copy             = copy;
exports.of_string        = of_string;
exports.to_string        = to_string;
exports.sub              = sub;
exports.sub_string       = sub_string;
exports.extend           = extend;
exports.fill             = fill;
exports.blit             = blit;
exports.blit_string      = blit_string;
exports.concat           = concat;
exports.cat              = cat;
exports.iter             = iter;
exports.iteri            = iteri;
exports.map              = map;
exports.mapi             = mapi;
exports.trim             = trim;
exports.escaped          = escaped;
exports.index            = index;
exports.rindex           = rindex;
exports.index_from       = index_from;
exports.rindex_from      = rindex_from;
exports.contains         = contains;
exports.contains_from    = contains_from;
exports.rcontains_from   = rcontains_from;
exports.uppercase        = uppercase;
exports.lowercase        = lowercase;
exports.capitalize       = capitalize;
exports.uncapitalize     = uncapitalize;
exports.compare          = compare;
exports.unsafe_to_string = unsafe_to_string;
exports.unsafe_of_string = unsafe_of_string;
/* No side effect */


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



function cmn(q, a, b, x, s, t) {
  var a$1 = ((a + q | 0) + x | 0) + t | 0;
  return ((a$1 << s) | (a$1 >>> (32 - s | 0)) | 0) + b | 0;
}

function f(a, b, c, d, x, s, t) {
  return cmn(b & c | (b ^ -1) & d, a, b, x, s, t);
}

function g(a, b, c, d, x, s, t) {
  return cmn(b & d | c & (d ^ -1), a, b, x, s, t);
}

function h(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}

function i(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | d ^ -1), a, b, x, s, t);
}

function cycle(x, k) {
  var a = x[0];
  var b = x[1];
  var c = x[2];
  var d = x[3];
  a = f(a, b, c, d, k[0], 7, -680876936);
  d = f(d, a, b, c, k[1], 12, -389564586);
  c = f(c, d, a, b, k[2], 17, 606105819);
  b = f(b, c, d, a, k[3], 22, -1044525330);
  a = f(a, b, c, d, k[4], 7, -176418897);
  d = f(d, a, b, c, k[5], 12, 1200080426);
  c = f(c, d, a, b, k[6], 17, -1473231341);
  b = f(b, c, d, a, k[7], 22, -45705983);
  a = f(a, b, c, d, k[8], 7, 1770035416);
  d = f(d, a, b, c, k[9], 12, -1958414417);
  c = f(c, d, a, b, k[10], 17, -42063);
  b = f(b, c, d, a, k[11], 22, -1990404162);
  a = f(a, b, c, d, k[12], 7, 1804603682);
  d = f(d, a, b, c, k[13], 12, -40341101);
  c = f(c, d, a, b, k[14], 17, -1502002290);
  b = f(b, c, d, a, k[15], 22, 1236535329);
  a = g(a, b, c, d, k[1], 5, -165796510);
  d = g(d, a, b, c, k[6], 9, -1069501632);
  c = g(c, d, a, b, k[11], 14, 643717713);
  b = g(b, c, d, a, k[0], 20, -373897302);
  a = g(a, b, c, d, k[5], 5, -701558691);
  d = g(d, a, b, c, k[10], 9, 38016083);
  c = g(c, d, a, b, k[15], 14, -660478335);
  b = g(b, c, d, a, k[4], 20, -405537848);
  a = g(a, b, c, d, k[9], 5, 568446438);
  d = g(d, a, b, c, k[14], 9, -1019803690);
  c = g(c, d, a, b, k[3], 14, -187363961);
  b = g(b, c, d, a, k[8], 20, 1163531501);
  a = g(a, b, c, d, k[13], 5, -1444681467);
  d = g(d, a, b, c, k[2], 9, -51403784);
  c = g(c, d, a, b, k[7], 14, 1735328473);
  b = g(b, c, d, a, k[12], 20, -1926607734);
  a = h(a, b, c, d, k[5], 4, -378558);
  d = h(d, a, b, c, k[8], 11, -2022574463);
  c = h(c, d, a, b, k[11], 16, 1839030562);
  b = h(b, c, d, a, k[14], 23, -35309556);
  a = h(a, b, c, d, k[1], 4, -1530992060);
  d = h(d, a, b, c, k[4], 11, 1272893353);
  c = h(c, d, a, b, k[7], 16, -155497632);
  b = h(b, c, d, a, k[10], 23, -1094730640);
  a = h(a, b, c, d, k[13], 4, 681279174);
  d = h(d, a, b, c, k[0], 11, -358537222);
  c = h(c, d, a, b, k[3], 16, -722521979);
  b = h(b, c, d, a, k[6], 23, 76029189);
  a = h(a, b, c, d, k[9], 4, -640364487);
  d = h(d, a, b, c, k[12], 11, -421815835);
  c = h(c, d, a, b, k[15], 16, 530742520);
  b = h(b, c, d, a, k[2], 23, -995338651);
  a = i(a, b, c, d, k[0], 6, -198630844);
  d = i(d, a, b, c, k[7], 10, 1126891415);
  c = i(c, d, a, b, k[14], 15, -1416354905);
  b = i(b, c, d, a, k[5], 21, -57434055);
  a = i(a, b, c, d, k[12], 6, 1700485571);
  d = i(d, a, b, c, k[3], 10, -1894986606);
  c = i(c, d, a, b, k[10], 15, -1051523);
  b = i(b, c, d, a, k[1], 21, -2054922799);
  a = i(a, b, c, d, k[8], 6, 1873313359);
  d = i(d, a, b, c, k[15], 10, -30611744);
  c = i(c, d, a, b, k[6], 15, -1560198380);
  b = i(b, c, d, a, k[13], 21, 1309151649);
  a = i(a, b, c, d, k[4], 6, -145523070);
  d = i(d, a, b, c, k[11], 10, -1120210379);
  c = i(c, d, a, b, k[2], 15, 718787259);
  b = i(b, c, d, a, k[9], 21, -343485551);
  x[0] = a + x[0] | 0;
  x[1] = b + x[1] | 0;
  x[2] = c + x[2] | 0;
  x[3] = d + x[3] | 0;
  return /* () */0;
}

var state = /* array */[
  1732584193,
  -271733879,
  -1732584194,
  271733878
];

var md5blk = /* array */[
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];

function caml_md5_string(s, start, len) {
  var s$1 = s.slice(start, len);
  var n = s$1.length;
  state[0] = 1732584193;
  state[1] = -271733879;
  state[2] = -1732584194;
  state[3] = 271733878;
  for(var i = 0; i <= 15; ++i){
    md5blk[i] = 0;
  }
  var i_end = n / 64 | 0;
  for(var i$1 = 1; i$1 <= i_end; ++i$1){
    for(var j = 0; j <= 15; ++j){
      var k = ((i$1 << 6) - 64 | 0) + (j << 2) | 0;
      md5blk[j] = ((s$1.charCodeAt(k) + (s$1.charCodeAt(k + 1 | 0) << 8) | 0) + (s$1.charCodeAt(k + 2 | 0) << 16) | 0) + (s$1.charCodeAt(k + 3 | 0) << 24) | 0;
    }
    cycle(state, md5blk);
  }
  var s_tail = s$1.slice((i_end << 6));
  for(var kk = 0; kk <= 15; ++kk){
    md5blk[kk] = 0;
  }
  var i_end$1 = s_tail.length - 1 | 0;
  for(var i$2 = 0; i$2 <= i_end$1; ++i$2){
    md5blk[i$2 / 4 | 0] = md5blk[i$2 / 4 | 0] | (s_tail.charCodeAt(i$2) << (i$2 % 4 << 3));
  }
  var i$3 = i_end$1 + 1 | 0;
  md5blk[i$3 / 4 | 0] = md5blk[i$3 / 4 | 0] | (128 << (i$3 % 4 << 3));
  if (i$3 > 55) {
    cycle(state, md5blk);
    for(var i$4 = 0; i$4 <= 15; ++i$4){
      md5blk[i$4] = 0;
    }
  }
  md5blk[14] = (n << 3);
  cycle(state, md5blk);
  return String.fromCharCode(state[0] & 255, (state[0] >> 8) & 255, (state[0] >> 16) & 255, (state[0] >> 24) & 255, state[1] & 255, (state[1] >> 8) & 255, (state[1] >> 16) & 255, (state[1] >> 24) & 255, state[2] & 255, (state[2] >> 8) & 255, (state[2] >> 16) & 255, (state[2] >> 24) & 255, state[3] & 255, (state[3] >> 8) & 255, (state[3] >> 16) & 255, (state[3] >> 24) & 255);
}

exports.caml_md5_string = caml_md5_string;
/* No side effect */


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Sys         = __webpack_require__(21);
var Caml_obj    = __webpack_require__(4);
var Caml_format = __webpack_require__(8);

function succ(n) {
  return n + 1;
}

function pred(n) {
  return n - 1;
}

function abs(n) {
  if (n >= 0) {
    return n;
  } else {
    return -n;
  }
}

var min_int = -9007199254740991;

var max_int = 9007199254740991;

function lognot(n) {
  return n ^ -1;
}

function to_string(n) {
  return Caml_format.caml_nativeint_format("%d", n);
}

var compare = Caml_obj.caml_nativeint_compare;

var zero = 0;

var one = 1;

var minus_one = -1;

var size = Sys.word_size;

exports.zero      = zero;
exports.one       = one;
exports.minus_one = minus_one;
exports.succ      = succ;
exports.pred      = pred;
exports.abs       = abs;
exports.size      = size;
exports.max_int   = max_int;
exports.min_int   = min_int;
exports.lognot    = lognot;
exports.to_string = to_string;
exports.compare   = compare;
/* No side effect */


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE



function keycodeMap(param) {
  var switcher = param - 8 | 0;
  if (switcher > 214 || switcher < 0) {
    return /* Nothing */65;
  } else {
    switch (switcher) {
      case 0 : 
          return /* Backspace */0;
      case 1 : 
          return /* Tab */1;
      case 5 : 
          return /* Enter */2;
      case 8 : 
          return /* LeftShift */56;
      case 9 : 
          return /* LeftCtrl */55;
      case 10 : 
          return /* LeftAlt */57;
      case 12 : 
          return /* CapsLock */63;
      case 19 : 
          return /* Escape */3;
      case 24 : 
          return /* Space */4;
      case 29 : 
          return /* Left */52;
      case 30 : 
          return /* Up */54;
      case 31 : 
          return /* Right */51;
      case 32 : 
          return /* Down */53;
      case 40 : 
          return /* Num_0 */10;
      case 41 : 
          return /* Num_1 */11;
      case 42 : 
          return /* Num_2 */12;
      case 43 : 
          return /* Num_3 */13;
      case 44 : 
          return /* Num_4 */14;
      case 45 : 
          return /* Num_5 */15;
      case 46 : 
          return /* Num_6 */16;
      case 47 : 
          return /* Num_7 */17;
      case 48 : 
          return /* Num_8 */18;
      case 49 : 
          return /* Num_9 */19;
      case 57 : 
          return /* A */25;
      case 58 : 
          return /* B */26;
      case 59 : 
          return /* C */27;
      case 60 : 
          return /* D */28;
      case 61 : 
          return /* E */29;
      case 62 : 
          return /* F */30;
      case 63 : 
          return /* G */31;
      case 64 : 
          return /* H */32;
      case 65 : 
          return /* I */33;
      case 66 : 
          return /* J */34;
      case 67 : 
          return /* K */35;
      case 68 : 
          return /* L */36;
      case 69 : 
          return /* M */37;
      case 70 : 
          return /* N */38;
      case 71 : 
          return /* O */39;
      case 72 : 
          return /* P */40;
      case 73 : 
          return /* Q */41;
      case 74 : 
          return /* R */42;
      case 75 : 
          return /* S */43;
      case 76 : 
          return /* T */44;
      case 77 : 
          return /* U */45;
      case 78 : 
          return /* V */46;
      case 79 : 
          return /* W */47;
      case 80 : 
          return /* X */48;
      case 81 : 
          return /* Y */49;
      case 82 : 
          return /* Z */50;
      case 83 : 
          return /* LeftOsKey */58;
      case 85 : 
          return /* RightOsKey */62;
      case 178 : 
          return /* Semicolon */20;
      case 179 : 
          return /* Equals */21;
      case 180 : 
          return /* Comma */6;
      case 181 : 
          return /* Minus */7;
      case 182 : 
          return /* Period */8;
      case 183 : 
          return /* Slash */9;
      case 184 : 
          return /* Backtick */64;
      case 2 : 
      case 3 : 
      case 4 : 
      case 6 : 
      case 7 : 
      case 11 : 
      case 13 : 
      case 14 : 
      case 15 : 
      case 16 : 
      case 17 : 
      case 18 : 
      case 20 : 
      case 21 : 
      case 22 : 
      case 23 : 
      case 25 : 
      case 26 : 
      case 27 : 
      case 28 : 
      case 33 : 
      case 34 : 
      case 35 : 
      case 36 : 
      case 37 : 
      case 38 : 
      case 39 : 
      case 50 : 
      case 51 : 
      case 52 : 
      case 53 : 
      case 54 : 
      case 55 : 
      case 56 : 
      case 84 : 
      case 86 : 
      case 87 : 
      case 88 : 
      case 89 : 
      case 90 : 
      case 91 : 
      case 92 : 
      case 93 : 
      case 94 : 
      case 95 : 
      case 96 : 
      case 97 : 
      case 98 : 
      case 99 : 
      case 100 : 
      case 101 : 
      case 102 : 
      case 103 : 
      case 104 : 
      case 105 : 
      case 106 : 
      case 107 : 
      case 108 : 
      case 109 : 
      case 110 : 
      case 111 : 
      case 112 : 
      case 113 : 
      case 114 : 
      case 115 : 
      case 116 : 
      case 117 : 
      case 118 : 
      case 119 : 
      case 120 : 
      case 121 : 
      case 122 : 
      case 123 : 
      case 124 : 
      case 125 : 
      case 126 : 
      case 127 : 
      case 128 : 
      case 129 : 
      case 130 : 
      case 131 : 
      case 132 : 
      case 133 : 
      case 134 : 
      case 135 : 
      case 136 : 
      case 137 : 
      case 138 : 
      case 139 : 
      case 140 : 
      case 141 : 
      case 142 : 
      case 143 : 
      case 144 : 
      case 145 : 
      case 146 : 
      case 147 : 
      case 148 : 
      case 149 : 
      case 150 : 
      case 151 : 
      case 152 : 
      case 153 : 
      case 154 : 
      case 155 : 
      case 156 : 
      case 157 : 
      case 158 : 
      case 159 : 
      case 160 : 
      case 161 : 
      case 162 : 
      case 163 : 
      case 164 : 
      case 165 : 
      case 166 : 
      case 167 : 
      case 168 : 
      case 169 : 
      case 170 : 
      case 171 : 
      case 172 : 
      case 173 : 
      case 174 : 
      case 175 : 
      case 176 : 
      case 177 : 
      case 185 : 
      case 186 : 
      case 187 : 
      case 188 : 
      case 189 : 
      case 190 : 
      case 191 : 
      case 192 : 
      case 193 : 
      case 194 : 
      case 195 : 
      case 196 : 
      case 197 : 
      case 198 : 
      case 199 : 
      case 200 : 
      case 201 : 
      case 202 : 
      case 203 : 
      case 204 : 
      case 205 : 
      case 206 : 
      case 207 : 
      case 208 : 
      case 209 : 
      case 210 : 
          return /* Nothing */65;
      case 211 : 
          return /* OpenBracket */22;
      case 212 : 
          return /* Backslash */23;
      case 213 : 
          return /* CloseBracket */24;
      case 214 : 
          return /* Quote */5;
      
    }
  }
}

exports.keycodeMap = keycodeMap;
/* No side effect */


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = __webpack_require__(3);
exports.mat2 = __webpack_require__(45);
exports.mat2d = __webpack_require__(46);
exports.mat3 = __webpack_require__(29);
exports.mat4 = __webpack_require__(47);
exports.quat = __webpack_require__(48);
exports.vec2 = __webpack_require__(49);
exports.vec3 = __webpack_require__(30);
exports.vec4 = __webpack_require__(31);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);
var mat3 = __webpack_require__(29);
var vec3 = __webpack_require__(30);
var vec4 = __webpack_require__(31);

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = __webpack_require__(3);

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE



var vertexShaderSource = "\n  attribute vec2 aVertexPosition;\n  attribute vec4 aVertexColor;\n  attribute vec2 aTextureCoord;\n\n  uniform mat4 uPMatrix;\n\n  varying vec4 vColor;\n  varying vec2 vTextureCoord;\n\n  void main(void) {\n    gl_Position = uPMatrix * vec4(aVertexPosition, 0.0, 1.0);\n    vColor = aVertexColor;\n    vTextureCoord = aTextureCoord;\n  }\n";

var fragmentShaderSource = "\n  varying vec4 vColor;\n  varying vec2 vTextureCoord;\n\n  uniform sampler2D uSampler;\n\n  void main(void) {\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + vColor;\n  }\n";

exports.vertexShaderSource   = vertexShaderSource;
exports.fragmentShaderSource = fragmentShaderSource;
/* No side effect */


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var $$Array                = __webpack_require__(24);
var Random                 = __webpack_require__(23);
var Caml_array             = __webpack_require__(7);
var Caml_int32             = __webpack_require__(5);
var Pervasives             = __webpack_require__(2);
var Reprocessing_Common    = __webpack_require__(19);
var Reprocessing_Constants = __webpack_require__(14);

var lookup_table = [/* int array */[]];

function color(r, g, b) {
  return /* record */[
          /* r */r,
          /* g */g,
          /* b */b
        ];
}

function round(i) {
  return Math.floor(i + 0.5);
}

function sq(x) {
  return Caml_int32.imul(x, x);
}

function pow(base, exp) {
  if (exp !== 0) {
    if (exp !== 1) {
      var b = pow(base, exp / 2 | 0);
      return Caml_int32.imul(Caml_int32.imul(b, b), exp % 2 ? base : 1);
    } else {
      return base;
    }
  } else {
    return 1;
  }
}

function constrain(amt, low, high) {
  return Pervasives.max(Pervasives.min(amt, high), low);
}

function remapf(value, low1, high1, low2, high2) {
  return low2 + (high2 - low2) * ((value - low1) / (high1 - low1));
}

function remap(value, low1, high1, low2, high2) {
  return remapf(value, low1, high1, low2, high2) | 0;
}

function norm(value, low, high) {
  return remapf(value, low, high, 0, 1);
}

function randomf(min, max) {
  return Random.$$float(max - min) + min;
}

function random(min, max) {
  return Random.$$int(max - min | 0) + min | 0;
}

var randomSeed = Random.init;

function randomGaussian() {
  var u1 = 0.0;
  var u2 = 0.0;
  while(u1 <= Pervasives.min_float) {
    u1 = Random.$$float(1.0);
    u2 = Random.$$float(1.0);
  };
  return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(Reprocessing_Constants.two_pi * u2);
}

function lerpf(low, high) {
  return (function (param) {
      return remapf(param, 0, 1, low, high);
    });
}

function lerp(low, high, value) {
  return lerpf(low, high)(value) | 0;
}

function distf(param, param$1) {
  var dx = param$1[0] - param[0];
  var dy = param$1[1] - param[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function dist(param, param$1) {
  return distf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ]);
}

function magf(vec) {
  return distf(/* tuple */[
              0,
              0
            ], vec);
}

function mag(vec) {
  return dist(/* tuple */[
              0,
              0
            ], vec);
}

function lerpColor(low, high, value) {
  return /* record */[
          /* r */lerp(low[/* r */0], high[/* r */0], value),
          /* g */lerp(low[/* g */1], high[/* g */1], value),
          /* b */lerp(low[/* b */2], high[/* b */2], value)
        ];
}

function degrees(x) {
  return 180.0 / Reprocessing_Constants.pi * x;
}

function radians(x) {
  return Reprocessing_Constants.pi / 180.0 * x;
}

function noise(x, y, z) {
  var p = lookup_table[0];
  var fade = function (t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
  };
  var grad = function (hash, x, y, z) {
    var match = hash & 15;
    if (match > 15 || match < 0) {
      return 0.0;
    } else {
      switch (match) {
        case 0 : 
            return x + y;
        case 1 : 
            return -x + y;
        case 2 : 
            return x - y;
        case 3 : 
            return -x - y;
        case 4 : 
            return x + z;
        case 5 : 
            return -x + z;
        case 6 : 
            return x - z;
        case 7 : 
            return -x - z;
        case 8 : 
            return y + z;
        case 10 : 
            return y - z;
        case 12 : 
            return y + x;
        case 9 : 
        case 13 : 
            return -y + z;
        case 14 : 
            return y - x;
        case 11 : 
        case 15 : 
            return -y - z;
        
      }
    }
  };
  var xi = x & 255;
  var yi = y & 255;
  var zi = z & 255;
  var xf = x - Math.floor(x);
  var yf = y - Math.floor(y);
  var zf = z - Math.floor(z);
  var u = fade(xf);
  var v = fade(yf);
  var w = fade(zf);
  var aaa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + zi | 0);
  var aba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + zi | 0);
  var aab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + yi | 0) + (zi + 1 | 0) | 0);
  var abb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var baa = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + zi | 0);
  var bba = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + zi | 0);
  var bab = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + yi | 0) + (zi + 1 | 0) | 0);
  var bbb = Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, Caml_array.caml_array_get(p, xi + 1 | 0) + (yi + 1 | 0) | 0) + (zi + 1 | 0) | 0);
  var x1 = lerpf(grad(aaa, xf, yf, zf), grad(baa, xf - 1.0, yf, zf))(u);
  var x2 = lerpf(grad(aba, xf, yf - 1.0, zf), grad(bba, xf - 1.0, yf - 1.0, zf))(u);
  var y1 = lerpf(x1, x2)(v);
  var x1$1 = lerpf(grad(aab, xf, yf, zf - 1.0), grad(bab, xf - 1.0, yf, zf - 1.0))(u);
  var x2$1 = lerpf(grad(abb, xf, yf - 1.0, zf - 1.0), grad(bbb, xf - 1.0, yf - 1.0, zf - 1.0))(u);
  var y2 = lerpf(x1$1, x2$1)(v);
  return (lerpf(y1, y2)(w) + 1.0) / 2.0;
}

function shuffle(array) {
  var array$1 = $$Array.copy(array);
  var length = array$1.length;
  for(var i = 0; i <= 255; ++i){
    var j = Random.$$int(length - i | 0);
    var tmp = Caml_array.caml_array_get(array$1, i);
    Caml_array.caml_array_set(array$1, i, Caml_array.caml_array_get(array$1, i + j | 0));
    Caml_array.caml_array_set(array$1, i + j | 0, tmp);
  }
  return array$1;
}

function noiseSeed(seed) {
  var state = Random.get_state(/* () */0);
  Random.init(seed);
  var array = Caml_array.caml_make_vect(256, 0);
  var array$1 = $$Array.mapi((function (i, _) {
          return i;
        }), array);
  var array$2 = shuffle(array$1);
  var double_array = $$Array.append(array$2, array$2);
  lookup_table[0] = double_array;
  return Random.set_state(state);
}

var split = Reprocessing_Common.split;

exports.color          = color;
exports.round          = round;
exports.sq             = sq;
exports.pow            = pow;
exports.constrain      = constrain;
exports.remapf         = remapf;
exports.remap          = remap;
exports.norm           = norm;
exports.randomf        = randomf;
exports.random         = random;
exports.randomSeed     = randomSeed;
exports.randomGaussian = randomGaussian;
exports.lerpf          = lerpf;
exports.lerp           = lerp;
exports.lerpColor      = lerpColor;
exports.distf          = distf;
exports.dist           = dist;
exports.magf           = magf;
exports.mag            = mag;
exports.degrees        = degrees;
exports.radians        = radians;
exports.noise          = noise;
exports.noiseSeed      = noiseSeed;
exports.split          = split;
/* Reprocessing_Constants Not a pure module */


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                  = __webpack_require__(1);
var Reasongl               = __webpack_require__(10);
var Pervasives             = __webpack_require__(2);
var RGLConstants           = __webpack_require__(12);
var Reprocessing_Env       = __webpack_require__(18);
var Reprocessing_Font      = __webpack_require__(53);
var Reprocessing_Matrix    = __webpack_require__(20);
var Reprocessing_Internal  = __webpack_require__(13);
var Reprocessing_Constants = __webpack_require__(14);

function translate(x, y, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createTranslation(x, y));
}

function rotate(theta, env) {
  return Reprocessing_Matrix.matmatmul(env[/* matrix */16], Reprocessing_Matrix.createRotation(theta));
}

function fill(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor : Some */[color]
  ];
  return /* () */0;
}

function noFill(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor : None */0
  ];
  return /* () */0;
}

function stroke(color, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : Some */[color],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3]
  ];
  return /* () */0;
}

function noStroke(env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor : None */0,
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3]
  ];
  return /* () */0;
}

function strokeWeight(weight, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */weight,
    /* strokeCap */init[/* strokeCap */2],
    /* fillColor */init[/* fillColor */3]
  ];
  return /* () */0;
}

function strokeCap(cap, env) {
  var init = env[/* style */13];
  env[/* style */13] = /* record */[
    /* strokeColor */init[/* strokeColor */0],
    /* strokeWeight */init[/* strokeWeight */1],
    /* strokeCap */cap,
    /* fillColor */init[/* fillColor */3]
  ];
  return /* () */0;
}

function pushStyle(env) {
  env[/* styleStack */14] = /* :: */[
    env[/* style */13],
    env[/* styleStack */14]
  ];
  return /* () */0;
}

function popStyle(env) {
  var match = env[/* styleStack */14];
  if (match) {
    env[/* style */13] = match[0];
    env[/* styleStack */14] = match[1];
    return /* () */0;
  } else {
    return Pervasives.failwith("Too many `popStyle` without enough `pushStyle`.");
  }
}

function loadImage(filename, env) {
  return Reprocessing_Internal.loadImage(env, filename);
}

function subImage(img, param, width, height, param$1, subw, subh, env) {
  var match = img[0];
  if (match) {
    return Reprocessing_Internal.drawImage(match[0], param[0], param[1], width, height, param$1[0], param$1[1], subw, subh, env);
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function image(img, param, width, height, env) {
  var match = img[0];
  if (match) {
    var img$1 = match[0];
    var imgw = img$1[/* width */3];
    var imgh = img$1[/* height */2];
    var exit = 0;
    var w;
    var h;
    if (width) {
      var w$1 = width[0];
      w = w$1;
      if (height) {
        h = height[0];
        exit = 1;
      } else {
        h = imgh;
        exit = 1;
      }
    } else {
      w = imgw;
      if (height) {
        h = height[0];
        exit = 1;
      } else {
        h = imgh;
        exit = 1;
      }
    }
    if (exit === 1) {
      return Reprocessing_Internal.drawImage(img$1, param[0], param[1], w, h, 0, 0, imgw, imgh, env);
    }
    
  } else {
    console.log("image not ready yet, just doing nothing :D");
    return /* () */0;
  }
}

function linef(p1, p2, env) {
  var match = env[/* style */13][/* strokeColor */0];
  if (match) {
    var color = match[0];
    var partial_arg = env[/* matrix */16];
    var transform = function (param) {
      return Reprocessing_Matrix.matptmul(partial_arg, param);
    };
    var width = env[/* style */13][/* strokeWeight */1];
    var radius = width / 2;
    var project = +(env[/* style */13][/* strokeCap */2] === /* Project */2);
    Reprocessing_Internal.drawLine(Curry._1(transform, p1), Curry._1(transform, p2), color, width, project, env);
    if (env[/* style */13][/* strokeCap */2]) {
      return 0;
    } else {
      Reprocessing_Internal.drawEllipse(env, p1, radius, radius, env[/* matrix */16], color);
      return Reprocessing_Internal.drawEllipse(env, p2, radius, radius, env[/* matrix */16], color);
    }
  } else {
    return /* () */0;
  }
}

function line(param, param$1, env) {
  return linef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], env);
}

function ellipsef(center, radx, rady, env) {
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawEllipse(env, center, radx, rady, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Reprocessing_Internal.drawArcStroke(env, center, radx, rady, 0, Reprocessing_Constants.tau, /* false */0, /* false */0, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function ellipse(param, radx, rady, env) {
  return ellipsef(/* tuple */[
              param[0],
              param[1]
            ], radx, rady, env);
}

function quadf(p1, p2, p3, p4, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var match_000 = Curry._1(transform, p1);
  var match_001 = Curry._1(transform, p2);
  var match_002 = Curry._1(transform, p3);
  var match_003 = Curry._1(transform, p4);
  var p4$1 = match_003;
  var p3$1 = match_002;
  var p2$1 = match_001;
  var p1$1 = match_000;
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.addRectToGlobalBatch(env, p3$1, p4$1, p2$1, p1$1, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    linef(p1$1, p2$1, env);
    linef(p2$1, p3$1, env);
    linef(p3$1, p4$1, env);
    linef(p4$1, p1$1, env);
    var r = env[/* style */13][/* strokeWeight */1] / 2;
    Reprocessing_Internal.drawEllipse(env, p1$1, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, p2$1, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, p3$1, r, r, Reprocessing_Matrix.identity, color);
    return Reprocessing_Internal.drawEllipse(env, p4$1, r, r, Reprocessing_Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function quad(param, param$1, param$2, param$3, env) {
  return quadf(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], /* tuple */[
              param$3[0],
              param$3[1]
            ], env);
}

function rectf(param, width, height, env) {
  var y = param[1];
  var x = param[0];
  return quadf(/* tuple */[
              x,
              y
            ], /* tuple */[
              x + width,
              y
            ], /* tuple */[
              x + width,
              y + height
            ], /* tuple */[
              x,
              y + height
            ], env);
}

function rect(param, width, height, env) {
  return rectf(/* tuple */[
              param[0],
              param[1]
            ], width, height, env);
}

function bezier(param, param$1, param$2, param$3, env) {
  var yy4 = param$3[1];
  var xx4 = param$3[0];
  var yy3 = param$2[1];
  var xx3 = param$2[0];
  var yy2 = param$1[1];
  var xx2 = param$1[0];
  var yy1 = param[1];
  var xx1 = param[0];
  var bezier_point = function (t) {
    return /* tuple */[
            Math.pow(1 - t, 3) * xx1 + 3 * Math.pow(1 - t, 2) * t * xx2 + 3 * (1 - t) * Math.pow(t, 2) * xx3 + Math.pow(t, 3) * xx4,
            Math.pow(1 - t, 3) * yy1 + 3 * Math.pow(1 - t, 2) * t * yy2 + 3 * (1 - t) * Math.pow(t, 2) * yy3 + Math.pow(t, 3) * yy4
          ];
  };
  for(var i = 0; i <= 99; ++i){
    linef(bezier_point(i / 100.0), bezier_point((i + 1 | 0) / 100.0), env);
  }
  return /* () */0;
}

function pixelf(param, color, env) {
  var y = param[1];
  var x = param[0];
  var w = env[/* style */13][/* strokeWeight */1];
  return Reprocessing_Internal.addRectToGlobalBatch(env, /* tuple */[
              x + w,
              y + w
            ], /* tuple */[
              x,
              y + w
            ], /* tuple */[
              x + w,
              y
            ], /* tuple */[
              x,
              y
            ], color);
}

function pixel(param, color, env) {
  return pixelf(/* tuple */[
              param[0],
              param[1]
            ], color, env);
}

function trianglef(p1, p2, p3, env) {
  var partial_arg = env[/* matrix */16];
  var transform = function (param) {
    return Reprocessing_Matrix.matptmul(partial_arg, param);
  };
  var match_000 = Curry._1(transform, p1);
  var match_001 = Curry._1(transform, p2);
  var match_002 = Curry._1(transform, p3);
  var p3$1 = match_002;
  var p2$1 = match_001;
  var p1$1 = match_000;
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawTriangle(env, p1$1, p2$1, p3$1, match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    var color = match$1[0];
    linef(p1$1, p2$1, env);
    linef(p2$1, p3$1, env);
    linef(p3$1, p1$1, env);
    var r = env[/* style */13][/* strokeWeight */1] / 2;
    Reprocessing_Internal.drawEllipse(env, p1$1, r, r, Reprocessing_Matrix.identity, color);
    Reprocessing_Internal.drawEllipse(env, p2$1, r, r, Reprocessing_Matrix.identity, color);
    return Reprocessing_Internal.drawEllipse(env, p3$1, r, r, Reprocessing_Matrix.identity, color);
  } else {
    return /* () */0;
  }
}

function triangle(param, param$1, param$2, env) {
  return trianglef(/* tuple */[
              param[0],
              param[1]
            ], /* tuple */[
              param$1[0],
              param$1[1]
            ], /* tuple */[
              param$2[0],
              param$2[1]
            ], env);
}

function arcf(center, radx, rady, start, stop, isOpen, isPie, env) {
  var match = env[/* style */13][/* fillColor */3];
  if (match) {
    Reprocessing_Internal.drawArc(env, center, radx, rady, start, stop, isPie, env[/* matrix */16], match[0]);
  }
  var match$1 = env[/* style */13][/* strokeColor */0];
  if (match$1) {
    return Reprocessing_Internal.drawArcStroke(env, center, radx, rady, start, stop, isOpen, isPie, env[/* matrix */16], match$1[0], env[/* style */13][/* strokeWeight */1]);
  } else {
    return /* () */0;
  }
}

function arc(param, radx, rady, start, stop, isOpen, isPie, env) {
  return arcf(/* tuple */[
              param[0],
              param[1]
            ], radx, rady, start, stop, isOpen, isPie, env);
}

function loadFont(filename, env) {
  return Curry._2(Reprocessing_Font.Font[/* parseFontFormat */8], env, filename);
}

function text(font, body, param, env) {
  return Curry._5(Reprocessing_Font.Font[/* drawString */11], env, font, body, param[0], param[1]);
}

function clear(env) {
  return Curry._2(Reasongl.Gl[/* clear */34], env[/* gl */2], RGLConstants.color_buffer_bit | RGLConstants.depth_buffer_bit);
}

function background(color, env) {
  clear(env);
  var w = Reprocessing_Env.width(env);
  var h = Reprocessing_Env.height(env);
  return Reprocessing_Internal.addRectToGlobalBatch(env, /* tuple */[
              w,
              h
            ], /* tuple */[
              0,
              h
            ], /* tuple */[
              w,
              0
            ], /* tuple */[
              0,
              0
            ], color);
}

exports.translate    = translate;
exports.rotate       = rotate;
exports.fill         = fill;
exports.noFill       = noFill;
exports.stroke       = stroke;
exports.noStroke     = noStroke;
exports.strokeWeight = strokeWeight;
exports.strokeCap    = strokeCap;
exports.pushStyle    = pushStyle;
exports.popStyle     = popStyle;
exports.loadImage    = loadImage;
exports.image        = image;
exports.subImage     = subImage;
exports.rectf        = rectf;
exports.rect         = rect;
exports.linef        = linef;
exports.line         = line;
exports.ellipsef     = ellipsef;
exports.ellipse      = ellipse;
exports.quadf        = quadf;
exports.quad         = quad;
exports.pixelf       = pixelf;
exports.pixel        = pixel;
exports.trianglef    = trianglef;
exports.triangle     = triangle;
exports.bezier       = bezier;
exports.arcf         = arcf;
exports.arc          = arc;
exports.loadFont     = loadFont;
exports.text         = text;
exports.clear        = clear;
exports.background   = background;
/* Reasongl Not a pure module */


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var $$Map                 = __webpack_require__(54);
var List                  = __webpack_require__(9);
var Curry                 = __webpack_require__(1);
var $$String              = __webpack_require__(17);
var Caml_obj              = __webpack_require__(4);
var Reasongl              = __webpack_require__(10);
var Pervasives            = __webpack_require__(2);
var Caml_format           = __webpack_require__(8);
var Reprocessing_Common   = __webpack_require__(19);
var Reprocessing_Internal = __webpack_require__(13);

var compare = Caml_obj.caml_compare;

var IntMap = $$Map.Make(/* module */[/* compare */compare]);

function compare$1(param, param$1) {
  var first = Caml_obj.caml_compare(param[0], param$1[0]);
  if (first !== 0) {
    return first;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var IntPairMap = $$Map.Make(/* module */[/* compare */compare$1]);

function parse_num(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Curry._1(Reprocessing_Common.Stream[/* peekch */1], stream);
    var exit = 0;
    var c;
    if (match) {
      var c$1 = match[0];
      if (c$1 >= 48) {
        if (c$1 >= 58) {
          exit = 1;
        } else {
          c = c$1;
          exit = 2;
        }
      } else if (c$1 !== 45) {
        exit = 1;
      } else {
        c = c$1;
        exit = 2;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 : 
          try {
            return /* tuple */[
                    stream,
                    Caml_format.caml_int_of_string(acc)
                  ];
          }
          catch (exn){
            return Pervasives.failwith("Could not parse number [" + (acc + "]."));
          }
          break;
      case 2 : 
          _acc = Reprocessing_Common.append_char(acc, c);
          _stream = Curry._1(Reprocessing_Common.Stream[/* popch */2], stream);
          continue ;
          
    }
  };
}

function parse_num$1(stream) {
  return parse_num(stream, "");
}

function parse_string(_stream, _acc) {
  while(true) {
    var acc = _acc;
    var stream = _stream;
    var match = Curry._1(Reprocessing_Common.Stream[/* peekch */1], stream);
    if (match) {
      var c = match[0];
      if (c !== 34) {
        _acc = Reprocessing_Common.append_char(acc, c);
        _stream = Curry._1(Reprocessing_Common.Stream[/* popch */2], stream);
        continue ;
        
      } else {
        return /* tuple */[
                Curry._1(Reprocessing_Common.Stream[/* popch */2], stream),
                acc
              ];
      }
    } else {
      return Pervasives.failwith("Unterminated string.");
    }
  };
}

function parse_string$1(stream) {
  return parse_string(stream, "");
}

function pop_line(_stream) {
  while(true) {
    var stream = _stream;
    var match = Curry._1(Reprocessing_Common.Stream[/* peekch */1], stream);
    if (match) {
      if (match[0] !== 10) {
        _stream = Curry._1(Reprocessing_Common.Stream[/* popch */2], stream);
        continue ;
        
      } else {
        return Curry._1(Reprocessing_Common.Stream[/* popch */2], stream);
      }
    } else {
      return Pervasives.failwith("could not pop line");
    }
  };
}

function parse_char_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num < 0) {
      return /* tuple */[
              stream,
              map
            ];
    } else {
      var stream$1 = Curry._2(Reprocessing_Common.Stream[/* switch */5], stream, "char id=");
      var match = parse_num(stream$1, "");
      var stream$2 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match[0], " x=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$1[0], " y=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$2[0], " width=");
      var match$3 = parse_num(stream$4, "");
      var stream$5 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$3[0], " height=");
      var match$4 = parse_num(stream$5, "");
      var stream$6 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$4[0], " xoffset=");
      var match$5 = parse_num(stream$6, "");
      var stream$7 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$5[0], " yoffset=");
      var match$6 = parse_num(stream$7, "");
      var stream$8 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$6[0], " xadvance=");
      var match$7 = parse_num(stream$8, "");
      var stream$9 = pop_line(match$7[0]);
      var new_map = Curry._3(IntMap[/* add */3], match[1], /* record */[
            /* x */match$1[1],
            /* y */match$2[1],
            /* width */match$3[1],
            /* height */match$4[1],
            /* xoffset */match$5[1],
            /* yoffset */match$6[1],
            /* xadvance */match$7[1]
          ], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$9;
      continue ;
      
    }
  };
}

function parse_kern_fmt(_stream, _num, _map) {
  while(true) {
    var map = _map;
    var num = _num;
    var stream = _stream;
    if (num) {
      var stream$1 = Curry._2(Reprocessing_Common.Stream[/* switch */5], stream, "kerning first=");
      var match = parse_num(stream$1, "");
      var stream$2 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match[0], " second=");
      var match$1 = parse_num(stream$2, "");
      var stream$3 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$1[0], " amount=");
      var match$2 = parse_num(stream$3, "");
      var stream$4 = pop_line(match$2[0]);
      var new_map = Curry._3(IntPairMap[/* add */3], /* tuple */[
            match[1],
            match$1[1]
          ], match$2[1], map);
      _map = new_map;
      _num = num - 1 | 0;
      _stream = stream$4;
      continue ;
      
    } else {
      return /* tuple */[
              stream,
              map
            ];
    }
  };
}

function replaceFilename(path, filename) {
  var splitStr = Reprocessing_Common.split(path, /* "/" */47);
  var revLst = List.rev(splitStr);
  var newRevLst = revLst ? /* :: */[
      filename,
      revLst[1]
    ] : /* [] */0;
  var newLst = List.rev(newRevLst);
  return $$String.concat("/", newLst);
}

function parseFontFormat(env, path) {
  var ret = [/* None */0];
  Curry._2(Reasongl.Gl[/* File */1][/* readFile */0], path, (function (str) {
          var stream = Curry._1(Reprocessing_Common.Stream[/* create */7], str + "\n");
          var stream$1 = pop_line(pop_line(stream));
          var stream$2 = Curry._2(Reprocessing_Common.Stream[/* switch */5], stream$1, "page id=0 file=\"");
          var match = parse_string(stream$2, "");
          var stream$3 = pop_line(match[0]);
          var stream$4 = Curry._2(Reprocessing_Common.Stream[/* switch */5], stream$3, "chars count=");
          var match$1 = parse_num(stream$4, "");
          var stream$5 = pop_line(match$1[0]);
          var match$2 = parse_char_fmt(stream$5, match$1[1], IntMap[/* empty */0]);
          var stream$6 = Curry._2(Reprocessing_Common.Stream[/* switch */5], match$2[0], "kernings count=");
          var match$3 = parse_num(stream$6, "");
          var stream$7 = pop_line(match$3[0]);
          var match$4 = parse_kern_fmt(stream$7, match$3[1], IntPairMap[/* empty */0]);
          var img_filename = replaceFilename(path, match[1]);
          ret[0] = /* Some */[/* record */[
              /* chars */match$2[1],
              /* kerning */match$4[1],
              /* image */Reprocessing_Internal.loadImage(env, img_filename)
            ]];
          return /* () */0;
        }));
  return ret;
}

function getChar(fnt, ch) {
  try {
    return Curry._2(IntMap[/* find */21], ch, fnt[/* chars */0]);
  }
  catch (exn){
    return Pervasives.failwith("Could not find character " + (Pervasives.string_of_int(ch) + " in font."));
  }
}

function drawChar(env, fnt, image, ch, last, x, y) {
  var c = getChar(fnt, ch);
  var kernAmount;
  if (last) {
    try {
      kernAmount = Curry._2(IntPairMap[/* find */21], /* tuple */[
            last[0],
            ch
          ], fnt[/* kerning */1]);
    }
    catch (exn){
      kernAmount = 0;
    }
  } else {
    kernAmount = 0;
  }
  if (image) {
    Reprocessing_Internal.drawImage(image[0], (x + c[/* xoffset */4] | 0) + kernAmount | 0, y + c[/* yoffset */5] | 0, c[/* width */2], c[/* height */3], c[/* x */0], c[/* y */1], c[/* width */2], c[/* height */3], env);
    return c[/* xadvance */6] + kernAmount | 0;
  } else {
    return c[/* xadvance */6] + kernAmount | 0;
  }
}

function drawString(env, fnt, str, x, y) {
  var match = fnt[0];
  if (match) {
    var fnt$1 = match[0];
    var match$1 = fnt$1[/* image */2][0];
    if (match$1) {
      var img = match$1[0];
      var offset = [x];
      var lastChar = [/* None */0];
      return $$String.iter((function (c) {
                    var advance = drawChar(env, fnt$1, /* Some */[img], c, lastChar[0], offset[0], y);
                    offset[0] = offset[0] + advance | 0;
                    lastChar[0] = /* Some */[c];
                    return /* () */0;
                  }), str);
    } else {
      console.log("loading font.");
      return /* () */0;
    }
  } else {
    return /* () */0;
  }
}

function calcStringWidth(env, fnt, str) {
  var offset = [0];
  var lastChar = [/* None */0];
  $$String.iter((function (c) {
          offset[0] = offset[0] + drawChar(env, fnt, /* None */0, c, lastChar[0], offset[0], 0) | 0;
          lastChar[0] = /* Some */[c];
          return /* () */0;
        }), str);
  return offset[0];
}

var Font = /* module */[
  /* IntMap */IntMap,
  /* IntPairMap */IntPairMap,
  /* parse_num */parse_num$1,
  /* parse_string */parse_string$1,
  /* pop_line */pop_line,
  /* parse_char_fmt */parse_char_fmt,
  /* parse_kern_fmt */parse_kern_fmt,
  /* replaceFilename */replaceFilename,
  /* parseFontFormat */parseFontFormat,
  /* getChar */getChar,
  /* drawChar */drawChar,
  /* drawString */drawString,
  /* calcStringWidth */calcStringWidth
];

var Internal = 0;

exports.Internal = Internal;
exports.Font     = Font;
/* IntMap Not a pure module */


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Curry                   = __webpack_require__(1);
var Caml_builtin_exceptions = __webpack_require__(0);

function Make(funarg) {
  var height = function (param) {
    if (param) {
      return param[4];
    } else {
      return 0;
    }
  };
  var create = function (l, x, d, r) {
    var hl = height(l);
    var hr = height(r);
    return /* Node */[
            l,
            x,
            d,
            r,
            hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          ];
  };
  var singleton = function (x, d) {
    return /* Node */[
            /* Empty */0,
            x,
            d,
            /* Empty */0,
            1
          ];
  };
  var bal = function (l, x, d, r) {
    var hl = l ? l[4] : 0;
    var hr = r ? r[4] : 0;
    if (hl > (hr + 2 | 0)) {
      if (l) {
        var lr = l[3];
        var ld = l[2];
        var lv = l[1];
        var ll = l[0];
        if (height(ll) >= height(lr)) {
          return create(ll, lv, ld, create(lr, x, d, r));
        } else if (lr) {
          return create(create(ll, lv, ld, lr[0]), lr[1], lr[2], create(lr[3], x, d, r));
        } else {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else if (hr > (hl + 2 | 0)) {
      if (r) {
        var rr = r[3];
        var rd = r[2];
        var rv = r[1];
        var rl = r[0];
        if (height(rr) >= height(rl)) {
          return create(create(l, x, d, rl), rv, rd, rr);
        } else if (rl) {
          return create(create(l, x, d, rl[0]), rl[1], rl[2], create(rl[3], rv, rd, rr));
        } else {
          throw [
                Caml_builtin_exceptions.invalid_argument,
                "Map.bal"
              ];
        }
      } else {
        throw [
              Caml_builtin_exceptions.invalid_argument,
              "Map.bal"
            ];
      }
    } else {
      return /* Node */[
              l,
              x,
              d,
              r,
              hl >= hr ? hl + 1 | 0 : hr + 1 | 0
            ];
    }
  };
  var is_empty = function (param) {
    if (param) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var add = function (x, data, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Curry._2(funarg[/* compare */0], x, v);
      if (c) {
        if (c < 0) {
          return bal(add(x, data, l), v, d, r);
        } else {
          return bal(l, v, d, add(x, data, r));
        }
      } else {
        return /* Node */[
                l,
                x,
                data,
                r,
                param[4]
              ];
      }
    } else {
      return /* Node */[
              /* Empty */0,
              x,
              data,
              /* Empty */0,
              1
            ];
    }
  };
  var find = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = Curry._2(funarg[/* compare */0], x, param[1]);
        if (c) {
          _param = c < 0 ? param[0] : param[3];
          continue ;
          
        } else {
          return param[2];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  };
  var mem = function (x, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var c = Curry._2(funarg[/* compare */0], x, param[1]);
        if (c) {
          _param = c < 0 ? param[0] : param[3];
          continue ;
          
        } else {
          return /* true */1;
        }
      } else {
        return /* false */0;
      }
    };
  };
  var min_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[0];
        if (l) {
          _param = l;
          continue ;
          
        } else {
          return /* tuple */[
                  param[1],
                  param[2]
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  };
  var max_binding = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var r = param[3];
        if (r) {
          _param = r;
          continue ;
          
        } else {
          return /* tuple */[
                  param[1],
                  param[2]
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  };
  var remove_min_binding = function (param) {
    if (param) {
      var l = param[0];
      if (l) {
        return bal(remove_min_binding(l), param[1], param[2], param[3]);
      } else {
        return param[3];
      }
    } else {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Map.remove_min_elt"
          ];
    }
  };
  var remove = function (x, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Curry._2(funarg[/* compare */0], x, v);
      if (c) {
        if (c < 0) {
          return bal(remove(x, l), v, d, r);
        } else {
          return bal(l, v, d, remove(x, r));
        }
      } else {
        var t1 = l;
        var t2 = r;
        if (t1) {
          if (t2) {
            var match = min_binding(t2);
            return bal(t1, match[0], match[1], remove_min_binding(t2));
          } else {
            return t1;
          }
        } else {
          return t2;
        }
      }
    } else {
      return /* Empty */0;
    }
  };
  var iter = function (f, _param) {
    while(true) {
      var param = _param;
      if (param) {
        iter(f, param[0]);
        Curry._2(f, param[1], param[2]);
        _param = param[3];
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  var map = function (f, param) {
    if (param) {
      var l$prime = map(f, param[0]);
      var d$prime = Curry._1(f, param[2]);
      var r$prime = map(f, param[3]);
      return /* Node */[
              l$prime,
              param[1],
              d$prime,
              r$prime,
              param[4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var mapi = function (f, param) {
    if (param) {
      var v = param[1];
      var l$prime = mapi(f, param[0]);
      var d$prime = Curry._2(f, v, param[2]);
      var r$prime = mapi(f, param[3]);
      return /* Node */[
              l$prime,
              v,
              d$prime,
              r$prime,
              param[4]
            ];
    } else {
      return /* Empty */0;
    }
  };
  var fold = function (f, _m, _accu) {
    while(true) {
      var accu = _accu;
      var m = _m;
      if (m) {
        _accu = Curry._3(f, m[1], m[2], fold(f, m[0], accu));
        _m = m[3];
        continue ;
        
      } else {
        return accu;
      }
    };
  };
  var for_all = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(p, param[1], param[2])) {
          if (for_all(p, param[0])) {
            _param = param[3];
            continue ;
            
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    };
  };
  var exists = function (p, _param) {
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(p, param[1], param[2])) {
          return /* true */1;
        } else if (exists(p, param[0])) {
          return /* true */1;
        } else {
          _param = param[3];
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    };
  };
  var add_min_binding = function (k, v, param) {
    if (param) {
      return bal(add_min_binding(k, v, param[0]), param[1], param[2], param[3]);
    } else {
      return singleton(k, v);
    }
  };
  var add_max_binding = function (k, v, param) {
    if (param) {
      return bal(param[0], param[1], param[2], add_max_binding(k, v, param[3]));
    } else {
      return singleton(k, v);
    }
  };
  var join = function (l, v, d, r) {
    if (l) {
      if (r) {
        var rh = r[4];
        var lh = l[4];
        if (lh > (rh + 2 | 0)) {
          return bal(l[0], l[1], l[2], join(l[3], v, d, r));
        } else if (rh > (lh + 2 | 0)) {
          return bal(join(l, v, d, r[0]), r[1], r[2], r[3]);
        } else {
          return create(l, v, d, r);
        }
      } else {
        return add_max_binding(v, d, l);
      }
    } else {
      return add_min_binding(v, d, r);
    }
  };
  var concat = function (t1, t2) {
    if (t1) {
      if (t2) {
        var match = min_binding(t2);
        return join(t1, match[0], match[1], remove_min_binding(t2));
      } else {
        return t1;
      }
    } else {
      return t2;
    }
  };
  var concat_or_join = function (t1, v, d, t2) {
    if (d) {
      return join(t1, v, d[0], t2);
    } else {
      return concat(t1, t2);
    }
  };
  var split = function (x, param) {
    if (param) {
      var r = param[3];
      var d = param[2];
      var v = param[1];
      var l = param[0];
      var c = Curry._2(funarg[/* compare */0], x, v);
      if (c) {
        if (c < 0) {
          var match = split(x, l);
          return /* tuple */[
                  match[0],
                  match[1],
                  join(match[2], v, d, r)
                ];
        } else {
          var match$1 = split(x, r);
          return /* tuple */[
                  join(l, v, d, match$1[0]),
                  match$1[1],
                  match$1[2]
                ];
        }
      } else {
        return /* tuple */[
                l,
                /* Some */[d],
                r
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              /* None */0,
              /* Empty */0
            ];
    }
  };
  var merge = function (f, s1, s2) {
    var exit = 0;
    if (s1) {
      var v1 = s1[1];
      if (s1[4] >= height(s2)) {
        var match = split(v1, s2);
        return concat_or_join(merge(f, s1[0], match[0]), v1, Curry._3(f, v1, /* Some */[s1[2]], match[1]), merge(f, s1[3], match[2]));
      } else {
        exit = 1;
      }
    } else if (s2) {
      exit = 1;
    } else {
      return /* Empty */0;
    }
    if (exit === 1) {
      if (s2) {
        var v2 = s2[1];
        var match$1 = split(v2, s1);
        return concat_or_join(merge(f, match$1[0], s2[0]), v2, Curry._3(f, v2, match$1[1], /* Some */[s2[2]]), merge(f, match$1[2], s2[3]));
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "map.ml",
                270,
                10
              ]
            ];
      }
    }
    
  };
  var filter = function (p, param) {
    if (param) {
      var d = param[2];
      var v = param[1];
      var l$prime = filter(p, param[0]);
      var pvd = Curry._2(p, v, d);
      var r$prime = filter(p, param[3]);
      if (pvd) {
        return join(l$prime, v, d, r$prime);
      } else {
        return concat(l$prime, r$prime);
      }
    } else {
      return /* Empty */0;
    }
  };
  var partition = function (p, param) {
    if (param) {
      var d = param[2];
      var v = param[1];
      var match = partition(p, param[0]);
      var lf = match[1];
      var lt = match[0];
      var pvd = Curry._2(p, v, d);
      var match$1 = partition(p, param[3]);
      var rf = match$1[1];
      var rt = match$1[0];
      if (pvd) {
        return /* tuple */[
                join(lt, v, d, rt),
                concat(lf, rf)
              ];
      } else {
        return /* tuple */[
                concat(lt, rt),
                join(lf, v, d, rf)
              ];
      }
    } else {
      return /* tuple */[
              /* Empty */0,
              /* Empty */0
            ];
    }
  };
  var cons_enum = function (_m, _e) {
    while(true) {
      var e = _e;
      var m = _m;
      if (m) {
        _e = /* More */[
          m[1],
          m[2],
          m[3],
          e
        ];
        _m = m[0];
        continue ;
        
      } else {
        return e;
      }
    };
  };
  var compare = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (e1) {
        if (e2) {
          var c = Curry._2(funarg[/* compare */0], e1[0], e2[0]);
          if (c !== 0) {
            return c;
          } else {
            var c$1 = Curry._2(cmp, e1[1], e2[1]);
            if (c$1 !== 0) {
              return c$1;
            } else {
              _e2 = cons_enum(e2[2], e2[3]);
              _e1 = cons_enum(e1[2], e1[3]);
              continue ;
              
            }
          }
        } else {
          return 1;
        }
      } else if (e2) {
        return -1;
      } else {
        return 0;
      }
    };
  };
  var equal = function (cmp, m1, m2) {
    var _e1 = cons_enum(m1, /* End */0);
    var _e2 = cons_enum(m2, /* End */0);
    while(true) {
      var e2 = _e2;
      var e1 = _e1;
      if (e1) {
        if (e2) {
          if (Curry._2(funarg[/* compare */0], e1[0], e2[0])) {
            return /* false */0;
          } else if (Curry._2(cmp, e1[1], e2[1])) {
            _e2 = cons_enum(e2[2], e2[3]);
            _e1 = cons_enum(e1[2], e1[3]);
            continue ;
            
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
      } else if (e2) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    };
  };
  var cardinal = function (param) {
    if (param) {
      return (cardinal(param[0]) + 1 | 0) + cardinal(param[3]) | 0;
    } else {
      return 0;
    }
  };
  var bindings_aux = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (param) {
        _param = param[0];
        _accu = /* :: */[
          /* tuple */[
            param[1],
            param[2]
          ],
          bindings_aux(accu, param[3])
        ];
        continue ;
        
      } else {
        return accu;
      }
    };
  };
  var bindings = function (s) {
    return bindings_aux(/* [] */0, s);
  };
  return [
          /* Empty */0,
          is_empty,
          mem,
          add,
          singleton,
          remove,
          merge,
          compare,
          equal,
          iter,
          fold,
          for_all,
          exists,
          filter,
          partition,
          cardinal,
          bindings,
          min_binding,
          max_binding,
          min_binding,
          split,
          find,
          map,
          mapi
        ];
}

exports.Make = Make;
/* No side effect */


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry = __webpack_require__(1);

function alwaysNone() {
  return /* None */0;
}

function alwaysTrue() {
  return /* true */1;
}

function alwaysTrue2(_, _$1) {
  return /* true */1;
}

function alwaysTrue3(_, _$1, _$2) {
  return /* true */1;
}

function call(f) {
  return Curry._1(f, /* () */0);
}

function compose(f1, f2, a) {
  return Curry._1(f2, Curry._1(f1, a));
}

function flip(f, b, a) {
  return Curry._2(f, a, b);
}

function getKey(k, _) {
  return k;
}

function getValue(_, v) {
  return v;
}

function identity(a) {
  return a;
}

function pairify(k, v) {
  return /* tuple */[
          k,
          v
        ];
}

function returnSome(a, _) {
  return /* Some */[a];
}

function $great$great(f1, f2) {
  return (function (param) {
      return Curry._1(f2, Curry._1(f1, param));
    });
}

var Operators = /* module */[/* >> */$great$great];

exports.alwaysNone  = alwaysNone;
exports.alwaysTrue  = alwaysTrue;
exports.alwaysTrue2 = alwaysTrue2;
exports.alwaysTrue3 = alwaysTrue3;
exports.call        = call;
exports.compose     = compose;
exports.flip        = flip;
exports.getKey      = getKey;
exports.getValue    = getValue;
exports.identity    = identity;
exports.pairify     = pairify;
exports.returnSome  = returnSome;
exports.Operators   = Operators;
/* No side effect */


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var Option        = __webpack_require__(61);
var ImmList       = __webpack_require__(64);
var Iterable      = __webpack_require__(57);
var Functions     = __webpack_require__(55);
var Pervasives    = __webpack_require__(2);
var Preconditions = __webpack_require__(63);

function emptySeq() {
  return /* Completed */0;
}

function isEmpty(seq) {
  return +(seq === emptySeq);
}

function reduce(predicate, reducer, _acc, _seq) {
  while(true) {
    var seq = _seq;
    var acc = _acc;
    var match = Curry._1(seq, /* () */0);
    if (match) {
      var value = match[0];
      if (Curry._2(predicate, acc, value)) {
        var acc$1 = Curry._2(reducer, acc, value);
        _seq = match[1];
        _acc = acc$1;
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

var include = Iterable.Make1(/* module */[
      /* isEmpty */isEmpty,
      /* reduce */reduce
    ]);

function empty() {
  return emptySeq;
}

function $$return(value, _) {
  return /* Next */[
          value,
          emptySeq
        ];
}

function ofList(list, _) {
  if (list) {
    var tail = list[1];
    var value = list[0];
    if (tail) {
      return /* Next */[
              value,
              (function (param) {
                  return ofList(tail, param);
                })
            ];
    } else {
      return /* Next */[
              value,
              emptySeq
            ];
    }
  } else {
    return /* Completed */0;
  }
}

function flatten(seq) {
  var continuedWith = function (continuation, iter) {
    if (iter) {
      return /* Next */[
              iter[0],
              Curry._2(Functions.Operators[/* >> */0], iter[1], (function (param) {
                      return continuedWith(continuation, param);
                    }))
            ];
    } else {
      return flattenIter(Curry._1(continuation, /* () */0));
    }
  };
  var flattenIter = function (iter) {
    if (iter) {
      return continuedWith(iter[1], Curry._1(iter[0], /* () */0));
    } else {
      return /* Completed */0;
    }
  };
  return (function () {
      return flattenIter(Curry._1(seq, /* () */0));
    });
}

function concat(seqs) {
  return flatten((function (param) {
                return ofList(seqs, param);
              }));
}

function defer(f, _) {
  return Curry._2(f, /* () */0, /* () */0);
}

function filter(f, seq) {
  return (function () {
      var f$1 = f;
      var _iter = Curry._1(seq, /* () */0);
      while(true) {
        var iter = _iter;
        if (iter) {
          var next = iter[1];
          var value = iter[0];
          if (Curry._1(f$1, value)) {
            return /* Next */[
                    value,
                    filter(f$1, next)
                  ];
          } else {
            _iter = Curry._1(next, /* () */0);
            continue ;
            
          }
        } else {
          return /* Completed */0;
        }
      };
    });
}

function first(seq) {
  var match = Curry._1(seq, /* () */0);
  if (match) {
    return /* Some */[match[0]];
  } else {
    return /* None */0;
  }
}

function firstOrRaise(seq) {
  var match = Curry._1(seq, /* () */0);
  if (match) {
    return match[0];
  } else {
    return Pervasives.failwith("empty");
  }
}

function generate(f, acc, _) {
  var partial_arg = Curry._1(f, acc);
  return /* Next */[
          acc,
          (function (param) {
              return generate(f, partial_arg, param);
            })
        ];
}

function map(f, seq, _) {
  var match = Curry._1(seq, /* () */0);
  if (match) {
    var next = match[1];
    return /* Next */[
            Curry._1(f, match[0]),
            (function (param) {
                return map(f, next, param);
              })
          ];
  } else {
    return /* Completed */0;
  }
}

function doOnNext(f, seq) {
  return (function (param) {
      return map((function (next) {
                    Curry._1(f, next);
                    return next;
                  }), seq, param);
    });
}

function flatMap(f, seq) {
  return flatten((function (param) {
                return map(f, seq, param);
              }));
}

function ofOption(opt) {
  if (opt) {
    var partial_arg = opt[0];
    return (function () {
        return /* Next */[
                partial_arg,
                emptySeq
              ];
      });
  } else {
    return emptySeq;
  }
}

function scan(reducer, acc, seq) {
  var recurse = function (reducer, acc, seq, _) {
    var match = Curry._1(seq, /* () */0);
    if (match) {
      var next = match[1];
      var acc$1 = Curry._2(reducer, acc, match[0]);
      return /* Next */[
              acc$1,
              (function (param) {
                  return recurse(reducer, acc$1, next, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  };
  return (function () {
      return /* Next */[
              acc,
              (function (param) {
                  return recurse(reducer, acc, seq, param);
                })
            ];
    });
}

function distinctUntilChangedWith(equality, seq, _) {
  var iter = function (equality, prevValue, _next, _param) {
    while(true) {
      var next = _next;
      var match = Curry._1(next, /* () */0);
      if (match) {
        var next$1 = match[1];
        var value = match[0];
        if (Curry._2(equality, prevValue, value)) {
          _param = /* () */0;
          _next = next$1;
          continue ;
          
        } else {
          return /* Next */[
                  value,
                  (function(value,next$1){
                  return function (param) {
                    return iter(equality, value, next$1, param);
                  }
                  }(value,next$1))
                ];
        }
      } else {
        return /* Completed */0;
      }
    };
  };
  var match = Curry._1(seq, /* () */0);
  if (match) {
    var next = match[1];
    var value = match[0];
    return /* Next */[
            value,
            (function (param) {
                return iter(equality, value, next, param);
              })
          ];
  } else {
    return /* Completed */0;
  }
}

function seek(_count, _seq) {
  while(true) {
    var seq = _seq;
    var count = _count;
    Preconditions.failIf("count must be >= 0", +(count < 0));
    if (count) {
      var match = Curry._1(seq, /* () */0);
      if (match) {
        _seq = match[1];
        _count = count - 1 | 0;
        continue ;
        
      } else {
        return seq;
      }
    } else {
      return seq;
    }
  };
}

function seekWhile(f, _seq) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, /* () */0);
    if (match) {
      if (Curry._1(f, match[0])) {
        _seq = match[1];
        continue ;
        
      } else {
        return seq;
      }
    } else {
      return seq;
    }
  };
}

function skip(count, seq) {
  Preconditions.failIf("count must be >= 0", +(count < 0));
  return (function () {
      var _count = count;
      var _iter = Curry._1(seq, /* () */0);
      while(true) {
        var iter = _iter;
        var count$1 = _count;
        if (iter) {
          if (count$1 > 0) {
            _iter = Curry._1(iter[1], /* () */0);
            _count = count$1 - 1 | 0;
            continue ;
            
          } else {
            return iter;
          }
        } else {
          return /* Completed */0;
        }
      };
    });
}

function skipWhile(f, seq, _) {
  var f$1 = f;
  var _iter = Curry._1(seq, /* () */0);
  while(true) {
    var iter = _iter;
    if (iter) {
      if (Curry._1(f$1, iter[0])) {
        _iter = Curry._1(iter[1], /* () */0);
        continue ;
        
      } else {
        return iter;
      }
    } else {
      return /* Completed */0;
    }
  };
}

function startWith(value, seq) {
  var seqs_000 = function () {
    return /* Next */[
            value,
            emptySeq
          ];
  };
  var seqs_001 = /* :: */[
    seq,
    /* [] */0
  ];
  var seqs = /* :: */[
    seqs_000,
    seqs_001
  ];
  return flatten((function (param) {
                return ofList(seqs, param);
              }));
}

function takeWhile(f, seq, _) {
  var match = Curry._1(seq, /* () */0);
  if (match) {
    var next = match[1];
    var value = match[0];
    if (Curry._1(f, value)) {
      return /* Next */[
              value,
              (function (param) {
                  return takeWhile(f, next, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  } else {
    return /* Completed */0;
  }
}

function take(count, seq) {
  Preconditions.failIf("count must be >= 0", +(count < 0));
  return (function () {
      if (count > 0) {
        var match = Curry._1(seq, /* () */0);
        if (match) {
          return /* Next */[
                  match[0],
                  take(count - 1 | 0, match[1])
                ];
        } else {
          return /* Completed */0;
        }
      } else {
        return /* Completed */0;
      }
    });
}

function mapReverseImpl(f, _src, _dst) {
  while(true) {
    var dst = _dst;
    var src = _src;
    if (src) {
      _dst = /* :: */[
        Curry._1(f, src[0]),
        dst
      ];
      _src = src[1];
      continue ;
      
    } else {
      return dst;
    }
  };
}

function mapReverse(f, list) {
  return mapReverseImpl(f, list, /* [] */0);
}

function zip(seqs, _) {
  var iters = mapReverseImpl(Functions.call, seqs, /* [] */0);
  var nextSequence = function () {
    var partial_arg = mapReverseImpl((function (next) {
            if (next) {
              return next[1];
            } else {
              return emptySeq;
            }
          }), iters, /* [] */0);
    return (function (param) {
                return zip(partial_arg, param);
              })(/* () */0);
  };
  return Curry._2(Option.Operators[/* |? */2], ImmList.reduce(/* None */0, (function (acc, next) {
                    if (acc) {
                      var match = acc[0];
                      if (match) {
                        if (next) {
                          return Option.$$return(/* Next */[
                                      /* :: */[
                                        next[0],
                                        match[0]
                                      ],
                                      nextSequence
                                    ]);
                        } else {
                          return /* Some */[/* Completed */0];
                        }
                      } else {
                        return acc;
                      }
                    } else if (next) {
                      return Option.$$return(/* Next */[
                                  /* :: */[
                                    next[0],
                                    /* [] */0
                                  ],
                                  nextSequence
                                ]);
                    } else {
                      return /* Some */[/* Completed */0];
                    }
                  }), /* None */0, iters), /* Completed */0);
}

function zip2With(zipper, a, b, _) {
  var match = Curry._1(a, /* () */0);
  var match$1 = Curry._1(b, /* () */0);
  if (match) {
    if (match$1) {
      var bNext = match$1[1];
      var aNext = match[1];
      return /* Next */[
              Curry._2(zipper, match[0], match$1[0]),
              (function (param) {
                  return zip2With(zipper, aNext, bNext, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  } else {
    return /* Completed */0;
  }
}

function zip3With(zipper, a, b, c, _) {
  var match = Curry._1(a, /* () */0);
  var match$1 = Curry._1(b, /* () */0);
  var match$2 = Curry._1(c, /* () */0);
  if (match) {
    if (match$1) {
      if (match$2) {
        var cNext = match$2[1];
        var bNext = match$1[1];
        var aNext = match[1];
        return /* Next */[
                Curry._3(zipper, match[0], match$1[0], match$2[0]),
                (function (param) {
                    return zip3With(zipper, aNext, bNext, cNext, param);
                  })
              ];
      } else {
        return /* Completed */0;
      }
    } else {
      return /* Completed */0;
    }
  } else {
    return /* Completed */0;
  }
}

function reverseImpl(_src, _dst) {
  while(true) {
    var dst = _dst;
    var src = _src;
    if (src) {
      _dst = /* :: */[
        src[0],
        dst
      ];
      _src = src[1];
      continue ;
      
    } else {
      return dst;
    }
  };
}

function reverse(list) {
  return reverseImpl(list, /* [] */0);
}

function zipLongest(seqs) {
  var partial_arg = reverseImpl(mapReverseImpl((function (seq) {
              var seqs_000 = function (param) {
                return map(Option.$$return, seq, param);
              };
              var seqs_001 = /* :: */[
                (function (param) {
                    return generate(Functions.identity, /* None */0, param);
                  }),
                /* [] */0
              ];
              var seqs = /* :: */[
                seqs_000,
                seqs_001
              ];
              return flatten((function (param) {
                            return ofList(seqs, param);
                          }));
            }), seqs, /* [] */0), /* [] */0);
  var partial_arg$1 = function (param) {
    return zip(partial_arg, param);
  };
  return (function (param) {
      return takeWhile((function (param) {
                    return ImmList.some(Option.isNotEmpty, param);
                  }), partial_arg$1, param);
    });
}

function zipLongest2With(zipper, a, b, _) {
  var match = Curry._1(a, /* () */0);
  var match$1 = Curry._1(b, /* () */0);
  if (match) {
    var aNext = match[1];
    var aValue = match[0];
    if (match$1) {
      var bNext = match$1[1];
      return /* Next */[
              Curry._2(zipper, /* Some */[aValue], /* Some */[match$1[0]]),
              (function (param) {
                  return zipLongest2With(zipper, aNext, bNext, param);
                })
            ];
    } else {
      return /* Next */[
              Curry._2(zipper, /* Some */[aValue], /* None */0),
              (function (param) {
                  return zipLongest2With(zipper, aNext, emptySeq, param);
                })
            ];
    }
  } else if (match$1) {
    var bNext$1 = match$1[1];
    return /* Next */[
            Curry._2(zipper, /* None */0, /* Some */[match$1[0]]),
            (function (param) {
                return zipLongest2With(zipper, emptySeq, bNext$1, param);
              })
          ];
  } else {
    return /* Completed */0;
  }
}

function zipLongest3With(zipper, a, b, c, _) {
  var match = Curry._1(a, /* () */0);
  var match$1 = Curry._1(b, /* () */0);
  var match$2 = Curry._1(c, /* () */0);
  if (match) {
    var aNext = match[1];
    var aValue = match[0];
    if (match$1) {
      var bNext = match$1[1];
      var bValue = match$1[0];
      if (match$2) {
        var cNext = match$2[1];
        return /* Next */[
                Curry._3(zipper, /* Some */[aValue], /* Some */[bValue], /* Some */[match$2[0]]),
                (function (param) {
                    return zipLongest3With(zipper, aNext, bNext, cNext, param);
                  })
              ];
      } else {
        return /* Next */[
                Curry._3(zipper, /* Some */[aValue], /* Some */[bValue], /* None */0),
                (function (param) {
                    return zipLongest3With(zipper, aNext, bNext, emptySeq, param);
                  })
              ];
      }
    } else if (match$2) {
      var cNext$1 = match$2[1];
      return /* Next */[
              Curry._3(zipper, /* Some */[aValue], /* None */0, /* Some */[match$2[0]]),
              (function (param) {
                  return zipLongest3With(zipper, aNext, emptySeq, cNext$1, param);
                })
            ];
    } else {
      return /* Next */[
              Curry._3(zipper, /* Some */[aValue], /* None */0, /* None */0),
              (function (param) {
                  return zipLongest3With(zipper, aNext, emptySeq, emptySeq, param);
                })
            ];
    }
  } else if (match$1) {
    var bNext$1 = match$1[1];
    var bValue$1 = match$1[0];
    if (match$2) {
      var cNext$2 = match$2[1];
      return /* Next */[
              Curry._3(zipper, /* None */0, /* Some */[bValue$1], /* Some */[match$2[0]]),
              (function (param) {
                  return zipLongest3With(zipper, emptySeq, bNext$1, cNext$2, param);
                })
            ];
    } else {
      return /* Next */[
              Curry._3(zipper, /* None */0, /* Some */[bValue$1], /* None */0),
              (function (param) {
                  return zipLongest3With(zipper, emptySeq, bNext$1, emptySeq, param);
                })
            ];
    }
  } else if (match$2) {
    var cNext$3 = match$2[1];
    return /* Next */[
            Curry._3(zipper, /* None */0, /* None */0, /* Some */[match$2[0]]),
            (function (param) {
                return zipLongest3With(zipper, emptySeq, emptySeq, cNext$3, param);
              })
          ];
  } else {
    return /* Completed */0;
  }
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

exports.emptySeq                 = emptySeq;
exports.every                    = every;
exports.find                     = find;
exports.findOrRaise              = findOrRaise;
exports.forEach                  = forEach;
exports.none                     = none;
exports.reduce                   = reduce$1;
exports.some                     = some;
exports.toIterable               = toIterable;
exports.empty                    = empty;
exports.$$return                 = $$return;
exports.ofList                   = ofList;
exports.flatten                  = flatten;
exports.concat                   = concat;
exports.defer                    = defer;
exports.filter                   = filter;
exports.first                    = first;
exports.firstOrRaise             = firstOrRaise;
exports.generate                 = generate;
exports.map                      = map;
exports.doOnNext                 = doOnNext;
exports.flatMap                  = flatMap;
exports.ofOption                 = ofOption;
exports.scan                     = scan;
exports.distinctUntilChangedWith = distinctUntilChangedWith;
exports.seek                     = seek;
exports.seekWhile                = seekWhile;
exports.skip                     = skip;
exports.skipWhile                = skipWhile;
exports.startWith                = startWith;
exports.takeWhile                = takeWhile;
exports.take                     = take;
exports.mapReverseImpl           = mapReverseImpl;
exports.mapReverse               = mapReverse;
exports.zip                      = zip;
exports.zip2With                 = zip2With;
exports.zip3With                 = zip3With;
exports.reverseImpl              = reverseImpl;
exports.reverse                  = reverse;
exports.zipLongest               = zipLongest;
exports.zipLongest2With          = zipLongest2With;
exports.zipLongest3With          = zipLongest3With;
/* include Not a pure module */


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var Option        = __webpack_require__(61);
var ImmList       = __webpack_require__(64);
var Functions     = __webpack_require__(55);
var MutableOption = __webpack_require__(81);

function everyPredicate(acc, _) {
  return acc;
}

function findPredicate(acc, _) {
  return Option.isEmpty(acc);
}

function somePredicate(acc, _) {
  return 1 - acc;
}

function Make(Base) {
  var isEmpty = Base[0];
  var reduce = Base[1];
  var every = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], everyPredicate, (function () {
                  return f;
                }), /* true */1, iterable);
  };
  var find = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], findPredicate, (function (_, next) {
                  if (Curry._1(f, next)) {
                    return /* Some */[next];
                  } else {
                    return /* None */0;
                  }
                }), /* None */0, iterable);
  };
  var findOrRaise = function (f, iterable) {
    return Option.firstOrRaise(find(f, iterable));
  };
  var forEach = function ($staropt$star, f, iterable) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue;
    if (predicate === Functions.alwaysTrue) {
      return Curry._4(Base[/* reduce */1], Functions.alwaysTrue2, (function () {
                    return f;
                  }), /* () */0, iterable);
    } else {
      return Curry._4(reduce, (function () {
                    return predicate;
                  }), (function () {
                    return f;
                  }), /* () */0, iterable);
    }
  };
  var none = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], everyPredicate, (function () {
                  return Curry._2(Functions.Operators[/* >> */0], f, (function (prim) {
                                return 1 - prim;
                              }));
                }), /* true */1, iterable);
  };
  var reduce$1 = function ($staropt$star, f, acc, iterable) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduce, predicate, f, acc, iterable);
  };
  var some = function (f, iterable) {
    return reduce$1(/* Some */[somePredicate], (function () {
                  return f;
                }), /* false */0, iterable);
  };
  var iterableBase = /* record */[/* reduce */Base[/* reduce */1]];
  var toIterable = function (iterable) {
    if (Curry._1(isEmpty, iterable)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              iterable,
              iterableBase
            ];
    }
  };
  return /* module */[
          /* every */every,
          /* find */find,
          /* findOrRaise */findOrRaise,
          /* forEach */forEach,
          /* none */none,
          /* reduce */reduce$1,
          /* some */some,
          /* toIterable */toIterable
        ];
}

function Make1(Base) {
  var isEmpty = Base[0];
  var reduce = Base[1];
  var every = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], everyPredicate, (function () {
                  return f;
                }), /* true */1, iterable);
  };
  var find = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], findPredicate, (function (_, next) {
                  if (Curry._1(f, next)) {
                    return /* Some */[next];
                  } else {
                    return /* None */0;
                  }
                }), /* None */0, iterable);
  };
  var findOrRaise = function (f, iterable) {
    return Option.firstOrRaise(find(f, iterable));
  };
  var forEach = function ($staropt$star, f, iterable) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue;
    if (predicate === Functions.alwaysTrue) {
      return Curry._4(Base[/* reduce */1], Functions.alwaysTrue2, (function () {
                    return f;
                  }), /* () */0, iterable);
    } else {
      return Curry._4(reduce, (function () {
                    return predicate;
                  }), (function () {
                    return f;
                  }), /* () */0, iterable);
    }
  };
  var none = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], everyPredicate, (function () {
                  return Curry._2(Functions.Operators[/* >> */0], f, (function (prim) {
                                return 1 - prim;
                              }));
                }), /* true */1, iterable);
  };
  var reduce$1 = function ($staropt$star, f, acc, iterable) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduce, predicate, f, acc, iterable);
  };
  var some = function (f, iterable) {
    return Curry._4(Base[/* reduce */1], somePredicate, (function () {
                  return f;
                }), /* false */0, iterable);
  };
  var iterableBase = /* record */[/* reduce */Base[/* reduce */1]];
  var toIterable = function (iterable) {
    if (Curry._1(isEmpty, iterable)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              iterable,
              iterableBase
            ];
    }
  };
  return /* module */[
          /* every */every,
          /* find */find,
          /* findOrRaise */findOrRaise,
          /* forEach */forEach,
          /* none */none,
          /* reduce */reduce$1,
          /* some */some,
          /* toIterable */toIterable
        ];
}

function reduce(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[1][/* reduce */0], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

function every(f, iterable) {
  return reduce(everyPredicate, (function () {
                return f;
              }), /* true */1, iterable);
}

function find(f, iterable) {
  return reduce(findPredicate, (function (_, next) {
                if (Curry._1(f, next)) {
                  return /* Some */[next];
                } else {
                  return /* None */0;
                }
              }), /* None */0, iterable);
}

function findOrRaise(f, iterable) {
  return Option.firstOrRaise(find(f, iterable));
}

function forEach($staropt$star, f, iterable) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue;
  if (predicate === Functions.alwaysTrue) {
    return reduce(Functions.alwaysTrue2, (function () {
                  return f;
                }), /* () */0, iterable);
  } else {
    return reduce((function () {
                  return predicate;
                }), (function () {
                  return f;
                }), /* () */0, iterable);
  }
}

function none(f, iterable) {
  return reduce(everyPredicate, (function () {
                return Curry._2(Functions.Operators[/* >> */0], f, (function (prim) {
                              return 1 - prim;
                            }));
              }), /* true */1, iterable);
}

function reduce$1($staropt$star, f, acc, iterable) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
  return reduce(predicate, f, acc, iterable);
}

function some(f, iterable) {
  return reduce(somePredicate, (function () {
                return f;
              }), /* false */0, iterable);
}

var concatImpl = /* record */[/* reduce */(function (predicate, f, acc, iters) {
      var shouldContinue = [/* true */1];
      var predicate$1 = function (acc, next) {
        var result = Curry._2(predicate, acc, next);
        shouldContinue[0] = result;
        return result;
      };
      return ImmList.reduce(/* Some */[(function (_, _$1) {
                      return shouldContinue[0];
                    })], (function (acc, next) {
                    return reduce$1(/* Some */[predicate$1], f, acc, next);
                  }), acc, iters);
    })];

function concat(iters) {
  if (iters) {
    return /* Instance */[
            iters,
            concatImpl
          ];
  } else {
    return /* Empty */0;
  }
}

var deferImpl = /* record */[/* reduce */(function (predicate, f, acc, provider) {
      return reduce$1(/* Some */[predicate], f, acc, Curry._1(provider, /* () */0));
    })];

function defer(provider) {
  return /* Instance */[
          provider,
          deferImpl
        ];
}

function distinctUntilChangedWith(equals, iterable) {
  if (iterable) {
    var reduce = iterable[1][/* reduce */0];
    return /* Instance */[
            iterable[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var previous = MutableOption.empty(/* () */0);
                  var shouldNotSkip = function (next) {
                    if (MutableOption.isEmpty(previous)) {
                      return /* true */1;
                    } else {
                      return 1 - Curry._2(equals, next, MutableOption.firstOrRaise(previous));
                    }
                  };
                  var predicate$1 = function (acc, next) {
                    if (shouldNotSkip(next)) {
                      return Curry._2(predicate, acc, next);
                    } else {
                      return /* true */1;
                    }
                  };
                  var f$1 = function (acc, next) {
                    if (shouldNotSkip(next)) {
                      MutableOption.set(next, previous);
                      return Curry._2(f, acc, next);
                    } else {
                      return acc;
                    }
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function doOnNext(sideEffect, iterable) {
  if (iterable) {
    var reduce = iterable[1][/* reduce */0];
    return /* Instance */[
            iterable[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  return Curry._4(reduce, predicate, (function (acc, next) {
                                Curry._1(sideEffect, next);
                                return Curry._2(f, acc, next);
                              }), acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function empty() {
  return /* Empty */0;
}

function filter(filter$1, iterable) {
  if (iterable) {
    var reduce = iterable[1][/* reduce */0];
    return /* Instance */[
            iterable[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var predicate$1 = function (acc, next) {
                    if (Curry._1(filter$1, next)) {
                      return Curry._2(predicate, acc, next);
                    } else {
                      return /* true */1;
                    }
                  };
                  return Curry._4(reduce, predicate$1, (function (acc, next) {
                                if (Curry._1(filter$1, next)) {
                                  return Curry._2(f, acc, next);
                                } else {
                                  return acc;
                                }
                              }), acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

var flattenImpl = /* record */[/* reduce */(function (predicate, f, acc, iters) {
      var shouldContinue = [/* true */1];
      var predicate$1 = function (acc, next) {
        var result = Curry._2(predicate, acc, next);
        shouldContinue[0] = result;
        return result;
      };
      return reduce$1(/* Some */[(function (_, _$1) {
                      return shouldContinue[0];
                    })], (function (acc, next) {
                    return reduce$1(/* Some */[predicate$1], f, acc, next);
                  }), acc, iters);
    })];

function flatten(iters) {
  if (iters) {
    return /* Instance */[
            iters,
            flattenImpl
          ];
  } else {
    return /* Empty */0;
  }
}

var generateImpl = /* record */[/* reduce */(function (predicate, f, acc, param) {
      var initialValue = param[1];
      if (Curry._2(predicate, acc, initialValue)) {
        var acc$1 = Curry._2(f, acc, initialValue);
        var gen = param[0];
        var _value = initialValue;
        var predicate$1 = predicate;
        var f$1 = f;
        var _acc = acc$1;
        while(true) {
          var acc$2 = _acc;
          var value = _value;
          var nextValue = Curry._1(gen, value);
          if (Curry._2(predicate$1, acc$2, nextValue)) {
            var acc$3 = Curry._2(f$1, acc$2, nextValue);
            _acc = acc$3;
            _value = nextValue;
            continue ;
            
          } else {
            return acc$2;
          }
        };
      } else {
        return acc;
      }
    })];

function generate(gen, initialValue) {
  return /* Instance */[
          /* tuple */[
            gen,
            initialValue
          ],
          generateImpl
        ];
}

function listAddFirstAll(iter, list) {
  return reduce$1(/* None */0, (function (acc, next) {
                return ImmList.addFirst(next, acc);
              }), list, iter);
}

function listFromReverse(iter) {
  return listAddFirstAll(iter, /* [] */0);
}

function map(mapper, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var memoize = MutableOption.empty(/* () */0);
                  var predicate$1 = function (acc, next) {
                    var next$1 = Curry._1(mapper, next);
                    MutableOption.set(next$1, memoize);
                    return Curry._2(predicate, acc, next$1);
                  };
                  var f$1 = function (acc, _) {
                    return Curry._2(f, acc, MutableOption.firstOrRaise(memoize));
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function flatMap(mapper, iter) {
  return flatten(map(mapper, iter));
}

var listImpl = /* record */[/* reduce */ImmList.reduceImpl];

function ofList(list) {
  if (list) {
    return /* Instance */[
            list,
            listImpl
          ];
  } else {
    return /* Empty */0;
  }
}

var returnImpl = /* record */[/* reduce */(function (predicate, f, acc, value) {
      if (Curry._2(predicate, acc, value)) {
        return Curry._2(f, acc, value);
      } else {
        return acc;
      }
    })];

function $$return(value) {
  return /* Instance */[
          value,
          returnImpl
        ];
}

function scan(reducer, initialValue, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  if (Curry._2(predicate, acc, initialValue)) {
                    var result = [Curry._2(f, acc, initialValue)];
                    var memoized = [initialValue];
                    var predicate$1 = function (acc, next) {
                      var nextValue = Curry._2(reducer, acc, next);
                      memoized[0] = nextValue;
                      return Curry._2(predicate, result[0], nextValue);
                    };
                    var f$1 = function (_, _$1) {
                      var acc = memoized[0];
                      result[0] = Curry._2(f, result[0], acc);
                      return acc;
                    };
                    Curry._4(reduce, predicate$1, f$1, initialValue, iter);
                    return result[0];
                  } else {
                    return acc;
                  }
                })]
          ];
  } else {
    return /* Instance */[
            initialValue,
            returnImpl
          ];
  }
}

function skip(count, iter) {
  if (count) {
    if (iter) {
      var reduce = iter[1][/* reduce */0];
      return /* Instance */[
              iter[0],
              /* record */[/* reduce */(function (predicate, f, acc, iter) {
                    var count$1 = [count];
                    var predicate$1 = function (acc, next) {
                      if (count$1[0] > 0) {
                        return /* true */1;
                      } else {
                        return Curry._2(predicate, acc, next);
                      }
                    };
                    var f$1 = function (acc, next) {
                      count$1[0] = count$1[0] - 1 | 0;
                      if (count$1[0] >= 0) {
                        return acc;
                      } else {
                        return Curry._2(f, acc, next);
                      }
                    };
                    return Curry._4(reduce, predicate$1, f$1, acc, iter);
                  })]
            ];
    } else {
      return /* Empty */0;
    }
  } else {
    return iter;
  }
}

function skipWhile(keepSkipping, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var doneSkipping = [/* false */0];
                  var predicate$1 = function (acc, next) {
                    if (doneSkipping[0]) {
                      return Curry._2(predicate, acc, next);
                    } else {
                      return /* true */1;
                    }
                  };
                  var f$1 = function (acc, next) {
                    if (doneSkipping[0]) {
                      return Curry._2(f, acc, next);
                    } else if (Curry._1(keepSkipping, next)) {
                      return acc;
                    } else {
                      doneSkipping[0] = /* true */1;
                      return Curry._2(f, acc, next);
                    }
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function startWith(value, iter) {
  return concat(/* :: */[
              /* Instance */[
                value,
                returnImpl
              ],
              /* :: */[
                iter,
                /* [] */0
              ]
            ]);
}

function take(count, iter) {
  if (count) {
    if (iter) {
      var reduce = iter[1][/* reduce */0];
      return /* Instance */[
              iter[0],
              /* record */[/* reduce */(function (predicate, f, acc, iter) {
                    var count$1 = [count];
                    var predicate$1 = function (acc, next) {
                      if (count$1[0] > 0) {
                        return Curry._2(predicate, acc, next);
                      } else {
                        return /* false */0;
                      }
                    };
                    var f$1 = function (acc, next) {
                      count$1[0] = count$1[0] - 1 | 0;
                      return Curry._2(f, acc, next);
                    };
                    return Curry._4(reduce, predicate$1, f$1, acc, iter);
                  })]
            ];
    } else {
      return /* Empty */0;
    }
  } else {
    return /* Empty */0;
  }
}

function takeWhile(keepTaking, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var predicate$1 = function (acc, next) {
                    if (Curry._1(keepTaking, next)) {
                      return Curry._2(predicate, acc, next);
                    } else {
                      return /* false */0;
                    }
                  };
                  return Curry._4(reduce, predicate$1, f, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function toIterable(iter) {
  return iter;
}

var nonePredicate = everyPredicate;

exports.everyPredicate           = everyPredicate;
exports.findPredicate            = findPredicate;
exports.nonePredicate            = nonePredicate;
exports.somePredicate            = somePredicate;
exports.Make                     = Make;
exports.Make1                    = Make1;
exports.every                    = every;
exports.find                     = find;
exports.findOrRaise              = findOrRaise;
exports.forEach                  = forEach;
exports.none                     = none;
exports.reduce                   = reduce$1;
exports.some                     = some;
exports.concatImpl               = concatImpl;
exports.concat                   = concat;
exports.deferImpl                = deferImpl;
exports.defer                    = defer;
exports.distinctUntilChangedWith = distinctUntilChangedWith;
exports.doOnNext                 = doOnNext;
exports.empty                    = empty;
exports.filter                   = filter;
exports.flattenImpl              = flattenImpl;
exports.flatten                  = flatten;
exports.generateImpl             = generateImpl;
exports.generate                 = generate;
exports.listAddFirstAll          = listAddFirstAll;
exports.listFromReverse          = listFromReverse;
exports.map                      = map;
exports.flatMap                  = flatMap;
exports.listImpl                 = listImpl;
exports.ofList                   = ofList;
exports.returnImpl               = returnImpl;
exports.$$return                 = $$return;
exports.scan                     = scan;
exports.skip                     = skip;
exports.skipWhile                = skipWhile;
exports.startWith                = startWith;
exports.take                     = take;
exports.takeWhile                = takeWhile;
exports.toIterable               = toIterable;
/* No side effect */


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Pervasives = __webpack_require__(2);

function create() {
  return [/* Owner */0];
}

var none = [/* Owner */0];

var Owner = /* module */[
  /* create */create,
  /* none */none
];

function create$1(value) {
  return /* record */[
          /* owner */[/* Owner */0],
          /* editable : true */1,
          /* value */value
        ];
}

function ensureEditable($$transient) {
  var editable = $$transient[/* editable */1];
  if (editable) {
    return $$transient;
  } else {
    return Pervasives.failwith("Transient has already been persisted");
  }
}

function get($$transient) {
  return ensureEditable($$transient)[/* value */2];
}

function persist($$transient) {
  var $$transient$1 = ensureEditable($$transient);
  $$transient$1[/* editable */1] = /* false */0;
  return $$transient$1[/* value */2];
}

function update(f, $$transient) {
  var $$transient$1 = ensureEditable($$transient);
  $$transient$1[/* value */2] = Curry._2(f, $$transient$1[/* owner */0], $$transient$1[/* value */2]);
  return $$transient$1;
}

function update1(f, arg, $$transient) {
  var $$transient$1 = ensureEditable($$transient);
  $$transient$1[/* value */2] = Curry._3(f, $$transient$1[/* owner */0], arg, $$transient$1[/* value */2]);
  return $$transient$1;
}

function update2(f, arg1, arg2, $$transient) {
  var $$transient$1 = ensureEditable($$transient);
  $$transient$1[/* value */2] = Curry._4(f, $$transient$1[/* owner */0], arg1, arg2, $$transient$1[/* value */2]);
  return $$transient$1;
}

exports.Owner          = Owner;
exports.create         = create$1;
exports.ensureEditable = ensureEditable;
exports.get            = get;
exports.persist        = persist;
exports.update         = update;
exports.update1        = update1;
exports.update2        = update2;
/* No side effect */


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Iterable   = __webpack_require__(57);
var Sequence   = __webpack_require__(56);
var Functions  = __webpack_require__(55);
var Collection = __webpack_require__(69);

function Make(Base) {
  var contains = Base[0];
  var include = Collection.Make([
        Base[1],
        Base[2],
        Base[3]
      ]);
  var reduce = include[5];
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var setBase_002 = /* reduce */Base[/* reduce */2];
  var setBase = /* record */[
    /* contains */contains,
    /* count */count,
    setBase_002,
    /* toSequence */toSequence
  ];
  var equals = function ($$this, that) {
    if ($$this === that) {
      return /* true */1;
    } else if (Curry._1(count, $$this) !== Curry._1(count, that)) {
      return /* false */0;
    } else {
      return Curry._4(reduce, /* Some */[(function (acc, _) {
                      return acc;
                    })], (function () {
                    return (function (param) {
                        return Functions.flip(contains, that, param);
                      });
                  }), /* true */1, $$this);
    }
  };
  var toSet = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              setBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */reduce,
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* equals */equals,
          /* contains */contains,
          /* toSet */toSet
        ];
}

function Make1(Base) {
  var contains = Base[0];
  var include = Collection.Make1([
        Base[1],
        Base[2],
        Base[3]
      ]);
  var reduce = include[5];
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var setBase_002 = /* reduce */Base[/* reduce */2];
  var setBase = /* record */[
    /* contains */contains,
    /* count */count,
    setBase_002,
    /* toSequence */toSequence
  ];
  var equals = function ($$this, that) {
    if ($$this === that) {
      return /* true */1;
    } else if (Curry._1(count, $$this) !== Curry._1(count, that)) {
      return /* false */0;
    } else {
      return Curry._4(reduce, /* Some */[(function (acc, _) {
                      return acc;
                    })], (function () {
                    return (function (param) {
                        return Functions.flip(contains, that, param);
                      });
                  }), /* true */1, $$this);
    }
  };
  var toSet = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              setBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */reduce,
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* contains */contains,
          /* equals */equals,
          /* toSet */toSet
        ];
}

function contains(value, set) {
  if (set) {
    return Curry._2(set[1][/* contains */0], value, set[0]);
  } else {
    return /* false */0;
  }
}

function count(set) {
  if (set) {
    return Curry._1(set[1][/* count */1], set[0]);
  } else {
    return 0;
  }
}

function reduce(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[1][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function toSequence(set) {
  if (set) {
    return Curry._1(set[1][/* toSequence */3], set[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include = Collection.Make1([
      count,
      reduce,
      toSequence
    ]);

var reduce$1 = include[5];

var toIterable = include[7];

var count$1 = include[8];

function equals($$this, that) {
  if ($$this === that) {
    return /* true */1;
  } else if (Curry._1(count$1, $$this) !== Curry._1(count$1, that)) {
    return /* false */0;
  } else {
    return Curry._4(reduce$1, /* Some */[(function (acc, _) {
                    return acc;
                  })], (function () {
                  return (function (param) {
                      return Functions.flip(contains, that, param);
                    });
                }), /* true */1, $$this);
  }
}

function empty() {
  return /* Empty */0;
}

function intersect($$this, that) {
  return Iterable.filter((function (param) {
                return Functions.flip(contains, that, param);
              }), Curry._1(toIterable, $$this));
}

function subtract($$this, that) {
  return Iterable.filter(Curry._2(Functions.Operators[/* >> */0], (function (param) {
                    return Functions.flip(contains, that, param);
                  }), (function (prim) {
                    return 1 - prim;
                  })), Curry._1(toIterable, $$this));
}

function toSet(set) {
  return set;
}

function union($$this, that) {
  return Iterable.concat(/* :: */[
              Curry._1(toIterable, $$this),
              /* :: */[
                subtract(that, $$this),
                /* [] */0
              ]
            ]);
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var some = include[6];

var isEmpty = include[9];

var isNotEmpty = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

exports.Make         = Make;
exports.Make1        = Make1;
exports.every        = every;
exports.find         = find;
exports.findOrRaise  = findOrRaise;
exports.forEach      = forEach;
exports.none         = none;
exports.reduce       = reduce$1;
exports.some         = some;
exports.toIterable   = toIterable;
exports.count        = count$1;
exports.isEmpty      = isEmpty;
exports.isNotEmpty   = isNotEmpty;
exports.toCollection = toCollection;
exports.toSequence   = toSequence$1;
exports.contains     = contains;
exports.equals       = equals;
exports.empty        = empty;
exports.intersect    = intersect;
exports.subtract     = subtract;
exports.toSet        = toSet;
exports.union        = union;
/* include Not a pure module */


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var $$Array       = __webpack_require__(24);
var Curry         = __webpack_require__(1);
var Indexed       = __webpack_require__(76);
var Caml_array    = __webpack_require__(7);
var Pervasives    = __webpack_require__(2);
var Preconditions = __webpack_require__(63);

function count(arr) {
  return arr.length;
}

function getOrRaise(index, arr) {
  return Caml_array.caml_array_get(arr, index);
}

function reduce(predicate, f, acc, arr) {
  var arrCount = arr.length;
  var _acc = acc;
  var _index = 0;
  while(true) {
    var index = _index;
    var acc$1 = _acc;
    if (index < arrCount) {
      var next = Caml_array.caml_array_get(arr, index);
      if (Curry._2(predicate, acc$1, next)) {
        var acc$2 = Curry._2(f, acc$1, Caml_array.caml_array_get(arr, index));
        _index = index + 1 | 0;
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      return acc$1;
    }
  };
}

function reduceReversed(predicate, f, acc, arr) {
  var arrCount = arr.length;
  var _acc = acc;
  var _index = arrCount - 1 | 0;
  while(true) {
    var index = _index;
    var acc$1 = _acc;
    if (index >= 0) {
      var next = Caml_array.caml_array_get(arr, index);
      if (Curry._2(predicate, acc$1, next)) {
        var acc$2 = Curry._2(f, acc$1, Caml_array.caml_array_get(arr, index));
        _index = index - 1 | 0;
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      return acc$1;
    }
  };
}

function toSequence(arr) {
  var arrCount = arr.length;
  var loop = function (index, _) {
    if (index < arrCount) {
      var partial_arg = index + 1 | 0;
      return /* Next */[
              Caml_array.caml_array_get(arr, index),
              (function (param) {
                  return loop(partial_arg, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  };
  return (function (param) {
      return loop(0, param);
    });
}

function toSequenceReversed(arr) {
  var loop = function (index, _) {
    if (index < 0) {
      return /* Completed */0;
    } else {
      var partial_arg = index - 1 | 0;
      return /* Next */[
              Caml_array.caml_array_get(arr, index),
              (function (param) {
                  return loop(partial_arg, param);
                })
            ];
    }
  };
  var partial_arg = arr.length - 1 | 0;
  return (function (param) {
      return loop(partial_arg, param);
    });
}

var include = Indexed.Make1(/* module */[
      /* count */count,
      /* getOrRaise */getOrRaise,
      /* reduce */reduce,
      /* reduceReversed */reduceReversed,
      /* toSequence */toSequence,
      /* toSequenceReversed */toSequenceReversed
    ]);

var count$1 = include[8];

function lastIndexOrRaise(arr) {
  var lastIndex = Curry._1(count$1, arr) - 1 | 0;
  if (lastIndex >= 0) {
    return lastIndex;
  } else {
    return Pervasives.failwith("empty");
  }
}

function addFirst(item, arr) {
  var count$2 = Curry._1(count$1, arr);
  var retval = Caml_array.caml_make_vect(count$2 + 1 | 0, item);
  $$Array.blit(arr, 0, retval, 1, count$2);
  return retval;
}

function addLast(item, arr) {
  var count$2 = Curry._1(count$1, arr);
  var retval = Caml_array.caml_make_vect(count$2 + 1 | 0, item);
  $$Array.blit(arr, 0, retval, 0, count$2);
  return retval;
}

function empty() {
  return /* array */[];
}

function insertAt(index, item, arr) {
  var count$2 = Curry._1(count$1, arr);
  Preconditions.failIfOutOfRange(count$2 + 1 | 0, index);
  var retval = Caml_array.caml_make_vect(count$2 + 1 | 0, item);
  $$Array.blit(arr, 0, retval, 0, index);
  $$Array.blit(arr, index, retval, index + 1 | 0, count$2 - index | 0);
  return retval;
}

function ofUnsafe(arr) {
  return arr;
}

function removeLastOrRaise(arr) {
  var count$2 = Curry._1(count$1, arr);
  if (count$2) {
    if (count$2 === 1) {
      return /* array */[];
    } else {
      return $$Array.sub(arr, 0, count$2 - 1 | 0);
    }
  } else {
    return Pervasives.failwith("Array is empty");
  }
}

function removeAt(index, arr) {
  var count$2 = Curry._1(count$1, arr);
  Preconditions.failIfOutOfRange(count$2, index);
  var newLength = count$2 - 1 | 0;
  var anyItem = Caml_array.caml_array_get(arr, 0);
  var retval = Caml_array.caml_make_vect(newLength, anyItem);
  $$Array.blit(arr, 0, retval, 0, index);
  $$Array.blit(arr, index + 1 | 0, retval, index, newLength - index | 0);
  return retval;
}

function removeFirstOrRaise(arr) {
  return removeAt(0, arr);
}

function skip(startIndex, arr) {
  var arrCount = Curry._1(count$1, arr);
  if (startIndex < 0) {
    return Pervasives.failwith("startIndex is < 0");
  } else if (startIndex >= arrCount) {
    return /* array */[];
  } else {
    var newCount = arrCount - startIndex | 0;
    return $$Array.sub(arr, startIndex, newCount);
  }
}

function take(newCount, arr) {
  if (newCount < 0) {
    return Pervasives.failwith("count is < 0");
  } else if (newCount) {
    return $$Array.sub(arr, 0, newCount);
  } else {
    return /* array */[];
  }
}

function update(index, item, arr) {
  var arrCount = Curry._1(count$1, arr);
  Preconditions.failIfOutOfRange(arrCount, index);
  var clone = $$Array.copy(arr);
  Caml_array.caml_array_set(clone, index, item);
  return clone;
}

function updateWith(index, f, arr) {
  var count$2 = Curry._1(count$1, arr);
  Preconditions.failIfOutOfRange(count$2, index);
  var clone = $$Array.copy(arr);
  Caml_array.caml_array_set(clone, index, Curry._1(f, Caml_array.caml_array_get(arr, index)));
  return clone;
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var isEmpty = include[9];

var isNotEmpty = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

var first = include[13];

var firstOrRaise = include[14];

var toSequentialCollection = include[15];

var last = include[16];

var lastOrRaise = include[17];

var reduceReversed$1 = include[18];

var toCollectionReversed = include[19];

var toIterableReversed = include[20];

var toNavigableCollection = include[21];

var toNavigableCollectionReversed = include[22];

var toSequenceReversed$1 = include[23];

var toSequentialCollectionReversed = include[24];

var get = include[25];

var getOrDefault = include[26];

var getOrRaise$1 = include[27];

var toIndexed = include[28];

var toIndexedReversed = include[29];

var toKeyedCollection = include[30];

var toKeyedCollectionReversed = include[31];

var toKeyedIterable = include[32];

var toKeyedIterableReversed = include[33];

var toMap = include[34];

var toMapReversed = include[35];

var toNavigableKeyedCollection = include[36];

var toNavigableKeyedCollectionReversed = include[37];

var toNavigableMap = include[38];

var toNavigableMapReversed = include[39];

var init = $$Array.init;

exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.none                               = none;
exports.reduce                             = reduce$1;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.count                              = count$1;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.toCollection                       = toCollection;
exports.toSequence                         = toSequence$1;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise;
exports.toSequentialCollection             = toSequentialCollection;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise;
exports.reduceReversed                     = reduceReversed$1;
exports.toCollectionReversed               = toCollectionReversed;
exports.toIterableReversed                 = toIterableReversed;
exports.toNavigableCollection              = toNavigableCollection;
exports.toNavigableCollectionReversed      = toNavigableCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed$1;
exports.toSequentialCollectionReversed     = toSequentialCollectionReversed;
exports.get                                = get;
exports.getOrDefault                       = getOrDefault;
exports.getOrRaise                         = getOrRaise$1;
exports.toIndexed                          = toIndexed;
exports.toIndexedReversed                  = toIndexedReversed;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterable                    = toKeyedIterable;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toMap                              = toMap;
exports.toMapReversed                      = toMapReversed;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toNavigableMap                     = toNavigableMap;
exports.toNavigableMapReversed             = toNavigableMapReversed;
exports.lastIndexOrRaise                   = lastIndexOrRaise;
exports.addFirst                           = addFirst;
exports.addLast                            = addLast;
exports.empty                              = empty;
exports.init                               = init;
exports.insertAt                           = insertAt;
exports.ofUnsafe                           = ofUnsafe;
exports.removeLastOrRaise                  = removeLastOrRaise;
exports.removeAt                           = removeAt;
exports.removeFirstOrRaise                 = removeFirstOrRaise;
exports.skip                               = skip;
exports.take                               = take;
exports.update                             = update;
exports.updateWith                         = updateWith;
/* include Not a pure module */


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Pervasives = __webpack_require__(2);

function firstOrRaise(opt) {
  if (opt) {
    return opt[0];
  } else {
    return Pervasives.failwith("option is none");
  }
}

function flatMap(f, opt) {
  if (opt) {
    return Curry._1(f, opt[0]);
  } else {
    return /* None */0;
  }
}

function isEmpty(opt) {
  if (opt) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isNotEmpty(opt) {
  if (opt) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function map(f, opt) {
  if (opt) {
    return /* Some */[Curry._1(f, opt[0])];
  } else {
    return /* None */0;
  }
}

function orDefault(defaultValue, opt) {
  if (opt) {
    return opt[0];
  } else {
    return defaultValue;
  }
}

function $$return(a) {
  return /* Some */[a];
}

function $great$great$eq(opt, f) {
  return flatMap(f, opt);
}

function $great$great$pipe(opt, f) {
  return map(f, opt);
}

function $pipe$unknown(opt, defaultValue) {
  return orDefault(defaultValue, opt);
}

var Operators = /* module */[
  /* >>= */$great$great$eq,
  /* >>| */$great$great$pipe,
  /* |? */$pipe$unknown
];

exports.firstOrRaise = firstOrRaise;
exports.flatMap      = flatMap;
exports.isEmpty      = isEmpty;
exports.isNotEmpty   = isNotEmpty;
exports.map          = map;
exports.orDefault    = orDefault;
exports.$$return     = $$return;
exports.Operators    = Operators;
/* No side effect */


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry     = __webpack_require__(1);
var Functions = __webpack_require__(55);

function Make1(Base) {
  var reduce = Base[0];
  var reduceKeys = function (predicate, reducer, acc, iter) {
    var reducer$1 = function (acc, k, _) {
      return Curry._2(reducer, acc, k);
    };
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(reduce, Functions.alwaysTrue3, reducer$1, acc, iter);
    } else {
      var predicate$1 = function (acc, k, _) {
        return Curry._2(predicate, acc, k);
      };
      return Curry._4(reduce, predicate$1, reducer$1, acc, iter);
    }
  };
  var reduceValues = function (predicate, reducer, acc, iter) {
    var reducer$1 = function (acc, _, v) {
      return Curry._2(reducer, acc, v);
    };
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(reduce, Functions.alwaysTrue3, reducer$1, acc, iter);
    } else {
      var predicate$1 = function (acc, _, v) {
        return Curry._2(predicate, acc, v);
      };
      return Curry._4(reduce, predicate$1, reducer$1, acc, iter);
    }
  };
  return /* module */[
          /* reduce */reduce,
          /* reduceKeys */reduceKeys,
          /* reduceValues */reduceValues
        ];
}

function Make2(Base) {
  var reduce = Base[0];
  var reduceKeys = function (predicate, reducer, acc, iter) {
    var reducer$1 = function (acc, k, _) {
      return Curry._2(reducer, acc, k);
    };
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(reduce, Functions.alwaysTrue3, reducer$1, acc, iter);
    } else {
      var predicate$1 = function (acc, k, _) {
        return Curry._2(predicate, acc, k);
      };
      return Curry._4(reduce, predicate$1, reducer$1, acc, iter);
    }
  };
  var reduceValues = function (predicate, reducer, acc, iter) {
    var reducer$1 = function (acc, _, v) {
      return Curry._2(reducer, acc, v);
    };
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(reduce, Functions.alwaysTrue3, reducer$1, acc, iter);
    } else {
      var predicate$1 = function (acc, _, v) {
        return Curry._2(predicate, acc, v);
      };
      return Curry._4(reduce, predicate$1, reducer$1, acc, iter);
    }
  };
  return /* module */[
          /* reduce */reduce,
          /* reduceKeys */reduceKeys,
          /* reduceValues */reduceValues
        ];
}

exports.Make1 = Make1;
exports.Make2 = Make2;
/* No side effect */


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Option     = __webpack_require__(61);
var Pervasives = __webpack_require__(2);

function failEmpty() {
  return Pervasives.failwith("empty");
}

function failIf(msg, condition) {
  if (condition) {
    return Pervasives.failwith(msg);
  } else {
    return /* () */0;
  }
}

function failIfOutOfRange(count, index) {
  if (index < 0) {
    return Pervasives.failwith("Index must be greater than 0");
  } else if (index >= count) {
    return Pervasives.failwith("Index must be less than count");
  } else {
    return /* () */0;
  }
}

function noneIfIndexOutOfRange(count, index, f) {
  if (index < 0 || index >= count) {
    return /* None */0;
  } else {
    return Option.$$return(Curry._1(f, index));
  }
}

exports.failEmpty             = failEmpty;
exports.failIf                = failIf;
exports.failIfOutOfRange      = failIfOutOfRange;
exports.noneIfIndexOutOfRange = noneIfIndexOutOfRange;
/* No side effect */


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Functions  = __webpack_require__(55);
var Pervasives = __webpack_require__(2);

function addFirst(value, list) {
  return /* :: */[
          value,
          list
        ];
}

function countImpl(_list, _count) {
  while(true) {
    var count = _count;
    var list = _list;
    if (list) {
      _count = count + 1 | 0;
      _list = list[1];
      continue ;
      
    } else {
      return count;
    }
  };
}

function count(list) {
  return countImpl(list, 0);
}

function empty() {
  return /* [] */0;
}

function isEmpty(list) {
  if (list) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isNotEmpty(list) {
  if (list) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function findOrRaise(f, _list) {
  while(true) {
    var list = _list;
    if (list) {
      var head = list[0];
      if (Curry._1(f, head)) {
        return head;
      } else {
        _list = list[1];
        continue ;
        
      }
    } else {
      return Pervasives.failwith("not found");
    }
  };
}

function first(list) {
  if (list) {
    return /* Some */[list[0]];
  } else {
    return /* None */0;
  }
}

function firstOrRaise(list) {
  if (list) {
    return list[0];
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduceImpl(predicate, f, _acc, _list) {
  while(true) {
    var list = _list;
    var acc = _acc;
    if (list) {
      var head = list[0];
      if (Curry._2(predicate, acc, head)) {
        var acc$1 = Curry._2(f, acc, head);
        _list = list[1];
        _acc = acc$1;
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function reduce($staropt$star, f, acc, list) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
  return reduceImpl(predicate, f, acc, list);
}

function removeAll() {
  return /* [] */0;
}

function removeFirstOrRaise(list) {
  if (list) {
    return list[1];
  } else {
    return Pervasives.failwith("List is empty");
  }
}

function $$return(value) {
  return /* :: */[
          value,
          /* [] */0
        ];
}

function some(f, _list) {
  while(true) {
    var list = _list;
    if (list) {
      if (Curry._1(f, list[0])) {
        return /* true */1;
      } else {
        _list = list[1];
        continue ;
        
      }
    } else {
      return /* false */0;
    }
  };
}

exports.addFirst           = addFirst;
exports.countImpl          = countImpl;
exports.count              = count;
exports.empty              = empty;
exports.isEmpty            = isEmpty;
exports.isNotEmpty         = isNotEmpty;
exports.findOrRaise        = findOrRaise;
exports.first              = first;
exports.firstOrRaise       = firstOrRaise;
exports.reduceImpl         = reduceImpl;
exports.reduce             = reduce;
exports.removeAll          = removeAll;
exports.removeFirstOrRaise = removeFirstOrRaise;
exports.$$return           = $$return;
exports.some               = some;
/* No side effect */


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE



var equal = /* Equal */0;

var greaterThan = /* GreaterThan */1;

var lessThan = /* LessThan */2;

exports.equal       = equal;
exports.greaterThan = greaterThan;
exports.lessThan    = lessThan;
/* No side effect */


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                = __webpack_require__(1);
var Sequence             = __webpack_require__(56);
var Pervasives           = __webpack_require__(2);
var SequentialCollection = __webpack_require__(70);

function Make(Base) {
  var lastOrRaise = Base[2];
  var include = SequentialCollection.Make([
        Base[0],
        Base[1],
        Base[3],
        Base[5]
      ]);
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var firstOrRaise = include[14];
  var last = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._1(lastOrRaise, collection)];
    }
  };
  var reduce = Base[/* reduceReversed */4];
  var ReversedSequentialCollection = SequentialCollection.Make(/* module */[
        /* count */count,
        /* firstOrRaise */lastOrRaise,
        /* reduce */reduce,
        /* toSequence */Base[6]
      ]);
  var reduceReversed = ReversedSequentialCollection[/* reduce */5];
  var toIterableReversed = ReversedSequentialCollection[/* toIterable */7];
  var toSequenceReversed = ReversedSequentialCollection[/* toSequence */12];
  var toCollectionReversed = ReversedSequentialCollection[/* toCollection */11];
  var toSequentialCollectionReversed = ReversedSequentialCollection[/* toSequentialCollection */15];
  var navigableCollectionBase_002 = /* reduce */Base[/* reduce */3];
  var navigableCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    navigableCollectionBase_002,
    /* toSequence */toSequence
  ];
  var navigableCollectionReversedBase_002 = /* reduce */Base[/* reduceReversed */4];
  var navigableCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    navigableCollectionReversedBase_002,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              navigableCollectionBase,
              navigableCollectionReversedBase
            ];
    }
  };
  var toNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              navigableCollectionReversedBase,
              navigableCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* first */include[13],
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */include[15],
          /* last */last,
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */reduceReversed,
          /* toCollectionReversed */toCollectionReversed,
          /* toIterableReversed */toIterableReversed,
          /* toNavigableCollection */toNavigableCollection,
          /* toNavigableCollectionReversed */toNavigableCollectionReversed,
          /* toSequenceReversed */toSequenceReversed,
          /* toSequentialCollectionReversed */toSequentialCollectionReversed
        ];
}

function Make1(Base) {
  var lastOrRaise = Base[2];
  var include = SequentialCollection.Make1([
        Base[0],
        Base[1],
        Base[3],
        Base[5]
      ]);
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var firstOrRaise = include[14];
  var last = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._1(lastOrRaise, collection)];
    }
  };
  var reduce = Base[/* reduceReversed */4];
  var ReversedSequentialCollection = SequentialCollection.Make1(/* module */[
        /* count */count,
        /* firstOrRaise */lastOrRaise,
        /* reduce */reduce,
        /* toSequence */Base[6]
      ]);
  var reduceReversed = ReversedSequentialCollection[/* reduce */5];
  var toIterableReversed = ReversedSequentialCollection[/* toIterable */7];
  var toSequenceReversed = ReversedSequentialCollection[/* toSequence */12];
  var toCollectionReversed = ReversedSequentialCollection[/* toCollection */11];
  var toSequentialCollectionReversed = ReversedSequentialCollection[/* toSequentialCollection */15];
  var navigableCollectionBase_002 = /* reduce */Base[/* reduce */3];
  var navigableCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    navigableCollectionBase_002,
    /* toSequence */toSequence
  ];
  var navigableCollectionReversedBase_002 = /* reduce */Base[/* reduceReversed */4];
  var navigableCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    navigableCollectionReversedBase_002,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              navigableCollectionBase,
              navigableCollectionReversedBase
            ];
    }
  };
  var toNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              navigableCollectionReversedBase,
              navigableCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* first */include[13],
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */include[15],
          /* last */last,
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */reduceReversed,
          /* toCollectionReversed */toCollectionReversed,
          /* toIterableReversed */toIterableReversed,
          /* toNavigableCollection */toNavigableCollection,
          /* toNavigableCollectionReversed */toNavigableCollectionReversed,
          /* toSequenceReversed */toSequenceReversed,
          /* toSequentialCollectionReversed */toSequentialCollectionReversed
        ];
}

function count(collection) {
  if (collection) {
    return Curry._1(collection[1][/* count */0], collection[0]);
  } else {
    return 0;
  }
}

function firstOrRaise(collection) {
  if (collection) {
    return Curry._1(collection[1][/* firstOrRaise */1], collection[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function lastOrRaise(collection) {
  if (collection) {
    return Curry._1(collection[2][/* firstOrRaise */1], collection[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[1][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function reduceReversed(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[2][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function toSequence(collection) {
  if (collection) {
    return Curry._1(collection[1][/* toSequence */3], collection[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function toSequenceReversed(collection) {
  if (collection) {
    return Curry._1(collection[2][/* toSequence */3], collection[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include = SequentialCollection.Make1([
      count,
      firstOrRaise,
      reduce,
      toSequence
    ]);

var count$1 = include[8];

var isEmpty = include[9];

var toSequence$1 = include[12];

var firstOrRaise$1 = include[14];

function last(collection) {
  if (Curry._1(isEmpty, collection)) {
    return /* None */0;
  } else {
    return /* Some */[lastOrRaise(collection)];
  }
}

var ReversedSequentialCollection = SequentialCollection.Make1(/* module */[
      /* count */count$1,
      /* firstOrRaise */lastOrRaise,
      /* reduce */reduceReversed,
      /* toSequence */toSequenceReversed
    ]);

var reduceReversed$1 = ReversedSequentialCollection[/* reduce */5];

var toIterableReversed = ReversedSequentialCollection[/* toIterable */7];

var toSequenceReversed$1 = ReversedSequentialCollection[/* toSequence */12];

var toCollectionReversed = ReversedSequentialCollection[/* toCollection */11];

var toSequentialCollectionReversed = ReversedSequentialCollection[/* toSequentialCollection */15];

var navigableCollectionBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */firstOrRaise$1,
  /* reduce */reduce,
  /* toSequence */toSequence$1
];

var navigableCollectionReversedBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */lastOrRaise,
  /* reduce */reduceReversed,
  /* toSequence */toSequenceReversed$1
];

function toNavigableCollectionReversed(collection) {
  if (Curry._1(isEmpty, collection)) {
    return /* Empty */0;
  } else {
    return /* Instance */[
            collection,
            navigableCollectionReversedBase,
            navigableCollectionBase
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toNavigableCollection(collection) {
  return collection;
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var isNotEmpty = include[10];

var toCollection = include[11];

var first = include[13];

var toSequentialCollection = include[15];

exports.Make                           = Make;
exports.Make1                          = Make1;
exports.every                          = every;
exports.find                           = find;
exports.findOrRaise                    = findOrRaise;
exports.forEach                        = forEach;
exports.none                           = none;
exports.reduce                         = reduce$1;
exports.some                           = some;
exports.toIterable                     = toIterable;
exports.count                          = count$1;
exports.isEmpty                        = isEmpty;
exports.isNotEmpty                     = isNotEmpty;
exports.toCollection                   = toCollection;
exports.toSequence                     = toSequence$1;
exports.first                          = first;
exports.firstOrRaise                   = firstOrRaise$1;
exports.toSequentialCollection         = toSequentialCollection;
exports.last                           = last;
exports.lastOrRaise                    = lastOrRaise;
exports.reduceReversed                 = reduceReversed$1;
exports.toCollectionReversed           = toCollectionReversed;
exports.toIterableReversed             = toIterableReversed;
exports.toNavigableCollectionReversed  = toNavigableCollectionReversed;
exports.toSequenceReversed             = toSequenceReversed$1;
exports.toSequentialCollectionReversed = toSequentialCollectionReversed;
exports.empty                          = empty;
exports.toNavigableCollection          = toNavigableCollection;
/* include Not a pure module */


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var Option        = __webpack_require__(61);
var ImmList       = __webpack_require__(64);
var Iterable      = __webpack_require__(57);
var Functions     = __webpack_require__(55);
var KeyedReducer  = __webpack_require__(62);
var MutableOption = __webpack_require__(81);

function everyPredicate(acc, _, _$1) {
  return acc;
}

function findPredicate(acc, _, _$1) {
  return Option.isEmpty(acc);
}

function somePredicate(acc, _, _$1) {
  return 1 - acc;
}

function Make1(Base) {
  var isEmpty = Base[0];
  var reduce = Base[1];
  var reduceKeys = Base[2];
  var reduceValues = Base[3];
  var every = function (f, iter) {
    return Curry._4(reduce, everyPredicate, (function () {
                  return f;
                }), /* true */1, iter);
  };
  var find = function (selector, f, iter) {
    return Curry._4(reduce, findPredicate, (function (_, k, v) {
                  if (Curry._2(f, k, v)) {
                    return /* Some */[Curry._2(selector, k, v)];
                  } else {
                    return /* None */0;
                  }
                }), /* None */0, iter);
  };
  var findOrRaise = function (selector, f, iter) {
    return Option.firstOrRaise(find(selector, f, iter));
  };
  var forEach = function ($staropt$star, f, iter) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(Base[/* reduce */1], Functions.alwaysTrue3, (function () {
                    return f;
                  }), /* () */0, iter);
    } else {
      return Curry._4(reduce, (function () {
                    return predicate;
                  }), (function () {
                    return f;
                  }), /* () */0, iter);
    }
  };
  var none = function (f, iter) {
    return Curry._4(reduce, everyPredicate, (function (_, k, v) {
                  return 1 - Curry._2(f, k, v);
                }), /* true */1, iter);
  };
  var reduce$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue3;
    return Curry._4(reduce, predicate, f, acc, map);
  };
  var reduceKeys$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduceKeys, predicate, f, acc, map);
  };
  var reduceValues$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduceValues, predicate, f, acc, map);
  };
  var some = function (f, iter) {
    return reduce$1(/* Some */[somePredicate], (function () {
                  return f;
                }), /* false */0, iter);
  };
  var keysIterableBase = /* record */[/* reduce */Base[/* reduceKeys */2]];
  var keys = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              keysIterableBase
            ];
    }
  };
  var toIterable = function (selector, keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              /* record */[/* reduce */(function (predicate, f, acc, map) {
                    if (predicate === Functions.alwaysTrue2) {
                      var f$1 = function (acc, k, v) {
                        return Curry._2(f, acc, Curry._2(selector, k, v));
                      };
                      return reduce$1(/* None */0, f$1, acc, map);
                    } else {
                      var memoizedPair = MutableOption.empty(/* () */0);
                      var predicate$1 = function (acc, k, v) {
                        var pair = Curry._2(selector, k, v);
                        MutableOption.set(pair, memoizedPair);
                        return Curry._2(predicate, acc, pair);
                      };
                      var f$2 = function (acc, _, _$1) {
                        return Curry._2(f, acc, MutableOption.firstOrRaise(memoizedPair));
                      };
                      return reduce$1(/* Some */[predicate$1], f$2, acc, map);
                    }
                  })]
            ];
    }
  };
  var keyedIterableBase = /* record */[/* reduce */Base[/* reduce */1]];
  var toKeyedIterable = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyedIterable,
              keyedIterableBase
            ];
    }
  };
  var valuesIterableBase = /* record */[/* reduce */Base[/* reduceValues */3]];
  var values = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              valuesIterableBase
            ];
    }
  };
  return /* module */[
          /* every */every,
          /* find */find,
          /* findOrRaise */findOrRaise,
          /* forEach */forEach,
          /* keys */keys,
          /* none */none,
          /* reduce */reduce$1,
          /* reduceKeys */reduceKeys$1,
          /* reduceValues */reduceValues$1,
          /* some */some,
          /* toIterable */toIterable,
          /* toKeyedIterable */toKeyedIterable,
          /* values */values
        ];
}

function Make2(Base) {
  var isEmpty = Base[0];
  var reduce = Base[1];
  var reduceKeys = Base[2];
  var reduceValues = Base[3];
  var every = function (f, iter) {
    return Curry._4(reduce, everyPredicate, (function () {
                  return f;
                }), /* true */1, iter);
  };
  var find = function (selector, f, iter) {
    return Curry._4(reduce, findPredicate, (function (_, k, v) {
                  if (Curry._2(f, k, v)) {
                    return /* Some */[Curry._2(selector, k, v)];
                  } else {
                    return /* None */0;
                  }
                }), /* None */0, iter);
  };
  var findOrRaise = function (selector, f, iter) {
    return Option.firstOrRaise(find(selector, f, iter));
  };
  var forEach = function ($staropt$star, f, iter) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    if (predicate === Functions.alwaysTrue2) {
      return Curry._4(Base[/* reduce */1], Functions.alwaysTrue3, (function () {
                    return f;
                  }), /* () */0, iter);
    } else {
      return Curry._4(reduce, (function () {
                    return predicate;
                  }), (function () {
                    return f;
                  }), /* () */0, iter);
    }
  };
  var none = function (f, iter) {
    return Curry._4(reduce, everyPredicate, (function (_, k, v) {
                  return 1 - Curry._2(f, k, v);
                }), /* true */1, iter);
  };
  var reduce$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue3;
    return Curry._4(reduce, predicate, f, acc, map);
  };
  var reduceKeys$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduceKeys, predicate, f, acc, map);
  };
  var reduceValues$1 = function ($staropt$star, f, acc, map) {
    var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
    return Curry._4(reduceValues, predicate, f, acc, map);
  };
  var some = function (f, iter) {
    return reduce$1(/* Some */[somePredicate], (function () {
                  return f;
                }), /* false */0, iter);
  };
  var keysIterableBase = /* record */[/* reduce */Base[/* reduceKeys */2]];
  var keys = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              keysIterableBase
            ];
    }
  };
  var toIterable = function (selector, keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              /* record */[/* reduce */(function (predicate, f, acc, map) {
                    if (predicate === Functions.alwaysTrue2) {
                      var f$1 = function (acc, k, v) {
                        return Curry._2(f, acc, Curry._2(selector, k, v));
                      };
                      return reduce$1(/* None */0, f$1, acc, map);
                    } else {
                      var memoizedPair = MutableOption.empty(/* () */0);
                      var predicate$1 = function (acc, k, v) {
                        var pair = Curry._2(selector, k, v);
                        MutableOption.set(pair, memoizedPair);
                        return Curry._2(predicate, acc, pair);
                      };
                      var f$2 = function (acc, _, _$1) {
                        return Curry._2(f, acc, MutableOption.firstOrRaise(memoizedPair));
                      };
                      return reduce$1(/* Some */[predicate$1], f$2, acc, map);
                    }
                  })]
            ];
    }
  };
  var keyedIterableBase = /* record */[/* reduce */Base[/* reduce */1]];
  var toKeyedIterable = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyedIterable,
              keyedIterableBase
            ];
    }
  };
  var valuesIterableBase = /* record */[/* reduce */Base[/* reduceValues */3]];
  var values = function (keyedIterable) {
    if (Curry._1(isEmpty, keyedIterable)) {
      return Iterable.empty(/* () */0);
    } else {
      return /* Instance */[
              keyedIterable,
              valuesIterableBase
            ];
    }
  };
  return /* module */[
          /* every */every,
          /* find */find,
          /* findOrRaise */findOrRaise,
          /* forEach */forEach,
          /* keys */keys,
          /* none */none,
          /* reduce */reduce$1,
          /* reduceKeys */reduceKeys$1,
          /* reduceValues */reduceValues$1,
          /* some */some,
          /* toIterable */toIterable,
          /* toKeyedIterable */toKeyedIterable,
          /* values */values
        ];
}

function reduce(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[1][/* reduce */0], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

var reduce$1 = include[0];

var reduceKeys = include[1];

var reduceValues = include[2];

function every(f, iter) {
  return Curry._4(reduce$1, everyPredicate, (function () {
                return f;
              }), /* true */1, iter);
}

function find(selector, f, iter) {
  return Curry._4(reduce$1, findPredicate, (function (_, k, v) {
                if (Curry._2(f, k, v)) {
                  return /* Some */[Curry._2(selector, k, v)];
                } else {
                  return /* None */0;
                }
              }), /* None */0, iter);
}

function findOrRaise(selector, f, iter) {
  return Option.firstOrRaise(find(selector, f, iter));
}

function forEach($staropt$star, f, iter) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
  if (predicate === Functions.alwaysTrue2) {
    return Curry._4(reduce$1, Functions.alwaysTrue3, (function () {
                  return f;
                }), /* () */0, iter);
  } else {
    return Curry._4(reduce$1, (function () {
                  return predicate;
                }), (function () {
                  return f;
                }), /* () */0, iter);
  }
}

function none(f, iter) {
  return Curry._4(reduce$1, everyPredicate, (function (_, k, v) {
                return 1 - Curry._2(f, k, v);
              }), /* true */1, iter);
}

function reduce$2($staropt$star, f, acc, map) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue3;
  return Curry._4(reduce$1, predicate, f, acc, map);
}

function reduceKeys$1($staropt$star, f, acc, map) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
  return Curry._4(reduceKeys, predicate, f, acc, map);
}

function reduceValues$1($staropt$star, f, acc, map) {
  var predicate = $staropt$star ? $staropt$star[0] : Functions.alwaysTrue2;
  return Curry._4(reduceValues, predicate, f, acc, map);
}

function some(f, iter) {
  return reduce$2(/* Some */[somePredicate], (function () {
                return f;
              }), /* false */0, iter);
}

var keysIterableBase = /* record */[/* reduce */reduceKeys];

function keys(keyedIterable) {
  if (keyedIterable) {
    return /* Instance */[
            keyedIterable,
            keysIterableBase
          ];
  } else {
    return Iterable.empty(/* () */0);
  }
}

function toIterable(selector, keyedIterable) {
  if (keyedIterable) {
    return /* Instance */[
            keyedIterable,
            /* record */[/* reduce */(function (predicate, f, acc, map) {
                  if (predicate === Functions.alwaysTrue2) {
                    var f$1 = function (acc, k, v) {
                      return Curry._2(f, acc, Curry._2(selector, k, v));
                    };
                    return reduce$2(/* None */0, f$1, acc, map);
                  } else {
                    var memoizedPair = MutableOption.empty(/* () */0);
                    var predicate$1 = function (acc, k, v) {
                      var pair = Curry._2(selector, k, v);
                      MutableOption.set(pair, memoizedPair);
                      return Curry._2(predicate, acc, pair);
                    };
                    var f$2 = function (acc, _, _$1) {
                      return Curry._2(f, acc, MutableOption.firstOrRaise(memoizedPair));
                    };
                    return reduce$2(/* Some */[predicate$1], f$2, acc, map);
                  }
                })]
          ];
  } else {
    return Iterable.empty(/* () */0);
  }
}

var valuesIterableBase = /* record */[/* reduce */reduceValues];

function values(keyedIterable) {
  if (keyedIterable) {
    return /* Instance */[
            keyedIterable,
            valuesIterableBase
          ];
  } else {
    return Iterable.empty(/* () */0);
  }
}

var concatImpl = /* record */[/* reduce */(function (predicate, f, acc, iters) {
      var shouldContinue = [/* true */1];
      var predicate$1 = function (acc, key, value) {
        var result = Curry._3(predicate, acc, key, value);
        shouldContinue[0] = result;
        return result;
      };
      return ImmList.reduce(/* Some */[(function (_, _$1) {
                      return shouldContinue[0];
                    })], (function (acc, next) {
                    return reduce$2(/* Some */[predicate$1], f, acc, next);
                  }), acc, iters);
    })];

function concat(iters) {
  if (iters) {
    return /* Instance */[
            iters,
            concatImpl
          ];
  } else {
    return /* Empty */0;
  }
}

var deferImpl = /* record */[/* reduce */(function (predicate, f, acc, provider) {
      return reduce$2(/* Some */[predicate], f, acc, Curry._1(provider, /* () */0));
    })];

function defer(provider) {
  return /* Instance */[
          provider,
          deferImpl
        ];
}

function distinctUntilChangedWith(keyEquals, valueEquals, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var previousKey = MutableOption.empty(/* () */0);
                  var previousValue = MutableOption.empty(/* () */0);
                  var shouldNotSkip = function (nextKey, nextValue) {
                    if (MutableOption.isEmpty(previousKey)) {
                      return /* true */1;
                    } else {
                      return 1 - (Curry._2(keyEquals, nextKey, MutableOption.firstOrRaise(previousKey)) && Curry._2(valueEquals, nextValue, MutableOption.firstOrRaise(previousValue)));
                    }
                  };
                  var predicate$1 = function (acc, key, value) {
                    if (shouldNotSkip(key, value)) {
                      return Curry._3(predicate, acc, key, value);
                    } else {
                      return /* true */1;
                    }
                  };
                  var f$1 = function (acc, key, value) {
                    if (shouldNotSkip(key, value)) {
                      MutableOption.set(key, previousKey);
                      MutableOption.set(value, previousValue);
                      return Curry._3(f, acc, key, value);
                    } else {
                      return acc;
                    }
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function doOnNext(sideEffect, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  return Curry._4(reduce, predicate, (function (acc, k, v) {
                                Curry._2(sideEffect, k, v);
                                return Curry._3(f, acc, k, v);
                              }), acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function empty() {
  return /* Empty */0;
}

function filter(filter$1, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var predicate$1 = function (acc, key, value) {
                    if (Curry._2(filter$1, key, value)) {
                      return Curry._3(predicate, acc, key, value);
                    } else {
                      return /* true */1;
                    }
                  };
                  return Curry._4(reduce, predicate$1, (function (acc, k, v) {
                                if (Curry._2(filter$1, k, v)) {
                                  return Curry._3(f, acc, k, v);
                                } else {
                                  return acc;
                                }
                              }), acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function flatMap(mapper, iter) {
  if (iter) {
    var reduceIter = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var shouldContinue = [/* true */1];
                  var predicate$1 = function (acc, key, value) {
                    var result = Curry._3(predicate, acc, key, value);
                    shouldContinue[0] = result;
                    return result;
                  };
                  return Curry._4(reduceIter, (function (_, _$1, _$2) {
                                return shouldContinue[0];
                              }), (function (acc, k, v) {
                                return reduce$2(/* Some */[predicate$1], f, acc, Curry._2(mapper, k, v));
                              }), acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

var fromEntriesImpl = /* record */[/* reduce */(function (predicate, f, acc, iter) {
      var predicate$1 = function (acc, param) {
        return Curry._3(predicate, acc, param[0], param[1]);
      };
      var f$1 = function (acc, param) {
        return Curry._3(f, acc, param[0], param[1]);
      };
      return Iterable.reduce(/* Some */[predicate$1], f$1, acc, iter);
    })];

function fromEntries(iter) {
  if (iter) {
    return /* Instance */[
            iter,
            fromEntriesImpl
          ];
  } else {
    return /* Empty */0;
  }
}

var generateImpl = /* record */[/* reduce */(function (predicate, f, acc, param) {
      var initialValue = param[3];
      var initialKey = param[2];
      if (Curry._3(predicate, acc, initialKey, initialValue)) {
        var acc$1 = Curry._3(f, acc, initialKey, initialValue);
        var genKey = param[0];
        var genValue = param[1];
        var _key = initialKey;
        var _value = initialValue;
        var predicate$1 = predicate;
        var f$1 = f;
        var _acc = acc$1;
        while(true) {
          var acc$2 = _acc;
          var value = _value;
          var key = _key;
          var nextKey = Curry._2(genKey, key, value);
          var nextValue = Curry._2(genValue, key, value);
          if (Curry._3(predicate$1, acc$2, nextKey, nextValue)) {
            var acc$3 = Curry._3(f$1, acc$2, nextKey, nextValue);
            _acc = acc$3;
            _value = nextValue;
            _key = nextKey;
            continue ;
            
          } else {
            return acc$2;
          }
        };
      } else {
        return acc;
      }
    })];

function generate(genKey, genValue, initialKey, initialValue) {
  return /* Instance */[
          /* tuple */[
            genKey,
            genValue,
            initialKey,
            initialValue
          ],
          generateImpl
        ];
}

function map(keyMapper, valueMapper, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var memoizedKey = MutableOption.empty(/* () */0);
                  var memoizedValue = MutableOption.empty(/* () */0);
                  var predicate$1 = function (acc, key, value) {
                    var nextKey = Curry._2(keyMapper, key, value);
                    var nextValue = Curry._2(valueMapper, key, value);
                    MutableOption.set(nextKey, memoizedKey);
                    MutableOption.set(nextValue, memoizedValue);
                    return Curry._3(predicate, acc, nextKey, nextValue);
                  };
                  var f$1 = function (acc, _, _$1) {
                    return Curry._3(f, acc, MutableOption.firstOrRaise(memoizedKey), MutableOption.firstOrRaise(memoizedValue));
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function mapKeys(mapper, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var memoizedKey = MutableOption.empty(/* () */0);
                  var predicate$1 = function (acc, key, value) {
                    var nextKey = Curry._2(mapper, key, value);
                    MutableOption.set(nextKey, memoizedKey);
                    return Curry._3(predicate, acc, nextKey, value);
                  };
                  var f$1 = function (acc, _, value) {
                    return Curry._3(f, acc, MutableOption.firstOrRaise(memoizedKey), value);
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function mapValues(mapper, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var memoizedValue = MutableOption.empty(/* () */0);
                  var predicate$1 = function (acc, key, value) {
                    var nextValue = Curry._2(mapper, key, value);
                    MutableOption.set(nextValue, memoizedValue);
                    return Curry._3(predicate, acc, key, nextValue);
                  };
                  var f$1 = function (acc, key, _) {
                    return Curry._3(f, acc, key, MutableOption.firstOrRaise(memoizedValue));
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

var returnImpl = /* record */[/* reduce */(function (predicate, f, acc, param) {
      var value = param[1];
      var key = param[0];
      if (Curry._3(predicate, acc, key, value)) {
        return Curry._3(f, acc, key, value);
      } else {
        return acc;
      }
    })];

function $$return(key, value) {
  return /* Instance */[
          /* tuple */[
            key,
            value
          ],
          returnImpl
        ];
}

function scan(reducer, initialValue, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  if (Curry._2(predicate, acc, initialValue)) {
                    var result = [Curry._2(f, acc, initialValue)];
                    var memoized = [initialValue];
                    var predicate$1 = function (acc, key, value) {
                      var nextValue = Curry._3(reducer, acc, key, value);
                      memoized[0] = nextValue;
                      return Curry._2(predicate, result[0], nextValue);
                    };
                    var f$1 = function (_, _$1, _$2) {
                      var acc = memoized[0];
                      result[0] = Curry._2(f, result[0], acc);
                      return acc;
                    };
                    Curry._4(reduce, predicate$1, f$1, initialValue, iter);
                    return result[0];
                  } else {
                    return acc;
                  }
                })]
          ];
  } else {
    return Iterable.$$return(initialValue);
  }
}

function skip(count, iter) {
  if (count) {
    if (iter) {
      var reduce = iter[1][/* reduce */0];
      return /* Instance */[
              iter[0],
              /* record */[/* reduce */(function (predicate, f, acc, iter) {
                    var count$1 = [count];
                    var predicate$1 = function (acc, key, value) {
                      if (count$1[0] > 0) {
                        return /* true */1;
                      } else {
                        return Curry._3(predicate, acc, key, value);
                      }
                    };
                    var f$1 = function (acc, key, value) {
                      count$1[0] = count$1[0] - 1 | 0;
                      if (count$1[0] >= 0) {
                        return acc;
                      } else {
                        return Curry._3(f, acc, key, value);
                      }
                    };
                    return Curry._4(reduce, predicate$1, f$1, acc, iter);
                  })]
            ];
    } else {
      return /* Empty */0;
    }
  } else {
    return iter;
  }
}

function skipWhile(keepSkipping, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var doneSkipping = [/* false */0];
                  var predicate$1 = function (acc, key, value) {
                    if (doneSkipping[0]) {
                      return Curry._3(predicate, acc, key, value);
                    } else {
                      return /* true */1;
                    }
                  };
                  var f$1 = function (acc, key, value) {
                    if (doneSkipping[0]) {
                      return Curry._3(f, acc, key, value);
                    } else if (Curry._2(keepSkipping, key, value)) {
                      return acc;
                    } else {
                      doneSkipping[0] = /* true */1;
                      return Curry._3(f, acc, key, value);
                    }
                  };
                  return Curry._4(reduce, predicate$1, f$1, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function startWith(key, value, iter) {
  return concat(/* :: */[
              $$return(key, value),
              /* :: */[
                iter,
                /* [] */0
              ]
            ]);
}

function take(count, iter) {
  if (count) {
    if (iter) {
      var reduce = iter[1][/* reduce */0];
      return /* Instance */[
              iter[0],
              /* record */[/* reduce */(function (predicate, f, acc, iter) {
                    var count$1 = [count];
                    var predicate$1 = function (acc, key, value) {
                      if (count$1[0] > 0) {
                        return Curry._3(predicate, acc, key, value);
                      } else {
                        return /* false */0;
                      }
                    };
                    var f$1 = function (acc, key, value) {
                      count$1[0] = count$1[0] - 1 | 0;
                      return Curry._3(f, acc, key, value);
                    };
                    return Curry._4(reduce, predicate$1, f$1, acc, iter);
                  })]
            ];
    } else {
      return /* Empty */0;
    }
  } else {
    return /* Empty */0;
  }
}

function takeWhile(keepTaking, iter) {
  if (iter) {
    var reduce = iter[1][/* reduce */0];
    return /* Instance */[
            iter[0],
            /* record */[/* reduce */(function (predicate, f, acc, iter) {
                  var predicate$1 = function (acc, key, value) {
                    if (Curry._2(keepTaking, key, value)) {
                      return Curry._3(predicate, acc, key, value);
                    } else {
                      return /* false */0;
                    }
                  };
                  return Curry._4(reduce, predicate$1, f, acc, iter);
                })]
          ];
  } else {
    return /* Empty */0;
  }
}

function toKeyedIterable(iter) {
  return iter;
}

var nonePredicate = everyPredicate;

exports.everyPredicate           = everyPredicate;
exports.findPredicate            = findPredicate;
exports.nonePredicate            = nonePredicate;
exports.somePredicate            = somePredicate;
exports.Make1                    = Make1;
exports.Make2                    = Make2;
exports.every                    = every;
exports.find                     = find;
exports.findOrRaise              = findOrRaise;
exports.forEach                  = forEach;
exports.keys                     = keys;
exports.none                     = none;
exports.reduce                   = reduce$2;
exports.reduceKeys               = reduceKeys$1;
exports.reduceValues             = reduceValues$1;
exports.some                     = some;
exports.toIterable               = toIterable;
exports.values                   = values;
exports.concatImpl               = concatImpl;
exports.concat                   = concat;
exports.deferImpl                = deferImpl;
exports.defer                    = defer;
exports.distinctUntilChangedWith = distinctUntilChangedWith;
exports.doOnNext                 = doOnNext;
exports.empty                    = empty;
exports.filter                   = filter;
exports.flatMap                  = flatMap;
exports.fromEntriesImpl          = fromEntriesImpl;
exports.fromEntries              = fromEntries;
exports.generateImpl             = generateImpl;
exports.generate                 = generate;
exports.map                      = map;
exports.mapKeys                  = mapKeys;
exports.mapValues                = mapValues;
exports.returnImpl               = returnImpl;
exports.$$return                 = $$return;
exports.scan                     = scan;
exports.skip                     = skip;
exports.skipWhile                = skipWhile;
exports.startWith                = startWith;
exports.take                     = take;
exports.takeWhile                = takeWhile;
exports.toKeyedIterable          = toKeyedIterable;
/* include Not a pure module */


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry               = __webpack_require__(1);
var ImmSet              = __webpack_require__(59);
var Iterable            = __webpack_require__(57);
var Sequence            = __webpack_require__(56);
var Functions           = __webpack_require__(55);
var Pervasives          = __webpack_require__(2);
var NavigableCollection = __webpack_require__(66);

function Make(Base) {
  var include = ImmSet.Make([
        Base[0],
        Base[1],
        Base[4],
        Base[6]
      ]);
  var contains = include[14];
  var include$1 = NavigableCollection.Make([
        Base[1],
        Base[2],
        Base[3],
        Base[4],
        Base[5],
        Base[6],
        Base[7]
      ]);
  var count = include$1[8];
  var isEmpty = include$1[9];
  var toSequence = include$1[12];
  var firstOrRaise = include$1[14];
  var lastOrRaise = include$1[17];
  var toSequenceReversed = include$1[23];
  var reduce = Base[/* reduceReversed */5];
  var ReversedImmSet = ImmSet.Make(/* module */[
        /* contains */contains,
        /* count */count,
        /* reduce */reduce,
        /* toSequence */toSequenceReversed
      ]);
  var toSetReversed = ReversedImmSet[/* toSet */15];
  var navigableSetBase_003 = /* reduce */Base[/* reduce */4];
  var navigableSetBase = /* record */[
    /* contains */contains,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    navigableSetBase_003,
    /* toSequence */toSequence
  ];
  var navigableSetReversedBase_003 = /* reduce */Base[/* reduceReversed */5];
  var navigableSetReversedBase = /* record */[
    /* contains */contains,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    navigableSetReversedBase_003,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableSet = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              navigableSetBase,
              navigableSetReversedBase
            ];
    }
  };
  var toNavigableSetReversed = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              navigableSetReversedBase,
              navigableSetBase
            ];
    }
  };
  return /* module */[
          /* equals */include[13],
          /* contains */contains,
          /* toSet */include[15],
          /* every */include$1[0],
          /* find */include$1[1],
          /* findOrRaise */include$1[2],
          /* forEach */include$1[3],
          /* none */include$1[4],
          /* reduce */include$1[5],
          /* some */include$1[6],
          /* toIterable */include$1[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include$1[10],
          /* toCollection */include$1[11],
          /* toSequence */toSequence,
          /* first */include$1[13],
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */include$1[15],
          /* last */include$1[16],
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */include$1[18],
          /* toCollectionReversed */include$1[19],
          /* toIterableReversed */include$1[20],
          /* toNavigableCollection */include$1[21],
          /* toNavigableCollectionReversed */include$1[22],
          /* toSequenceReversed */toSequenceReversed,
          /* toSequentialCollectionReversed */include$1[24],
          /* toNavigableSet */toNavigableSet,
          /* toNavigableSetReversed */toNavigableSetReversed,
          /* toSetReversed */toSetReversed
        ];
}

function Make1(Base) {
  var include = ImmSet.Make1([
        Base[0],
        Base[1],
        Base[4],
        Base[6]
      ]);
  var contains = include[13];
  var include$1 = NavigableCollection.Make1([
        Base[1],
        Base[2],
        Base[3],
        Base[4],
        Base[5],
        Base[6],
        Base[7]
      ]);
  var count = include$1[8];
  var isEmpty = include$1[9];
  var toSequence = include$1[12];
  var firstOrRaise = include$1[14];
  var lastOrRaise = include$1[17];
  var toSequenceReversed = include$1[23];
  var reduce = Base[/* reduceReversed */5];
  var ReversedImmSet = ImmSet.Make1(/* module */[
        /* contains */contains,
        /* count */count,
        /* reduce */reduce,
        /* toSequence */toSequenceReversed
      ]);
  var toSetReversed = ReversedImmSet[/* toSet */15];
  var navigableSetBase_003 = /* reduce */Base[/* reduce */4];
  var navigableSetBase = /* record */[
    /* contains */contains,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    navigableSetBase_003,
    /* toSequence */toSequence
  ];
  var navigableSetReversedBase_003 = /* reduce */Base[/* reduceReversed */5];
  var navigableSetReversedBase = /* record */[
    /* contains */contains,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    navigableSetReversedBase_003,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableSet = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              navigableSetBase,
              navigableSetReversedBase
            ];
    }
  };
  var toNavigableSetReversed = function (set) {
    if (Curry._1(isEmpty, set)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              set,
              navigableSetReversedBase,
              navigableSetBase
            ];
    }
  };
  return /* module */[
          /* contains */contains,
          /* equals */include[14],
          /* toSet */include[15],
          /* every */include$1[0],
          /* find */include$1[1],
          /* findOrRaise */include$1[2],
          /* forEach */include$1[3],
          /* none */include$1[4],
          /* reduce */include$1[5],
          /* some */include$1[6],
          /* toIterable */include$1[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include$1[10],
          /* toCollection */include$1[11],
          /* toSequence */toSequence,
          /* first */include$1[13],
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */include$1[15],
          /* last */include$1[16],
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */include$1[18],
          /* toCollectionReversed */include$1[19],
          /* toIterableReversed */include$1[20],
          /* toNavigableCollection */include$1[21],
          /* toNavigableCollectionReversed */include$1[22],
          /* toSequenceReversed */toSequenceReversed,
          /* toSequentialCollectionReversed */include$1[24],
          /* toNavigableSet */toNavigableSet,
          /* toNavigableSetReversed */toNavigableSetReversed,
          /* toSetReversed */toSetReversed
        ];
}

function contains(value, set) {
  if (set) {
    return Curry._2(set[1][/* contains */0], value, set[0]);
  } else {
    return /* false */0;
  }
}

function count(set) {
  if (set) {
    return Curry._1(set[1][/* count */1], set[0]);
  } else {
    return 0;
  }
}

function firstOrRaise(set) {
  if (set) {
    return Curry._1(set[1][/* firstOrRaise */2], set[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function lastOrRaise(set) {
  if (set) {
    return Curry._1(set[2][/* firstOrRaise */2], set[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, set) {
  if (set) {
    return Curry._4(set[1][/* reduce */3], predicate, f, acc, set[0]);
  } else {
    return acc;
  }
}

function reduceReversed(predicate, f, acc, set) {
  if (set) {
    return Curry._4(set[2][/* reduce */3], predicate, f, acc, set[0]);
  } else {
    return acc;
  }
}

function toSequence(set) {
  if (set) {
    return Curry._1(set[1][/* toSequence */4], set[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function toSequenceReversed(set) {
  if (set) {
    return Curry._1(set[2][/* toSequence */4], set[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include = ImmSet.Make1([
      contains,
      count,
      reduce,
      toSequence
    ]);

var contains$1 = include[13];

var include$1 = NavigableCollection.Make1([
      count,
      firstOrRaise,
      lastOrRaise,
      reduce,
      reduceReversed,
      toSequence,
      toSequenceReversed
    ]);

var toIterable = include$1[7];

var count$1 = include$1[8];

var isEmpty = include$1[9];

var toSequence$1 = include$1[12];

var firstOrRaise$1 = include$1[14];

var lastOrRaise$1 = include$1[17];

var toSequenceReversed$1 = include$1[23];

var ReversedImmSet = ImmSet.Make1(/* module */[
      /* contains */contains$1,
      /* count */count$1,
      /* reduce */reduceReversed,
      /* toSequence */toSequenceReversed$1
    ]);

var toSetReversed = ReversedImmSet[/* toSet */15];

var navigableSetBase = /* record */[
  /* contains */contains$1,
  /* count */count$1,
  /* firstOrRaise */firstOrRaise$1,
  /* reduce */reduce,
  /* toSequence */toSequence$1
];

var navigableSetReversedBase = /* record */[
  /* contains */contains$1,
  /* count */count$1,
  /* firstOrRaise */lastOrRaise$1,
  /* reduce */reduceReversed,
  /* toSequence */toSequenceReversed$1
];

function toNavigableSetReversed(set) {
  if (Curry._1(isEmpty, set)) {
    return /* Empty */0;
  } else {
    return /* Instance */[
            set,
            navigableSetReversedBase,
            navigableSetBase
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toNavigableSet(set) {
  return set;
}

function intersect($$this, that) {
  return Iterable.filter((function (param) {
                return Functions.flip(contains$1, that, param);
              }), Curry._1(toIterable, $$this));
}

function subtract($$this, that) {
  return Iterable.filter(Curry._2(Functions.Operators[/* >> */0], (function (param) {
                    return Functions.flip(contains$1, that, param);
                  }), (function (prim) {
                    return 1 - prim;
                  })), Curry._1(toIterable, $$this));
}

function union($$this, that) {
  return Iterable.concat(/* :: */[
              Curry._1(toIterable, $$this),
              /* :: */[
                subtract(that, $$this),
                /* [] */0
              ]
            ]);
}

var equals = include[14];

var toSet = include[15];

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var none = include$1[4];

var reduce$1 = include$1[5];

var some = include$1[6];

var isNotEmpty = include$1[10];

var toCollection = include$1[11];

var first = include$1[13];

var toSequentialCollection = include$1[15];

var last = include$1[16];

var reduceReversed$1 = include$1[18];

var toCollectionReversed = include$1[19];

var toIterableReversed = include$1[20];

var toNavigableCollection = include$1[21];

var toNavigableCollectionReversed = include$1[22];

var toSequentialCollectionReversed = include$1[24];

exports.Make                           = Make;
exports.Make1                          = Make1;
exports.contains                       = contains$1;
exports.equals                         = equals;
exports.toSet                          = toSet;
exports.every                          = every;
exports.find                           = find;
exports.findOrRaise                    = findOrRaise;
exports.forEach                        = forEach;
exports.none                           = none;
exports.reduce                         = reduce$1;
exports.some                           = some;
exports.toIterable                     = toIterable;
exports.count                          = count$1;
exports.isEmpty                        = isEmpty;
exports.isNotEmpty                     = isNotEmpty;
exports.toCollection                   = toCollection;
exports.toSequence                     = toSequence$1;
exports.first                          = first;
exports.firstOrRaise                   = firstOrRaise$1;
exports.toSequentialCollection         = toSequentialCollection;
exports.last                           = last;
exports.lastOrRaise                    = lastOrRaise$1;
exports.reduceReversed                 = reduceReversed$1;
exports.toCollectionReversed           = toCollectionReversed;
exports.toIterableReversed             = toIterableReversed;
exports.toNavigableCollection          = toNavigableCollection;
exports.toNavigableCollectionReversed  = toNavigableCollectionReversed;
exports.toSequenceReversed             = toSequenceReversed$1;
exports.toSequentialCollectionReversed = toSequentialCollectionReversed;
exports.toNavigableSetReversed         = toNavigableSetReversed;
exports.toSetReversed                  = toSetReversed;
exports.empty                          = empty;
exports.toNavigableSet                 = toNavigableSet;
exports.intersect                      = intersect;
exports.subtract                       = subtract;
exports.union                          = union;
/* include Not a pure module */


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry    = __webpack_require__(1);
var Iterable = __webpack_require__(57);
var Sequence = __webpack_require__(56);

function Make(Base) {
  var count = Base[0];
  var toSequence = Base[2];
  var isEmpty = function (collection) {
    return +(Curry._1(count, collection) === 0);
  };
  var isNotEmpty = function (collection) {
    return +(Curry._1(count, collection) !== 0);
  };
  var include = Iterable.Make(/* module */[
        /* isEmpty */isEmpty,
        /* reduce */Base[1]
      ]);
  var collectionBase_001 = /* reduce */Base[/* reduce */1];
  var collectionBase = /* record */[
    /* count */count,
    collectionBase_001,
    /* toSequence */toSequence
  ];
  var toCollection = function (collection) {
    if (Curry._1(count, collection)) {
      return /* Instance */[
              collection,
              collectionBase
            ];
    } else {
      return /* Empty */0;
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */isNotEmpty,
          /* toCollection */toCollection,
          /* toSequence */toSequence
        ];
}

function Make1(Base) {
  var count = Base[0];
  var isEmpty = function (collection) {
    return +(Curry._1(count, collection) === 0);
  };
  var isNotEmpty = function (collection) {
    return +(Curry._1(count, collection) !== 0);
  };
  var include = Iterable.Make1(/* module */[
        /* isEmpty */isEmpty,
        /* reduce */Base[1]
      ]);
  var toSequence = function (collection) {
    if (Curry._1(count, collection)) {
      return Curry._1(Base[/* toSequence */2], collection);
    } else {
      return Sequence.empty(/* () */0);
    }
  };
  var collectionBase_001 = /* reduce */Base[/* reduce */1];
  var collectionBase = /* record */[
    /* count */count,
    collectionBase_001,
    /* toSequence */toSequence
  ];
  var toCollection = function (collection) {
    if (Curry._1(count, collection)) {
      return /* Instance */[
              collection,
              collectionBase
            ];
    } else {
      return /* Empty */0;
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */isNotEmpty,
          /* toCollection */toCollection,
          /* toSequence */toSequence
        ];
}

function count(collection) {
  if (collection) {
    return Curry._1(collection[1][/* count */0], collection[0]);
  } else {
    return 0;
  }
}

function reduce(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[1][/* reduce */1], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function isEmpty(collection) {
  return +(count(collection) === 0);
}

function isNotEmpty(collection) {
  return +(count(collection) !== 0);
}

var include = Iterable.Make1(/* module */[
      /* isEmpty */isEmpty,
      /* reduce */reduce
    ]);

function toSequence(collection) {
  if (count(collection)) {
    var collection$1 = collection;
    if (collection$1) {
      return Curry._1(collection$1[1][/* toSequence */2], collection$1[0]);
    } else {
      return Sequence.empty(/* () */0);
    }
  } else {
    return Sequence.empty(/* () */0);
  }
}

function empty() {
  return /* Empty */0;
}

function toCollection(collection) {
  return collection;
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

exports.Make         = Make;
exports.Make1        = Make1;
exports.every        = every;
exports.find         = find;
exports.findOrRaise  = findOrRaise;
exports.forEach      = forEach;
exports.none         = none;
exports.reduce       = reduce$1;
exports.some         = some;
exports.toIterable   = toIterable;
exports.count        = count;
exports.isEmpty      = isEmpty;
exports.isNotEmpty   = isNotEmpty;
exports.toSequence   = toSequence;
exports.empty        = empty;
exports.toCollection = toCollection;
/* include Not a pure module */


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry      = __webpack_require__(1);
var Sequence   = __webpack_require__(56);
var Collection = __webpack_require__(69);
var Pervasives = __webpack_require__(2);

function Make(Base) {
  var firstOrRaise = Base[1];
  var include = Collection.Make([
        Base[0],
        Base[2],
        Base[3]
      ]);
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var first = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._1(firstOrRaise, collection)];
    }
  };
  var sequentialCollectionBase_002 = /* reduce */Base[/* reduce */2];
  var sequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    sequentialCollectionBase_002,
    /* toSequence */toSequence
  ];
  var toSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              sequentialCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* first */first,
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */toSequentialCollection
        ];
}

function Make1(Base) {
  var firstOrRaise = Base[1];
  var include = Collection.Make1([
        Base[0],
        Base[2],
        Base[3]
      ]);
  var count = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var first = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._1(firstOrRaise, collection)];
    }
  };
  var sequentialCollectionBase_002 = /* reduce */Base[/* reduce */2];
  var sequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    sequentialCollectionBase_002,
    /* toSequence */toSequence
  ];
  var toSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              collection,
              sequentialCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* first */first,
          /* firstOrRaise */firstOrRaise,
          /* toSequentialCollection */toSequentialCollection
        ];
}

function count(collection) {
  if (collection) {
    return Curry._1(collection[1][/* count */0], collection[0]);
  } else {
    return 0;
  }
}

function firstOrRaise(collection) {
  if (collection) {
    return Curry._1(collection[1][/* firstOrRaise */1], collection[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[1][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function toSequence(collection) {
  if (collection) {
    return Curry._1(collection[1][/* toSequence */3], collection[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include = Collection.Make1([
      count,
      reduce,
      toSequence
    ]);

var isEmpty = include[9];

function first(collection) {
  if (Curry._1(isEmpty, collection)) {
    return /* None */0;
  } else {
    return /* Some */[firstOrRaise(collection)];
  }
}

function empty() {
  return /* Empty */0;
}

function toSequentialCollection(collection) {
  return collection;
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var count$1 = include[8];

var isNotEmpty = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

exports.Make                   = Make;
exports.Make1                  = Make1;
exports.every                  = every;
exports.find                   = find;
exports.findOrRaise            = findOrRaise;
exports.forEach                = forEach;
exports.none                   = none;
exports.reduce                 = reduce$1;
exports.some                   = some;
exports.toIterable             = toIterable;
exports.count                  = count$1;
exports.isEmpty                = isEmpty;
exports.isNotEmpty             = isNotEmpty;
exports.toCollection           = toCollection;
exports.toSequence             = toSequence$1;
exports.first                  = first;
exports.firstOrRaise           = firstOrRaise;
exports.empty                  = empty;
exports.toSequentialCollection = toSequentialCollection;
/* include Not a pure module */


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry           = __webpack_require__(1);
var ImmSet          = __webpack_require__(59);
var Sequence        = __webpack_require__(56);
var Pervasives      = __webpack_require__(2);
var KeyedReducer    = __webpack_require__(62);
var KeyedCollection = __webpack_require__(78);

function Make1(Base) {
  var get = Base[2];
  var getOrDefault = Base[3];
  var getOrRaise = Base[4];
  var include = KeyedCollection.Make1([
        Base[0],
        Base[1],
        Base[5],
        Base[6],
        Base[7],
        Base[8]
      ]);
  var containsKey = include[13];
  var count = include[14];
  var isEmpty = include[15];
  var keysSequence = include[18];
  var toSequence = include[20];
  var keysSetBase_002 = /* reduce */Base[/* reduceKeys */6];
  var keysSetBase = /* record */[
    /* contains */containsKey,
    /* count */count,
    keysSetBase_002,
    /* toSequence */keysSequence
  ];
  var keysSet = function (map) {
    if (Curry._1(isEmpty, map)) {
      return ImmSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysSetBase
            ];
    }
  };
  var mapBase_005 = /* reduce */Base[/* reduce */5];
  var mapBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    mapBase_005,
    /* toSequence */toSequence
  ];
  var toMap = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              mapBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[16],
          /* keysCollection */include[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include[19],
          /* toSequence */toSequence,
          /* valuesCollection */include[21],
          /* valuesSequence */include[22],
          /* get */get,
          /* getOrDefault */getOrDefault,
          /* getOrRaise */getOrRaise,
          /* keysSet */keysSet,
          /* toMap */toMap
        ];
}

function Make2(Base) {
  var get = Base[2];
  var getOrDefault = Base[3];
  var getOrRaise = Base[4];
  var include = KeyedCollection.Make2([
        Base[0],
        Base[1],
        Base[5],
        Base[6],
        Base[7],
        Base[8]
      ]);
  var containsKey = include[13];
  var count = include[14];
  var isEmpty = include[15];
  var keysSequence = include[18];
  var toSequence = include[20];
  var keysSetBase_002 = /* reduce */Base[/* reduceKeys */6];
  var keysSetBase = /* record */[
    /* contains */containsKey,
    /* count */count,
    keysSetBase_002,
    /* toSequence */keysSequence
  ];
  var keysSet = function (map) {
    if (Curry._1(isEmpty, map)) {
      return ImmSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysSetBase
            ];
    }
  };
  var mapBase_005 = /* reduce */Base[/* reduce */5];
  var mapBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    mapBase_005,
    /* toSequence */toSequence
  ];
  var toMap = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              mapBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[16],
          /* keysCollection */include[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include[19],
          /* toSequence */toSequence,
          /* valuesCollection */include[21],
          /* valuesSequence */include[22],
          /* get */get,
          /* getOrDefault */getOrDefault,
          /* getOrRaise */getOrRaise,
          /* keysSet */keysSet,
          /* toMap */toMap
        ];
}

function containsKey(key, map) {
  if (map) {
    return Curry._2(map[1][/* containsKey */0], key, map[0]);
  } else {
    return /* false */0;
  }
}

function count(map) {
  if (map) {
    return Curry._1(map[1][/* count */1], map[0]);
  } else {
    return 0;
  }
}

function get(key, map) {
  if (map) {
    return Curry._2(map[1][/* get */2], key, map[0]);
  } else {
    return /* None */0;
  }
}

function getOrDefault($$default, key, map) {
  if (map) {
    return Curry._3(map[1][/* getOrDefault */3], $$default, key, map[0]);
  } else {
    return $$default;
  }
}

function getOrRaise(key, map) {
  if (map) {
    return Curry._2(map[1][/* getOrRaise */4], key, map[0]);
  } else {
    return Pervasives.failwith("not found");
  }
}

function reduce(predicate, f, acc, map) {
  if (map) {
    return Curry._4(map[1][/* reduce */5], predicate, f, acc, map[0]);
  } else {
    return acc;
  }
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

var reduceKeys = include[1];

function toSequence(selector, map) {
  if (map) {
    return Curry._2(map[1][/* toSequence */6], selector, map[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include$1 = KeyedCollection.Make2([
      containsKey,
      count,
      include[0],
      reduceKeys,
      include[2],
      toSequence
    ]);

var containsKey$1 = include$1[13];

var count$1 = include$1[14];

var isEmpty = include$1[15];

var keysSequence = include$1[18];

var keysSetBase = /* record */[
  /* contains */containsKey$1,
  /* count */count$1,
  /* reduce */reduceKeys,
  /* toSequence */keysSequence
];

function keysSet(map) {
  if (Curry._1(isEmpty, map)) {
    return ImmSet.empty(/* () */0);
  } else {
    return /* Instance */[
            map,
            keysSetBase
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toMap(map) {
  return map;
}

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var keys = include$1[4];

var none = include$1[5];

var reduce$1 = include$1[6];

var reduceKeys$1 = include$1[7];

var reduceValues = include$1[8];

var some = include$1[9];

var toIterable = include$1[10];

var toKeyedIterable = include$1[11];

var values = include$1[12];

var isNotEmpty = include$1[16];

var keysCollection = include$1[17];

var toKeyedCollection = include$1[19];

var toSequence$1 = include$1[20];

var valuesCollection = include$1[21];

var valuesSequence = include$1[22];

exports.Make1             = Make1;
exports.Make2             = Make2;
exports.every             = every;
exports.find              = find;
exports.findOrRaise       = findOrRaise;
exports.forEach           = forEach;
exports.keys              = keys;
exports.none              = none;
exports.reduce            = reduce$1;
exports.reduceKeys        = reduceKeys$1;
exports.reduceValues      = reduceValues;
exports.some              = some;
exports.toIterable        = toIterable;
exports.toKeyedIterable   = toKeyedIterable;
exports.values            = values;
exports.containsKey       = containsKey$1;
exports.count             = count$1;
exports.isEmpty           = isEmpty;
exports.isNotEmpty        = isNotEmpty;
exports.keysCollection    = keysCollection;
exports.keysSequence      = keysSequence;
exports.toKeyedCollection = toKeyedCollection;
exports.toSequence        = toSequence$1;
exports.valuesCollection  = valuesCollection;
exports.valuesSequence    = valuesSequence;
exports.get               = get;
exports.getOrDefault      = getOrDefault;
exports.getOrRaise        = getOrRaise;
exports.keysSet           = keysSet;
exports.empty             = empty;
exports.toMap             = toMap;
/* include Not a pure module */


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Caml_array = __webpack_require__(7);
var Caml_int32 = __webpack_require__(5);

var table = Caml_array.caml_make_vect(65536, 0);

var position1 = -1;

var position2 = -1;

for(var i = 1; i <= 65535; ++i){
  if (position1 === position2) {
    position1 = 0;
    position2 = i;
  }
  Caml_array.caml_array_set(table, i, Caml_array.caml_array_get(table, position1) + 1 | 0);
  position1 = position1 + 1 | 0;
}

function countBits(x) {
  var intValue = x;
  var intBits = Caml_array.caml_array_get(table, intValue & 65535) + Caml_array.caml_array_get(table, (intValue >> 16) & 65535) | 0;
  return intBits + (
          x < 0 ? 1 : 0
        ) | 0;
}

var width = 32;

function bitPos(key, depth) {
  var mask = (key >>> Caml_int32.imul(depth, 5)) & 31;
  return (1 << mask);
}

function index(bitmap, bit) {
  return countBits(bitmap & (bit - 1 | 0));
}

function containsNode(bitmap, bit) {
  return +((bitmap & bit) !== 0);
}

var bitCountTable = table;

var shift = 5;

exports.bitCountTable = bitCountTable;
exports.countBits     = countBits;
exports.shift         = shift;
exports.width         = width;
exports.bitPos        = bitPos;
exports.index         = index;
exports.containsNode  = containsNode;
/*  Not a pure module */


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Char      = __webpack_require__(27);
var Bytes     = __webpack_require__(40);
var Curry     = __webpack_require__(1);
var Int32     = __webpack_require__(35);
var Int64     = __webpack_require__(36);
var $$String  = __webpack_require__(17);
var Ordering  = __webpack_require__(65);
var Nativeint = __webpack_require__(42);

function make(compare, $$this, that) {
  var cmp = Curry._2(compare, $$this, that);
  if (cmp > 0) {
    return Ordering.greaterThan;
  } else if (cmp < 0) {
    return Ordering.lessThan;
  } else {
    return Ordering.equal;
  }
}

function bytes(param, param$1) {
  return make(Bytes.compare, param, param$1);
}

function $$char(param, param$1) {
  return make(Char.compare, param, param$1);
}

function $$int($$this, that) {
  if ($$this < that) {
    return Ordering.lessThan;
  } else if ($$this > that) {
    return Ordering.greaterThan;
  } else {
    return Ordering.equal;
  }
}

function int32(param, param$1) {
  return make(Int32.compare, param, param$1);
}

function int64(param, param$1) {
  return make(Int64.compare, param, param$1);
}

function nativeInt(param, param$1) {
  return make(Nativeint.compare, param, param$1);
}

function string(param, param$1) {
  return make($$String.compare, param, param$1);
}

function toEquality(comparator, x, y) {
  if (Curry._2(comparator, x, y) === Ordering.equal) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

exports.make       = make;
exports.bytes      = bytes;
exports.$$char     = $$char;
exports.$$int      = $$int;
exports.int32      = int32;
exports.int64      = int64;
exports.nativeInt  = nativeInt;
exports.string     = string;
exports.toEquality = toEquality;
/* No side effect */


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var Ordering      = __webpack_require__(65);
var Pervasives    = __webpack_require__(2);
var NavigableSet  = __webpack_require__(68);
var Preconditions = __webpack_require__(63);

function contains(value, param) {
  var start = param[/* start */1];
  if (value >= start) {
    return +(value < (start + param[/* count */0] | 0));
  } else {
    return /* false */0;
  }
}

function count(param) {
  return param[/* count */0];
}

function firstOrRaise(param) {
  if (param[/* count */0]) {
    return param[/* start */1];
  } else {
    return Pervasives.failwith("empty");
  }
}

function lastOrRaise(param) {
  var count = param[/* count */0];
  if (count) {
    return (param[/* start */1] + count | 0) - 1 | 0;
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, param) {
  var predicate$1 = predicate;
  var f$1 = f;
  var _start = param[/* start */1];
  var _count = param[/* count */0];
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var count = _count;
    var start = _start;
    if (count) {
      if (Curry._2(predicate$1, acc$1, start)) {
        var acc$2 = Curry._2(f$1, acc$1, start);
        _acc = acc$2;
        _count = count - 1 | 0;
        _start = start + 1 | 0;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      return acc$1;
    }
  };
}

function reduceReversed(predicate, f, acc, param) {
  var count = param[/* count */0];
  var predicate$1 = predicate;
  var f$1 = f;
  var _start = (param[/* start */1] + count | 0) - 1 | 0;
  var _count = count;
  var _acc = acc;
  while(true) {
    var acc$1 = _acc;
    var count$1 = _count;
    var start = _start;
    if (count$1) {
      if (Curry._2(predicate$1, acc$1, start)) {
        var acc$2 = Curry._2(f$1, acc$1, start);
        _acc = acc$2;
        _count = count$1 - 1 | 0;
        _start = start - 1 | 0;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      return acc$1;
    }
  };
}

function toSequence(param) {
  var start = param[/* start */1];
  var count = param[/* count */0];
  var recurse = function (start, count, _) {
    if (count) {
      var partial_arg = count - 1 | 0;
      var partial_arg$1 = start + 1 | 0;
      return /* Next */[
              start,
              (function (param) {
                  return recurse(partial_arg$1, partial_arg, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  };
  return (function (param) {
      return recurse(start, count, param);
    });
}

function toSequenceReversed(param) {
  var count = param[/* count */0];
  var recurse = function (start, count, _) {
    if (count) {
      var partial_arg = count - 1 | 0;
      var partial_arg$1 = start - 1 | 0;
      return /* Next */[
              start,
              (function (param) {
                  return recurse(partial_arg$1, partial_arg, param);
                })
            ];
    } else {
      return /* Completed */0;
    }
  };
  var partial_arg = (param[/* start */1] + count | 0) - 1 | 0;
  return (function (param) {
      return recurse(partial_arg, count, param);
    });
}

var include = NavigableSet.Make(/* module */[
      /* contains */contains,
      /* count */count,
      /* firstOrRaise */firstOrRaise,
      /* lastOrRaise */lastOrRaise,
      /* reduce */reduce,
      /* reduceReversed */reduceReversed,
      /* toSequence */toSequence,
      /* toSequenceReversed */toSequenceReversed
    ]);

var emptyInstance = /* record */[
  /* count */0,
  /* start */0
];

function create(start, count) {
  Preconditions.failIf("count must be >= 0", +(count < 0));
  if (count) {
    return /* record */[
            /* count */count,
            /* start */start
          ];
  } else {
    return emptyInstance;
  }
}

function compare(param, param$1) {
  var thatStart = param$1[/* start */1];
  var thisStart = param[/* start */1];
  if (thisStart > thatStart) {
    return Ordering.greaterThan;
  } else if (thisStart < thatStart) {
    return Ordering.lessThan;
  } else {
    var thatCount = param$1[/* count */0];
    var thisCount = param[/* count */0];
    if (thisCount > thatCount) {
      return Ordering.greaterThan;
    } else if (thisCount < thatCount) {
      return Ordering.lessThan;
    } else {
      return Ordering.equal;
    }
  }
}

function empty() {
  return emptyInstance;
}

function equals($$this, that) {
  if ($$this[/* start */1] === that[/* start */1]) {
    return +($$this[/* count */0] === that[/* count */0]);
  } else {
    return /* false */0;
  }
}

function hash(param) {
  return param[/* start */1] + param[/* count */0] | 0;
}

var contains$1 = include[1];

var toSet = include[2];

var every = include[3];

var find = include[4];

var findOrRaise = include[5];

var forEach = include[6];

var none = include[7];

var reduce$1 = include[8];

var some = include[9];

var toIterable = include[10];

var count$1 = include[11];

var isEmpty = include[12];

var isNotEmpty = include[13];

var toCollection = include[14];

var toSequence$1 = include[15];

var first = include[16];

var firstOrRaise$1 = include[17];

var toSequentialCollection = include[18];

var last = include[19];

var lastOrRaise$1 = include[20];

var reduceReversed$1 = include[21];

var toCollectionReversed = include[22];

var toIterableReversed = include[23];

var toNavigableCollection = include[24];

var toNavigableCollectionReversed = include[25];

var toSequenceReversed$1 = include[26];

var toSequentialCollectionReversed = include[27];

var toNavigableSet = include[28];

var toNavigableSetReversed = include[29];

var toSetReversed = include[30];

exports.contains                       = contains$1;
exports.toSet                          = toSet;
exports.every                          = every;
exports.find                           = find;
exports.findOrRaise                    = findOrRaise;
exports.forEach                        = forEach;
exports.none                           = none;
exports.reduce                         = reduce$1;
exports.some                           = some;
exports.toIterable                     = toIterable;
exports.count                          = count$1;
exports.isEmpty                        = isEmpty;
exports.isNotEmpty                     = isNotEmpty;
exports.toCollection                   = toCollection;
exports.toSequence                     = toSequence$1;
exports.first                          = first;
exports.firstOrRaise                   = firstOrRaise$1;
exports.toSequentialCollection         = toSequentialCollection;
exports.last                           = last;
exports.lastOrRaise                    = lastOrRaise$1;
exports.reduceReversed                 = reduceReversed$1;
exports.toCollectionReversed           = toCollectionReversed;
exports.toIterableReversed             = toIterableReversed;
exports.toNavigableCollection          = toNavigableCollection;
exports.toNavigableCollectionReversed  = toNavigableCollectionReversed;
exports.toSequenceReversed             = toSequenceReversed$1;
exports.toSequentialCollectionReversed = toSequentialCollectionReversed;
exports.toNavigableSet                 = toNavigableSet;
exports.toNavigableSetReversed         = toNavigableSetReversed;
exports.toSetReversed                  = toSetReversed;
exports.emptyInstance                  = emptyInstance;
exports.create                         = create;
exports.compare                        = compare;
exports.empty                          = empty;
exports.equals                         = equals;
exports.hash                           = hash;
/* include Not a pure module */


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block                   = __webpack_require__(25);
var Curry                   = __webpack_require__(1);
var Option                  = __webpack_require__(61);
var Iterable                = __webpack_require__(57);
var Sequence                = __webpack_require__(56);
var Transient               = __webpack_require__(58);
var Caml_array              = __webpack_require__(7);
var Caml_int32              = __webpack_require__(5);
var Pervasives              = __webpack_require__(2);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function count(trie) {
  if (typeof trie === "number") {
    return 0;
  } else if (trie.tag) {
    return trie[1][0];
  } else {
    return Curry._1(CopyOnWriteArray.count, trie[1]);
  }
}

function reduce(f, acc, trie) {
  if (typeof trie === "number") {
    return acc;
  } else if (trie.tag) {
    var reducer = function (acc, node) {
      return reduce(f, acc, node);
    };
    return Curry._4(CopyOnWriteArray.reduce, /* None */0, reducer, acc, trie[3]);
  } else {
    return Curry._4(CopyOnWriteArray.reduce, /* None */0, f, acc, trie[1]);
  }
}

function reduceWhileWithResult(triePredicate, trieReducer, predicate, f, acc, trie) {
  if (typeof trie === "number") {
    return acc;
  } else if (trie.tag) {
    return Curry._4(CopyOnWriteArray.reduce, /* Some */[triePredicate], trieReducer, acc, trie[3]);
  } else {
    return Curry._4(CopyOnWriteArray.reduce, /* Some */[predicate], f, acc, trie[1]);
  }
}

function reduceReversed(f, acc, trie) {
  if (typeof trie === "number") {
    return acc;
  } else if (trie.tag) {
    var reducer = function (acc, node) {
      return reduceReversed(f, acc, node);
    };
    return Curry._4(CopyOnWriteArray.reduceReversed, /* None */0, reducer, acc, trie[3]);
  } else {
    return Curry._4(CopyOnWriteArray.reduceReversed, /* None */0, f, acc, trie[1]);
  }
}

function reduceReversedWhileWithResult(triePredicate, trieReducer, predicate, f, acc, trie) {
  if (typeof trie === "number") {
    return acc;
  } else if (trie.tag) {
    return Curry._4(CopyOnWriteArray.reduceReversed, /* Some */[triePredicate], trieReducer, acc, trie[3]);
  } else {
    return Curry._4(CopyOnWriteArray.reduceReversed, /* Some */[predicate], f, acc, trie[1]);
  }
}

function toSequence(trie) {
  if (typeof trie === "number") {
    return Sequence.empty(/* () */0);
  } else if (trie.tag) {
    return Sequence.flatMap(toSequence, Curry._1(CopyOnWriteArray.toSequence, trie[3]));
  } else {
    return Curry._1(CopyOnWriteArray.toSequence, trie[1]);
  }
}

function toSequenceReversed(trie) {
  if (typeof trie === "number") {
    return Sequence.empty(/* () */0);
  } else if (trie.tag) {
    return Sequence.flatMap(toSequenceReversed, Curry._1(CopyOnWriteArray.toSequenceReversed, trie[3]));
  } else {
    return Curry._1(CopyOnWriteArray.toSequenceReversed, trie[1]);
  }
}

function depth(trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return trie[0];
  } else {
    return 0;
  }
}

function depthCapacity(depth) {
  return (32 << Caml_int32.imul(depth, 5));
}

function capacity(trie) {
  return depthCapacity(depth(trie));
}

function childCapacity(trie) {
  return depthCapacity(depth(trie) - 1 | 0);
}

function isEmpty(trie) {
  return +(count(trie) === 0);
}

function tryAddFirstLeafToTrieUsingMutator(updateLevel, owner, values, trie) {
  if (typeof trie === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            110,
            4
          ]
        ];
  } else if (trie.tag) {
    var tries = trie[3];
    var levelCount = trie[1];
    var levelDepth = trie[0];
    var firstChild = Curry._1(CopyOnWriteArray.firstOrRaise, tries);
    var firstChildCount = count(firstChild);
    var firstChildDepth = depth(firstChild);
    var triesWidth = Curry._1(CopyOnWriteArray.count, tries);
    var valuesCount = Curry._1(CopyOnWriteArray.count, values);
    if (typeof firstChild === "number") {
      return /* None */0;
    } else if (firstChild.tag) {
      var match = tryAddFirstLeafToTrieUsingMutator(updateLevel, owner, values, firstChild);
      if (match) {
        var newFirstChild = match[0];
        var newLevelCount = (levelCount[0] - firstChildCount | 0) + count(newFirstChild) | 0;
        return Option.$$return(Curry._5(updateLevel, owner, newLevelCount, 0, newFirstChild, trie));
      } else if (firstChildDepth < (levelDepth - 1 | 0)) {
        var newFirstChildLevelCount = [firstChildCount + valuesCount | 0];
        var newFirstChild_000 = firstChild[0] + 1 | 0;
        var newFirstChild_003 = /* array */[
          /* Leaf */Block.__(0, [
              owner,
              values
            ]),
          firstChild
        ];
        var newFirstChild$1 = /* Level */Block.__(1, [
            newFirstChild_000,
            newFirstChildLevelCount,
            owner,
            newFirstChild_003
          ]);
        var newLevelCount$1 = levelCount[0] + valuesCount | 0;
        return Option.$$return(Curry._5(updateLevel, owner, newLevelCount$1, 0, newFirstChild$1, trie));
      } else if (triesWidth < 32) {
        var newLevelCount$2 = [levelCount[0] + valuesCount | 0];
        return Option.$$return(/* Level */Block.__(1, [
                      levelDepth,
                      newLevelCount$2,
                      owner,
                      CopyOnWriteArray.addFirst(/* Leaf */Block.__(0, [
                              owner,
                              values
                            ]), tries)
                    ]));
      } else {
        return /* None */0;
      }
    } else if (firstChildDepth < (levelDepth - 1 | 0)) {
      var newFirstChildLevelCount$1 = firstChildCount + valuesCount | 0;
      var newFirstChild_001 = [newFirstChildLevelCount$1];
      var newFirstChild_003$1 = /* array */[
        /* Leaf */Block.__(0, [
            owner,
            values
          ]),
        firstChild
      ];
      var newFirstChild$2 = /* Level */Block.__(1, [
          1,
          newFirstChild_001,
          owner,
          newFirstChild_003$1
        ]);
      var newLevelCount$3 = (levelCount[0] - firstChildCount | 0) + newFirstChildLevelCount$1 | 0;
      return Option.$$return(Curry._5(updateLevel, owner, newLevelCount$3, 0, newFirstChild$2, trie));
    } else if (triesWidth < 32) {
      var newLevelCount$4 = levelCount[0] + valuesCount | 0;
      return Option.$$return(/* Level */Block.__(1, [
                    levelDepth,
                    [newLevelCount$4],
                    owner,
                    CopyOnWriteArray.addFirst(/* Leaf */Block.__(0, [
                            owner,
                            values
                          ]), tries)
                  ]));
    } else {
      return /* None */0;
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            110,
            4
          ]
        ];
  }
}

function addFirstLeafUsingMutator(updateLevel, owner, values, trie) {
  if (typeof trie === "number") {
    return /* Leaf */Block.__(0, [
              owner,
              values
            ]);
  } else if (trie.tag) {
    var match = tryAddFirstLeafToTrieUsingMutator(updateLevel, owner, values, trie);
    if (match) {
      return match[0];
    } else {
      var levelCount = count(trie) + Curry._1(CopyOnWriteArray.count, values) | 0;
      var levelDepth = trie[0] + 1 | 0;
      return /* Level */Block.__(1, [
                levelDepth,
                [levelCount],
                owner,
                /* array */[
                  /* Leaf */Block.__(0, [
                      owner,
                      values
                    ]),
                  trie
                ]
              ]);
    }
  } else {
    var levelCount$1 = count(trie) + Curry._1(CopyOnWriteArray.count, values) | 0;
    return /* Level */Block.__(1, [
              1,
              [levelCount$1],
              owner,
              /* array */[
                /* Leaf */Block.__(0, [
                    owner,
                    values
                  ]),
                trie
              ]
            ]);
  }
}

function tryAddLastLeafToTrieUsingMutator(updateLevel, owner, values, trie) {
  if (typeof trie === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            168,
            4
          ]
        ];
  } else if (trie.tag) {
    var tries = trie[3];
    var levelCount = trie[1];
    var levelDepth = trie[0];
    var lastIndex = CopyOnWriteArray.lastIndexOrRaise(tries);
    var lastChild = Curry._1(CopyOnWriteArray.lastOrRaise, tries);
    var lastChildCount = count(lastChild);
    var lastChildDepth = depth(lastChild);
    var triesWidth = Curry._1(CopyOnWriteArray.count, tries);
    var valuesCount = Curry._1(CopyOnWriteArray.count, values);
    if (typeof lastChild === "number") {
      return /* None */0;
    } else if (lastChild.tag) {
      var match = tryAddLastLeafToTrieUsingMutator(updateLevel, owner, values, lastChild);
      if (match) {
        var newLastChild = match[0];
        var newLevelCount = (levelCount[0] - lastChildCount | 0) + count(newLastChild) | 0;
        return Option.$$return(Curry._5(updateLevel, owner, newLevelCount, lastIndex, newLastChild, trie));
      } else if (lastChildDepth < (levelDepth - 1 | 0)) {
        var newLastChildLevelCount = [lastChildCount + valuesCount | 0];
        var newLastChild_000 = lastChild[0] + 1 | 0;
        var newLastChild_003 = /* array */[
          lastChild,
          /* Leaf */Block.__(0, [
              owner,
              values
            ])
        ];
        var newLastChild$1 = /* Level */Block.__(1, [
            newLastChild_000,
            newLastChildLevelCount,
            owner,
            newLastChild_003
          ]);
        var newLevelCount$1 = levelCount[0] + valuesCount | 0;
        return Option.$$return(Curry._5(updateLevel, owner, newLevelCount$1, lastIndex, newLastChild$1, trie));
      } else if (triesWidth < 32) {
        var newLevelCount$2 = [levelCount[0] + valuesCount | 0];
        return Option.$$return(/* Level */Block.__(1, [
                      levelDepth,
                      newLevelCount$2,
                      owner,
                      CopyOnWriteArray.addLast(/* Leaf */Block.__(0, [
                              owner,
                              values
                            ]), tries)
                    ]));
      } else {
        return /* None */0;
      }
    } else if (lastChildDepth < (levelDepth - 1 | 0)) {
      var newLastChildLevelCount$1 = lastChildCount + valuesCount | 0;
      var newLastChild_001 = [newLastChildLevelCount$1];
      var newLastChild_003$1 = /* array */[
        lastChild,
        /* Leaf */Block.__(0, [
            owner,
            values
          ])
      ];
      var newLastChild$2 = /* Level */Block.__(1, [
          1,
          newLastChild_001,
          owner,
          newLastChild_003$1
        ]);
      var newLevelCount$3 = (levelCount[0] - lastChildCount | 0) + newLastChildLevelCount$1 | 0;
      return Option.$$return(Curry._5(updateLevel, owner, newLevelCount$3, lastIndex, newLastChild$2, trie));
    } else if (triesWidth < 32) {
      var newLevelCount$4 = [levelCount[0] + valuesCount | 0];
      return Option.$$return(/* Level */Block.__(1, [
                    levelDepth,
                    newLevelCount$4,
                    owner,
                    CopyOnWriteArray.addLast(/* Leaf */Block.__(0, [
                            owner,
                            values
                          ]), tries)
                  ]));
    } else {
      return /* None */0;
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            168,
            4
          ]
        ];
  }
}

function addLastLeafUsingMutator(updateLevel, owner, values, trie) {
  if (typeof trie === "number") {
    return /* Leaf */Block.__(0, [
              owner,
              values
            ]);
  } else if (trie.tag) {
    var match = tryAddLastLeafToTrieUsingMutator(updateLevel, owner, values, trie);
    if (match) {
      return match[0];
    } else {
      var levelCount = count(trie) + Curry._1(CopyOnWriteArray.count, values) | 0;
      var levelDepth = trie[0] + 1 | 0;
      return /* Level */Block.__(1, [
                levelDepth,
                [levelCount],
                owner,
                /* array */[
                  trie,
                  /* Leaf */Block.__(0, [
                      owner,
                      values
                    ])
                ]
              ]);
    }
  } else {
    var levelCount$1 = count(trie) + Curry._1(CopyOnWriteArray.count, values) | 0;
    return /* Level */Block.__(1, [
              1,
              [levelCount$1],
              owner,
              /* array */[
                trie,
                /* Leaf */Block.__(0, [
                    owner,
                    values
                  ])
              ]
            ]);
  }
}

function removeFirstLeafUsingMutator(updateLevel, owner, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    var levelDepth = trie[0];
    if (levelDepth > 1) {
      var tries = trie[3];
      var levelCount = trie[1];
      var triesWidth = Curry._1(CopyOnWriteArray.count, tries);
      var firstChild = Curry._1(CopyOnWriteArray.firstOrRaise, tries);
      var match = removeFirstLeafUsingMutator(updateLevel, owner, firstChild);
      var newFirstChild = match[1];
      var firstLeaf = match[0];
      if (typeof newFirstChild === "number") {
        if (triesWidth > 2) {
          var newLevelCount = levelCount[0] - count(firstLeaf) | 0;
          var newTrie_001 = [newLevelCount];
          var newTrie_003 = CopyOnWriteArray.removeFirstOrRaise(tries);
          var newTrie = /* Level */Block.__(1, [
              levelDepth,
              newTrie_001,
              owner,
              newTrie_003
            ]);
          return /* tuple */[
                  firstLeaf,
                  newTrie
                ];
        } else {
          return /* tuple */[
                  firstLeaf,
                  Curry._1(CopyOnWriteArray.lastOrRaise, tries)
                ];
        }
      } else {
        var newLevelCount$1 = levelCount[0] - count(firstLeaf) | 0;
        return /* tuple */[
                firstLeaf,
                Curry._5(updateLevel, owner, newLevelCount$1, 0, newFirstChild, trie)
              ];
      }
    } else if (levelDepth !== 1) {
      return Pervasives.failwith("invalid state");
    } else {
      var tries$1 = trie[3];
      var triesWidth$1 = Curry._1(CopyOnWriteArray.count, tries$1);
      var firstChild$1 = Curry._1(CopyOnWriteArray.firstOrRaise, tries$1);
      if (triesWidth$1 > 2) {
        var newLevelCount$2 = trie[1][0] - count(firstChild$1) | 0;
        return /* tuple */[
                firstChild$1,
                /* Level */Block.__(1, [
                    1,
                    [newLevelCount$2],
                    owner,
                    CopyOnWriteArray.removeFirstOrRaise(tries$1)
                  ])
              ];
      } else {
        return /* tuple */[
                firstChild$1,
                Curry._1(CopyOnWriteArray.lastOrRaise, tries$1)
              ];
      }
    }
  } else {
    return /* tuple */[
            trie,
            /* Empty */0
          ];
  }
}

function removeLastLeafUsingMutator(updateLevel, owner, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    var levelDepth = trie[0];
    if (levelDepth > 1) {
      var tries = trie[3];
      var levelCount = trie[1];
      var triesWidth = Curry._1(CopyOnWriteArray.count, tries);
      var lastChildIndex = CopyOnWriteArray.lastIndexOrRaise(tries);
      var lastChild = Curry._1(CopyOnWriteArray.lastOrRaise, tries);
      var match = removeLastLeafUsingMutator(updateLevel, owner, lastChild);
      var lastLeaf = match[1];
      var newLastChild = match[0];
      if (typeof newLastChild === "number") {
        if (triesWidth > 2) {
          var newLevelCount = levelCount[0] - count(lastLeaf) | 0;
          var newTrie_001 = [newLevelCount];
          var newTrie_003 = CopyOnWriteArray.removeLastOrRaise(tries);
          var newTrie = /* Level */Block.__(1, [
              levelDepth,
              newTrie_001,
              owner,
              newTrie_003
            ]);
          return /* tuple */[
                  newTrie,
                  lastLeaf
                ];
        } else {
          return /* tuple */[
                  Curry._1(CopyOnWriteArray.firstOrRaise, tries),
                  lastLeaf
                ];
        }
      } else {
        var newLevelCount$1 = levelCount[0] - count(lastLeaf) | 0;
        return /* tuple */[
                Curry._5(updateLevel, owner, newLevelCount$1, lastChildIndex, newLastChild, trie),
                lastLeaf
              ];
      }
    } else if (levelDepth !== 1) {
      return Pervasives.failwith("invalid state");
    } else {
      var tries$1 = trie[3];
      var triesWidth$1 = Curry._1(CopyOnWriteArray.count, tries$1);
      var lastChild$1 = Curry._1(CopyOnWriteArray.lastOrRaise, tries$1);
      if (triesWidth$1 > 2) {
        var newLevelCount$2 = trie[1][0] - count(lastChild$1) | 0;
        return /* tuple */[
                /* Level */Block.__(1, [
                    1,
                    [newLevelCount$2],
                    owner,
                    CopyOnWriteArray.removeLastOrRaise(tries$1)
                  ]),
                lastChild$1
              ];
      } else {
        return /* tuple */[
                Curry._1(CopyOnWriteArray.firstOrRaise, tries$1),
                lastChild$1
              ];
      }
    }
  } else {
    return /* tuple */[
            /* Empty */0,
            trie
          ];
  }
}

function computeIndexUsingRadixSearch(depth, index) {
  var mask = 31;
  var level = Caml_int32.imul(depth, 5);
  return (index >>> level) & mask;
}

function canRadixSearch(trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    var childCapacity = depthCapacity(trie[0] - 1 | 0);
    var triesCount = Curry._1(CopyOnWriteArray.count, trie[3]);
    return +(trie[1][0] === Caml_int32.imul(triesCount, childCapacity));
  } else {
    return /* true */1;
  }
}

function computeLevelIndexUsingRadixSearch(index, f, trie) {
  if (typeof trie === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            313,
            4
          ]
        ];
  } else if (trie.tag) {
    var childIndex = computeIndexUsingRadixSearch(trie[0], index);
    return Curry._3(f, trie, index, childIndex);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            313,
            4
          ]
        ];
  }
}

function computeLevelIndexUsingCountSearch(index, f, trie) {
  if (typeof trie === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            321,
            4
          ]
        ];
  } else if (trie.tag) {
    var tries = trie[3];
    var _index = index;
    var _childIndex = 0;
    while(true) {
      var childIndex = _childIndex;
      var index$1 = _index;
      var childNode = Caml_array.caml_array_get(tries, childIndex);
      var childCount = count(childNode);
      if (index$1 < childCount) {
        return Curry._3(f, trie, index$1, childIndex);
      } else {
        _childIndex = childIndex + 1 | 0;
        _index = index$1 - childCount | 0;
        continue ;
        
      }
    };
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            321,
            4
          ]
        ];
  }
}

function getImplLevelContinuation(get, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            335,
            4
          ]
        ];
  } else if (param.tag) {
    var tries = param[3];
    return (function (effectiveIndex, childIndex) {
        var childNode = Curry._2(CopyOnWriteArray.getOrRaise, childIndex, tries);
        return Curry._2(get, effectiveIndex, childNode);
      });
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            335,
            4
          ]
        ];
  }
}

function getImpl(computeLevelIndex, get, index, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return Curry._3(computeLevelIndex, index, (function (param) {
                  return getImplLevelContinuation(get, param);
                }), trie);
  } else {
    return Caml_array.caml_array_get(trie[1], computeIndexUsingRadixSearch(0, index));
  }
}

function getUsingRadixSearch(index, trie) {
  return getImpl(computeLevelIndexUsingRadixSearch, getUsingRadixSearch, index, trie);
}

function get(index, trie) {
  if (typeof trie === "number" || !trie.tag || canRadixSearch(trie)) {
    return getUsingRadixSearch(index, trie);
  } else {
    return getImpl(computeLevelIndexUsingCountSearch, get, index, trie);
  }
}

function skipImpl(computeLevelIndex, skip, owner, skipCount, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return Curry._3(computeLevelIndex, skipCount - 1 | 0, (function (param) {
                  if (typeof param === "number") {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            384,
                            46
                          ]
                        ];
                  } else if (param.tag) {
                    var tries = param[3];
                    var depth = param[0];
                    return (function (effectiveIndex, childIndex) {
                        var childNode = Caml_array.caml_array_get(tries, childIndex);
                        var childResult = Curry._3(skip, owner, effectiveIndex + 1 | 0, childNode);
                        var newChildNode = childResult[1];
                        var tail = childResult[0];
                        var triesLastIndex = CopyOnWriteArray.lastIndexOrRaise(tries);
                        if (typeof newChildNode === "number") {
                          if (childIndex === triesLastIndex) {
                            return childResult;
                          } else if (childIndex === (triesLastIndex - 1 | 0)) {
                            return /* tuple */[
                                    tail,
                                    Curry._1(CopyOnWriteArray.lastOrRaise, tries)
                                  ];
                          } else {
                            var newTries = CopyOnWriteArray.skip(childIndex + 1 | 0, tries);
                            var levelCount = Curry._4(CopyOnWriteArray.reduce, /* None */0, (function (acc, next) {
                                    return acc + count(next) | 0;
                                  }), 0, newTries);
                            return /* tuple */[
                                    tail,
                                    /* Level */Block.__(1, [
                                        depth,
                                        [levelCount],
                                        owner,
                                        newTries
                                      ])
                                  ];
                          }
                        } else if (newChildNode.tag) {
                          var newTries$1 = CopyOnWriteArray.skip(childIndex, tries);
                          Caml_array.caml_array_set(newTries$1, 0, newChildNode);
                          var levelCount$1 = Curry._4(CopyOnWriteArray.reduce, /* None */0, (function (acc, next) {
                                  return acc + count(next) | 0;
                                }), 0, newTries$1);
                          return /* tuple */[
                                  tail,
                                  /* Level */Block.__(1, [
                                      depth,
                                      [levelCount$1],
                                      owner,
                                      newTries$1
                                    ])
                                ];
                        } else {
                          var newTries$2 = CopyOnWriteArray.skip(childIndex, tries);
                          Caml_array.caml_array_set(newTries$2, 0, newChildNode);
                          var levelCount$2 = Curry._4(CopyOnWriteArray.reduce, /* None */0, (function (acc, next) {
                                  return acc + count(next) | 0;
                                }), 0, newTries$2);
                          return /* tuple */[
                                  tail,
                                  /* Level */Block.__(1, [
                                      depth,
                                      [levelCount$2],
                                      owner,
                                      newTries$2
                                    ])
                                ];
                        }
                      });
                  } else {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            384,
                            46
                          ]
                        ];
                  }
                }), trie);
  } else {
    var skipCount$1 = computeIndexUsingRadixSearch(0, skipCount - 1 | 0) + 1 | 0;
    var result = CopyOnWriteArray.skip(skipCount$1, trie[1]);
    return /* tuple */[
            result,
            /* Empty */0
          ];
  }
}

function skipUsingRadixSearch(owner, skipCount, trie) {
  return skipImpl(computeLevelIndexUsingRadixSearch, skipUsingRadixSearch, owner, skipCount, trie);
}

function skip(owner, count, trie) {
  if (typeof trie === "number" || !trie.tag || canRadixSearch(trie)) {
    return skipUsingRadixSearch(owner, count, trie);
  } else {
    return skipImpl(computeLevelIndexUsingCountSearch, skip, owner, count, trie);
  }
}

function takeImpl(computeLevelIndex, take, owner, takeCount, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return Curry._3(computeLevelIndex, takeCount - 1 | 0, (function (param) {
                  if (typeof param === "number") {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            453,
                            46
                          ]
                        ];
                  } else if (param.tag) {
                    var tries = param[3];
                    var depth = param[0];
                    return (function (effectiveIndex, childIndex) {
                        var childNode = Caml_array.caml_array_get(tries, childIndex);
                        var childResult = Curry._3(take, owner, effectiveIndex + 1 | 0, childNode);
                        var tail = childResult[1];
                        var newChildNode = childResult[0];
                        if (typeof newChildNode === "number") {
                          if (childIndex) {
                            if (childIndex === 1) {
                              return /* tuple */[
                                      Caml_array.caml_array_get(tries, 0),
                                      tail
                                    ];
                            } else {
                              var newTries = CopyOnWriteArray.take(childIndex, tries);
                              var levelCount = Curry._4(CopyOnWriteArray.reduce, /* None */0, (function (acc, next) {
                                      return acc + count(next) | 0;
                                    }), 0, newTries);
                              return /* tuple */[
                                      /* Level */Block.__(1, [
                                          depth,
                                          [levelCount],
                                          owner,
                                          newTries
                                        ]),
                                      tail
                                    ];
                            }
                          } else {
                            return childResult;
                          }
                        } else {
                          var newTries$1 = CopyOnWriteArray.take(childIndex + 1 | 0, tries);
                          Caml_array.caml_array_set(newTries$1, childIndex, newChildNode);
                          var levelCount$1 = Curry._4(CopyOnWriteArray.reduce, /* None */0, (function (acc, next) {
                                  return acc + count(next) | 0;
                                }), 0, newTries$1);
                          return /* tuple */[
                                  /* Level */Block.__(1, [
                                      depth,
                                      [levelCount$1],
                                      owner,
                                      newTries$1
                                    ]),
                                  tail
                                ];
                        }
                      });
                  } else {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            453,
                            46
                          ]
                        ];
                  }
                }), trie);
  } else {
    var takeCount$1 = computeIndexUsingRadixSearch(0, takeCount - 1 | 0) + 1 | 0;
    var result = CopyOnWriteArray.take(takeCount$1, trie[1]);
    return /* tuple */[
            /* Empty */0,
            result
          ];
  }
}

function takeUsingRadixSearch(owner, takeCount, trie) {
  return takeImpl(computeLevelIndexUsingRadixSearch, takeUsingRadixSearch, owner, takeCount, trie);
}

function take(owner, count, trie) {
  if (typeof trie === "number" || !trie.tag || canRadixSearch(trie)) {
    return takeUsingRadixSearch(owner, count, trie);
  } else {
    return takeImpl(computeLevelIndexUsingCountSearch, take, owner, count, trie);
  }
}

function updateUsingMutatorImpl(computeLevelIndex, updateUsingMutator, updateLevel, updateLeaf, owner, index, value, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return Curry._3(computeLevelIndex, index, (function (param) {
                  if (typeof param === "number") {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            521,
                            38
                          ]
                        ];
                  } else if (param.tag) {
                    var tries = param[3];
                    var count = param[1];
                    return (function (index, childIndex) {
                        var childNode = Curry._2(CopyOnWriteArray.getOrRaise, childIndex, tries);
                        var newChildNode = Curry._6(updateUsingMutator, updateLevel, updateLeaf, owner, index, value, childNode);
                        if (childNode === newChildNode) {
                          return trie;
                        } else {
                          return Curry._5(updateLevel, owner, count[0], childIndex, newChildNode, trie);
                        }
                      });
                  } else {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            521,
                            38
                          ]
                        ];
                  }
                }), trie);
  } else {
    return Curry._4(updateLeaf, owner, computeIndexUsingRadixSearch(0, index), value, trie);
  }
}

function updateUsingRadixSearchUsingMutator(updateLevel, updateLeaf, owner, index, value, trie) {
  return updateUsingMutatorImpl(computeLevelIndexUsingRadixSearch, updateUsingRadixSearchUsingMutator, updateLevel, updateLeaf, owner, index, value, trie);
}

function updateUsingMutator(updateLevel, updateLeaf, owner, index, value, trie) {
  var exit = 0;
  if (typeof trie === "number") {
    exit = 1;
  } else if (trie.tag) {
    if (canRadixSearch(trie)) {
      exit = 1;
    } else {
      return updateUsingMutatorImpl(computeLevelIndexUsingCountSearch, updateUsingMutator, updateLevel, updateLeaf, owner, index, value, trie);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return updateUsingRadixSearchUsingMutator(updateLevel, updateLeaf, owner, index, value, trie);
  }
  
}

function updateAllUsingMutator(updateLevel, updateLeaf, owner, f, trie) {
  if (typeof trie === "number") {
    return /* Empty */0;
  } else if (trie.tag) {
    var tries = trie[3];
    var count = trie[1];
    var triesCount = Curry._1(CopyOnWriteArray.count, tries);
    var _index = 0;
    var _trie = trie;
    while(true) {
      var trie$1 = _trie;
      var index = _index;
      if (index < triesCount) {
        var childNode = Caml_array.caml_array_get(tries, index);
        var newChildNode = updateAllUsingMutator(updateLevel, updateLeaf, owner, f, childNode);
        var newTrie = childNode === newChildNode ? trie$1 : Curry._5(updateLevel, owner, count[0], index, newChildNode, trie$1);
        _trie = newTrie;
        _index = index + 1 | 0;
        continue ;
        
      } else {
        return trie$1;
      }
    };
  } else {
    var values = trie[1];
    var valuesCount = Curry._1(CopyOnWriteArray.count, values);
    var _index$1 = 0;
    var _trie$1 = trie;
    while(true) {
      var trie$2 = _trie$1;
      var index$1 = _index$1;
      if (index$1 < valuesCount) {
        var newValue = Curry._1(f, Caml_array.caml_array_get(values, index$1));
        var newTrie$1 = Curry._4(updateLeaf, owner, index$1, newValue, trie$2);
        _trie$1 = newTrie$1;
        _index$1 = index$1 + 1 | 0;
        continue ;
        
      } else {
        return trie$2;
      }
    };
  }
}

function updateWithUsingMutatorImpl(computeLevelIndex, updateWithUsingMutator, updateLevel, updateLeaf, owner, index, f, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("invalid state");
  } else if (trie.tag) {
    return Curry._3(computeLevelIndex, index, (function (param) {
                  if (typeof param === "number") {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            630,
                            38
                          ]
                        ];
                  } else if (param.tag) {
                    var tries = param[3];
                    var count = param[1];
                    return (function (index, childIndex) {
                        var childNode = Curry._2(CopyOnWriteArray.getOrRaise, childIndex, tries);
                        var newChildNode = Curry._6(updateWithUsingMutator, updateLevel, updateLeaf, owner, index, f, childNode);
                        if (childNode === newChildNode) {
                          return trie;
                        } else {
                          return Curry._5(updateLevel, owner, count[0], childIndex, newChildNode, trie);
                        }
                      });
                  } else {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          [
                            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
                            630,
                            38
                          ]
                        ];
                  }
                }), trie);
  } else {
    var arrIndex = computeIndexUsingRadixSearch(0, index);
    var newValue = Curry._1(f, Caml_array.caml_array_get(trie[1], arrIndex));
    return Curry._4(updateLeaf, owner, arrIndex, newValue, trie);
  }
}

function updateWithUsingRadixSearchUsingMutator(updateLevel, updateLeaf, owner, index, f, trie) {
  return updateWithUsingMutatorImpl(computeLevelIndexUsingRadixSearch, updateWithUsingRadixSearchUsingMutator, updateLevel, updateLeaf, owner, index, f, trie);
}

function updateWithUsingMutator(updateLevel, updateLeaf, owner, index, f, trie) {
  var exit = 0;
  if (typeof trie === "number") {
    exit = 1;
  } else if (trie.tag) {
    if (canRadixSearch(trie)) {
      exit = 1;
    } else {
      return updateWithUsingMutatorImpl(computeLevelIndexUsingCountSearch, updateWithUsingMutator, updateLevel, updateLeaf, owner, index, f, trie);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return updateWithUsingRadixSearchUsingMutator(updateLevel, updateLeaf, owner, index, f, trie);
  }
  
}

function updateLevelPersistent(_, count, index, child, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            685,
            4
          ]
        ];
  } else if (param.tag) {
    return /* Level */Block.__(1, [
              param[0],
              [count],
              Transient.Owner[/* none */1],
              CopyOnWriteArray.update(index, child, param[3])
            ]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            685,
            4
          ]
        ];
  }
}

function updateLeafPersistent(_, index, value, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            692,
            4
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/IndexedTrie.re",
            692,
            4
          ]
        ];
  } else {
    return /* Leaf */Block.__(0, [
              Transient.Owner[/* none */1],
              CopyOnWriteArray.update(index, value, param[1])
            ]);
  }
}

function updateLevelTransient(owner, count, index, child, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("Invalid state");
  } else if (trie.tag) {
    var tries = trie[3];
    if (trie[2] === owner) {
      Caml_array.caml_array_set(tries, index, child);
      trie[1][0] = count;
      return trie;
    } else {
      return /* Level */Block.__(1, [
                trie[0],
                [count],
                owner,
                CopyOnWriteArray.update(index, child, tries)
              ]);
    }
  } else {
    return Pervasives.failwith("Invalid state");
  }
}

function updateLeafTransient(owner, index, value, trie) {
  if (typeof trie === "number") {
    return Pervasives.failwith("Invalid state");
  } else if (trie.tag) {
    return Pervasives.failwith("Invalid state");
  } else {
    var values = trie[1];
    if (trie[0] === owner) {
      Caml_array.caml_array_set(values, index, value);
      return trie;
    } else {
      return /* Leaf */Block.__(0, [
                owner,
                CopyOnWriteArray.update(index, value, values)
              ]);
    }
  }
}

function validate(trie) {
  if (typeof trie === "number") {
    return /* () */0;
  } else if (trie.tag) {
    var tries = trie[3];
    var levelDepth = trie[0];
    Pervasives.print_string("depth: ");
    Pervasives.print_int(levelDepth);
    Pervasives.print_newline(/* () */0);
    Pervasives.print_string("count: ");
    Pervasives.print_int(trie[1][0]);
    Pervasives.print_newline(/* () */0);
    Pervasives.print_string("triesWidth: ");
    Pervasives.print_int(Curry._1(CopyOnWriteArray.count, tries));
    Pervasives.print_newline(/* () */0);
    Pervasives.print_newline(/* () */0);
    var firstTrie = Curry._1(CopyOnWriteArray.firstOrRaise, tries);
    if (levelDepth !== (depth(firstTrie) + 1 | 0)) {
      Pervasives.failwith("parent level higher than child");
    }
    if (count(firstTrie) !== depthCapacity(depth(firstTrie))) {
      Pervasives.print_string("firstTrie count: ");
      Pervasives.print_int(count(firstTrie));
      Pervasives.print_newline(/* () */0);
      Pervasives.print_string("firstTrie capacity: ");
      Pervasives.print_int(depthCapacity(depth(firstTrie)));
      Pervasives.print_newline(/* () */0);
      Pervasives.failwith(" first Trie isn't full");
    }
    return Iterable.forEach(/* None */0, validate, Curry._1(CopyOnWriteArray.toIterable, tries));
  } else if (Curry._1(CopyOnWriteArray.count, trie[1]) !== 32) {
    return Pervasives.failwith("arr too small");
  } else {
    return 0;
  }
}

var bits = 5;

var width = 32;

var empty = /* Empty */0;

exports.bits                                   = bits;
exports.width                                  = width;
exports.count                                  = count;
exports.reduce                                 = reduce;
exports.reduceWhileWithResult                  = reduceWhileWithResult;
exports.reduceReversed                         = reduceReversed;
exports.reduceReversedWhileWithResult          = reduceReversedWhileWithResult;
exports.toSequence                             = toSequence;
exports.toSequenceReversed                     = toSequenceReversed;
exports.depth                                  = depth;
exports.depthCapacity                          = depthCapacity;
exports.capacity                               = capacity;
exports.childCapacity                          = childCapacity;
exports.empty                                  = empty;
exports.isEmpty                                = isEmpty;
exports.tryAddFirstLeafToTrieUsingMutator      = tryAddFirstLeafToTrieUsingMutator;
exports.addFirstLeafUsingMutator               = addFirstLeafUsingMutator;
exports.tryAddLastLeafToTrieUsingMutator       = tryAddLastLeafToTrieUsingMutator;
exports.addLastLeafUsingMutator                = addLastLeafUsingMutator;
exports.removeFirstLeafUsingMutator            = removeFirstLeafUsingMutator;
exports.removeLastLeafUsingMutator             = removeLastLeafUsingMutator;
exports.computeIndexUsingRadixSearch           = computeIndexUsingRadixSearch;
exports.canRadixSearch                         = canRadixSearch;
exports.computeLevelIndexUsingRadixSearch      = computeLevelIndexUsingRadixSearch;
exports.computeLevelIndexUsingCountSearch      = computeLevelIndexUsingCountSearch;
exports.getImplLevelContinuation               = getImplLevelContinuation;
exports.getImpl                                = getImpl;
exports.getUsingRadixSearch                    = getUsingRadixSearch;
exports.get                                    = get;
exports.skipImpl                               = skipImpl;
exports.skipUsingRadixSearch                   = skipUsingRadixSearch;
exports.skip                                   = skip;
exports.takeImpl                               = takeImpl;
exports.takeUsingRadixSearch                   = takeUsingRadixSearch;
exports.take                                   = take;
exports.updateUsingMutatorImpl                 = updateUsingMutatorImpl;
exports.updateUsingRadixSearchUsingMutator     = updateUsingRadixSearchUsingMutator;
exports.updateUsingMutator                     = updateUsingMutator;
exports.updateAllUsingMutator                  = updateAllUsingMutator;
exports.updateWithUsingMutatorImpl             = updateWithUsingMutatorImpl;
exports.updateWithUsingRadixSearchUsingMutator = updateWithUsingRadixSearchUsingMutator;
exports.updateWithUsingMutator                 = updateWithUsingMutator;
exports.updateLevelPersistent                  = updateLevelPersistent;
exports.updateLeafPersistent                   = updateLeafPersistent;
exports.updateLevelTransient                   = updateLevelTransient;
exports.updateLeafTransient                    = updateLeafTransient;
exports.validate                               = validate;
/* Sequence Not a pure module */


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry               = __webpack_require__(1);
var IntRange            = __webpack_require__(74);
var Sequence            = __webpack_require__(56);
var Pervasives          = __webpack_require__(2);
var NavigableMap        = __webpack_require__(77);
var Preconditions       = __webpack_require__(63);
var NavigableCollection = __webpack_require__(66);

function Make1(Base) {
  var count = Base[0];
  var getOrRaise = Base[1];
  var get = function (index, indexed) {
    return Preconditions.noneIfIndexOutOfRange(Curry._1(count, indexed), index, (function (param) {
                  return Curry._2(getOrRaise, param, indexed);
                }));
  };
  var getOrDefault = function ($$default, index, indexed) {
    if (index < 0 || index >= Curry._1(count, indexed)) {
      return $$default;
    } else {
      return Curry._2(getOrRaise, index, indexed);
    }
  };
  var count$1 = Base[0];
  var getOrRaise$1 = Base[1];
  var firstOrRaise = function (indexed) {
    return Curry._2(getOrRaise$1, 0, indexed);
  };
  var lastOrRaise = function (indexed) {
    var lastIndex = Curry._1(count$1, indexed) - 1 | 0;
    return Curry._2(getOrRaise$1, lastIndex, indexed);
  };
  var include = NavigableCollection.Make1(/* module */[
        /* count */count$1,
        /* firstOrRaise */firstOrRaise,
        /* lastOrRaise */lastOrRaise,
        /* reduce */Base[2],
        /* reduceReversed */Base[3],
        /* toSequence */Base[4],
        /* toSequenceReversed */Base[5]
      ]);
  var count$2 = include[8];
  var isEmpty = include[9];
  var toSequence = include[12];
  var toSequenceReversed = include[23];
  var containsKey = function (index, indexed) {
    if (index >= 0) {
      return +(index < Curry._1(count$2, indexed));
    } else {
      return /* false */0;
    }
  };
  var firstOrRaise$1 = function (selector, indexed) {
    if (Curry._1(count$2, indexed) > 0) {
      return Curry._2(selector, 0, Curry._2(getOrRaise, 0, indexed));
    } else {
      return Pervasives.failwith("empty");
    }
  };
  var lastOrRaise$1 = function (selector, indexed) {
    var lastIndex = Curry._1(count$2, indexed) - 1 | 0;
    if (lastIndex >= 0) {
      return Curry._2(selector, lastIndex, Curry._2(getOrRaise, lastIndex, indexed));
    } else {
      return Pervasives.failwith("empty");
    }
  };
  var reduceValues = Base[/* reduce */2];
  var reduceValuesReversed = Base[/* reduceReversed */3];
  var reduce = function (predicate, f, acc, indexed) {
    var index = [0];
    var predicate$1 = function (acc, next) {
      return Curry._3(predicate, acc, index[0], next);
    };
    var reducer = function (acc, next) {
      var acc$1 = Curry._3(f, acc, index[0], next);
      index[0] = index[0] + 1 | 0;
      return acc$1;
    };
    return Curry._4(Base[/* reduce */2], predicate$1, reducer, acc, indexed);
  };
  var reduceReversed = function (predicate, f, acc, indexed) {
    var index = [Curry._1(count$2, indexed) - 1 | 0];
    var predicate$1 = function (acc, next) {
      return Curry._3(predicate, acc, index[0], next);
    };
    var reducer = function (acc, next) {
      var acc$1 = Curry._3(f, acc, index[0], next);
      index[0] = index[0] - 1 | 0;
      return acc$1;
    };
    return Curry._4(Base[/* reduceReversed */3], predicate$1, reducer, acc, indexed);
  };
  var reduceKeys = function (predicate, f, acc, indexed) {
    return Curry._4(IntRange.reduce, /* Some */[predicate], f, acc, IntRange.create(0, Curry._1(count$2, indexed)));
  };
  var reduceKeysReversed = function (predicate, f, acc, indexed) {
    return Curry._4(IntRange.reduceReversed, /* Some */[predicate], f, acc, IntRange.create(0, Curry._1(count$2, indexed)));
  };
  var toSequence$1 = function (selector, indexed) {
    var partial_arg = Curry._1(Base[/* toSequence */4], indexed);
    var partial_arg$1 = Curry._1(IntRange.toSequence, IntRange.create(0, Curry._1(count$2, indexed)));
    return (function (param) {
        return Sequence.zip2With(selector, partial_arg$1, partial_arg, param);
      });
  };
  var toSequenceReversed$1 = function (selector, indexed) {
    var partial_arg = Curry._1(Base[/* toSequenceReversed */5], indexed);
    var partial_arg$1 = Curry._1(IntRange.toSequenceReversed, IntRange.create(0, Curry._1(count$2, indexed)));
    return (function (param) {
        return Sequence.zip2With(selector, partial_arg$1, partial_arg, param);
      });
  };
  var NavigableMap$1 = NavigableMap.Make1(/* module */[
        /* containsKey */containsKey,
        /* count */count$2,
        /* firstOrRaise */firstOrRaise$1,
        /* get */get,
        /* getOrDefault */getOrDefault,
        /* getOrRaise */getOrRaise,
        /* lastOrRaise */lastOrRaise$1,
        /* reduce */reduce,
        /* reduceReversed */reduceReversed,
        /* reduceKeys */reduceKeys,
        /* reduceKeysReversed */reduceKeysReversed,
        /* reduceValues */reduceValues,
        /* reduceValuesReversed */reduceValuesReversed,
        /* toSequence */toSequence$1,
        /* toSequenceReversed */toSequenceReversed$1
      ]);
  var toKeyedCollection = NavigableMap$1[/* toKeyedCollection */46];
  var toKeyedCollectionReversed = NavigableMap$1[/* toKeyedCollectionReversed */15];
  var toKeyedIterable = NavigableMap$1[/* toKeyedIterable */38];
  var toKeyedIterableReversed = NavigableMap$1[/* toKeyedIterableReversed */16];
  var toMap = NavigableMap$1[/* toMap */53];
  var toMapReversed = NavigableMap$1[/* toMapReversed */57];
  var toNavigableKeyedCollection = NavigableMap$1[/* toNavigableKeyedCollection */17];
  var toNavigableKeyedCollectionReversed = NavigableMap$1[/* toNavigableKeyedCollectionReversed */18];
  var toNavigableMap = NavigableMap$1[/* toNavigableMap */58];
  var toNavigableMapReversed = NavigableMap$1[/* toNavigableMapReversed */59];
  var indexedBase_002 = /* reduce */Base[/* reduce */2];
  var indexedBase = /* record */[
    /* count */count$2,
    /* getOrRaise */getOrRaise,
    indexedBase_002,
    /* toSequence */toSequence
  ];
  var indexedReversedBase_001 = function (i, indexed) {
    return Curry._2(getOrRaise, (Curry._1(count$2, indexed) - i | 0) - 1 | 0, indexed);
  };
  var indexedReversedBase_002 = /* reduce */Base[/* reduceReversed */3];
  var indexedReversedBase = /* record */[
    /* count */count$2,
    indexedReversedBase_001,
    indexedReversedBase_002,
    /* toSequence */toSequenceReversed
  ];
  var toIndexed = function (indexed) {
    if (Curry._1(isEmpty, indexed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              indexed,
              indexedBase,
              indexedReversedBase
            ];
    }
  };
  var toIndexedReversed = function (indexed) {
    if (Curry._1(isEmpty, indexed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              indexed,
              indexedReversedBase,
              indexedBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* none */include[4],
          /* reduce */include[5],
          /* some */include[6],
          /* toIterable */include[7],
          /* count */count$2,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[10],
          /* toCollection */include[11],
          /* toSequence */toSequence,
          /* first */include[13],
          /* firstOrRaise */include[14],
          /* toSequentialCollection */include[15],
          /* last */include[16],
          /* lastOrRaise */include[17],
          /* reduceReversed */include[18],
          /* toCollectionReversed */include[19],
          /* toIterableReversed */include[20],
          /* toNavigableCollection */include[21],
          /* toNavigableCollectionReversed */include[22],
          /* toSequenceReversed */toSequenceReversed,
          /* toSequentialCollectionReversed */include[24],
          /* get */get,
          /* getOrDefault */getOrDefault,
          /* getOrRaise */getOrRaise,
          /* toIndexed */toIndexed,
          /* toIndexedReversed */toIndexedReversed,
          /* toKeyedCollection */toKeyedCollection,
          /* toKeyedCollectionReversed */toKeyedCollectionReversed,
          /* toKeyedIterable */toKeyedIterable,
          /* toKeyedIterableReversed */toKeyedIterableReversed,
          /* toMap */toMap,
          /* toMapReversed */toMapReversed,
          /* toNavigableKeyedCollection */toNavigableKeyedCollection,
          /* toNavigableKeyedCollectionReversed */toNavigableKeyedCollectionReversed,
          /* toNavigableMap */toNavigableMap,
          /* toNavigableMapReversed */toNavigableMapReversed
        ];
}

function count(indexed) {
  if (indexed) {
    return Curry._1(indexed[1][/* count */0], indexed[0]);
  } else {
    return 0;
  }
}

function getOrRaise(index, indexed) {
  if (indexed) {
    return Curry._2(indexed[1][/* getOrRaise */1], index, indexed[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[1][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function reduceReversed(predicate, f, acc, collection) {
  if (collection) {
    return Curry._4(collection[2][/* reduce */2], predicate, f, acc, collection[0]);
  } else {
    return acc;
  }
}

function toSequence(indexed) {
  if (indexed) {
    return Curry._1(indexed[1][/* toSequence */3], indexed[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function toSequenceReversed(indexed) {
  if (indexed) {
    return Curry._1(indexed[2][/* toSequence */3], indexed[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function get(index, indexed) {
  return Preconditions.noneIfIndexOutOfRange(count(indexed), index, (function (param) {
                return getOrRaise(param, indexed);
              }));
}

function getOrDefault($$default, index, indexed) {
  if (index < 0 || index >= count(indexed)) {
    return $$default;
  } else {
    return getOrRaise(index, indexed);
  }
}

function firstOrRaise(indexed) {
  return getOrRaise(0, indexed);
}

function lastOrRaise(indexed) {
  var lastIndex = count(indexed) - 1 | 0;
  return getOrRaise(lastIndex, indexed);
}

var include = NavigableCollection.Make1(/* module */[
      /* count */count,
      /* firstOrRaise */firstOrRaise,
      /* lastOrRaise */lastOrRaise,
      /* reduce */reduce,
      /* reduceReversed */reduceReversed,
      /* toSequence */toSequence,
      /* toSequenceReversed */toSequenceReversed
    ]);

var count$1 = include[8];

var isEmpty = include[9];

var toSequence$1 = include[12];

var toSequenceReversed$1 = include[23];

function containsKey(index, indexed) {
  if (index >= 0) {
    return +(index < Curry._1(count$1, indexed));
  } else {
    return /* false */0;
  }
}

function firstOrRaise$1(selector, indexed) {
  if (Curry._1(count$1, indexed) > 0) {
    return Curry._2(selector, 0, getOrRaise(0, indexed));
  } else {
    return Pervasives.failwith("empty");
  }
}

function lastOrRaise$1(selector, indexed) {
  var lastIndex = Curry._1(count$1, indexed) - 1 | 0;
  if (lastIndex >= 0) {
    return Curry._2(selector, lastIndex, getOrRaise(lastIndex, indexed));
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce$1(predicate, f, acc, indexed) {
  var index = [0];
  var predicate$1 = function (acc, next) {
    return Curry._3(predicate, acc, index[0], next);
  };
  var reducer = function (acc, next) {
    var acc$1 = Curry._3(f, acc, index[0], next);
    index[0] = index[0] + 1 | 0;
    return acc$1;
  };
  return reduce(predicate$1, reducer, acc, indexed);
}

function reduceReversed$1(predicate, f, acc, indexed) {
  var index = [Curry._1(count$1, indexed) - 1 | 0];
  var predicate$1 = function (acc, next) {
    return Curry._3(predicate, acc, index[0], next);
  };
  var reducer = function (acc, next) {
    var acc$1 = Curry._3(f, acc, index[0], next);
    index[0] = index[0] - 1 | 0;
    return acc$1;
  };
  return reduceReversed(predicate$1, reducer, acc, indexed);
}

function reduceKeys(predicate, f, acc, indexed) {
  return Curry._4(IntRange.reduce, /* Some */[predicate], f, acc, IntRange.create(0, Curry._1(count$1, indexed)));
}

function reduceKeysReversed(predicate, f, acc, indexed) {
  return Curry._4(IntRange.reduceReversed, /* Some */[predicate], f, acc, IntRange.create(0, Curry._1(count$1, indexed)));
}

function toSequence$2(selector, indexed) {
  var partial_arg = toSequence(indexed);
  var partial_arg$1 = Curry._1(IntRange.toSequence, IntRange.create(0, Curry._1(count$1, indexed)));
  return (function (param) {
      return Sequence.zip2With(selector, partial_arg$1, partial_arg, param);
    });
}

function toSequenceReversed$2(selector, indexed) {
  var partial_arg = toSequenceReversed(indexed);
  var partial_arg$1 = Curry._1(IntRange.toSequenceReversed, IntRange.create(0, Curry._1(count$1, indexed)));
  return (function (param) {
      return Sequence.zip2With(selector, partial_arg$1, partial_arg, param);
    });
}

var NavigableMap$1 = NavigableMap.Make1(/* module */[
      /* containsKey */containsKey,
      /* count */count$1,
      /* firstOrRaise */firstOrRaise$1,
      /* get */get,
      /* getOrDefault */getOrDefault,
      /* getOrRaise */getOrRaise,
      /* lastOrRaise */lastOrRaise$1,
      /* reduce */reduce$1,
      /* reduceReversed */reduceReversed$1,
      /* reduceKeys */reduceKeys,
      /* reduceKeysReversed */reduceKeysReversed,
      /* reduceValues */reduce,
      /* reduceValuesReversed */reduceReversed,
      /* toSequence */toSequence$2,
      /* toSequenceReversed */toSequenceReversed$2
    ]);

var toKeyedCollection = NavigableMap$1[/* toKeyedCollection */46];

var toKeyedCollectionReversed = NavigableMap$1[/* toKeyedCollectionReversed */15];

var toKeyedIterable = NavigableMap$1[/* toKeyedIterable */38];

var toKeyedIterableReversed = NavigableMap$1[/* toKeyedIterableReversed */16];

var toMap = NavigableMap$1[/* toMap */53];

var toMapReversed = NavigableMap$1[/* toMapReversed */57];

var toNavigableKeyedCollection = NavigableMap$1[/* toNavigableKeyedCollection */17];

var toNavigableKeyedCollectionReversed = NavigableMap$1[/* toNavigableKeyedCollectionReversed */18];

var toNavigableMap = NavigableMap$1[/* toNavigableMap */58];

var toNavigableMapReversed = NavigableMap$1[/* toNavigableMapReversed */59];

var indexedBase = /* record */[
  /* count */count$1,
  /* getOrRaise */getOrRaise,
  /* reduce */reduce,
  /* toSequence */toSequence$1
];

function indexedReversedBase_001(i, indexed) {
  return getOrRaise((Curry._1(count$1, indexed) - i | 0) - 1 | 0, indexed);
}

var indexedReversedBase = /* record */[
  /* count */count$1,
  indexedReversedBase_001,
  /* reduce */reduceReversed,
  /* toSequence */toSequenceReversed$1
];

function toIndexedReversed(indexed) {
  if (Curry._1(isEmpty, indexed)) {
    return /* Empty */0;
  } else {
    return /* Instance */[
            indexed,
            indexedReversedBase,
            indexedBase
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toIndexed(indexed) {
  return indexed;
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$2 = include[5];

var some = include[6];

var toIterable = include[7];

var isNotEmpty = include[10];

var toCollection = include[11];

var first = include[13];

var firstOrRaise$2 = include[14];

var toSequentialCollection = include[15];

var last = include[16];

var lastOrRaise$2 = include[17];

var reduceReversed$2 = include[18];

var toCollectionReversed = include[19];

var toIterableReversed = include[20];

var toNavigableCollection = include[21];

var toNavigableCollectionReversed = include[22];

var toSequentialCollectionReversed = include[24];

exports.Make1                              = Make1;
exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.none                               = none;
exports.reduce                             = reduce$2;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.count                              = count$1;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.toCollection                       = toCollection;
exports.toSequence                         = toSequence$1;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise$2;
exports.toSequentialCollection             = toSequentialCollection;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise$2;
exports.reduceReversed                     = reduceReversed$2;
exports.toCollectionReversed               = toCollectionReversed;
exports.toIterableReversed                 = toIterableReversed;
exports.toNavigableCollection              = toNavigableCollection;
exports.toNavigableCollectionReversed      = toNavigableCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed$1;
exports.toSequentialCollectionReversed     = toSequentialCollectionReversed;
exports.get                                = get;
exports.getOrDefault                       = getOrDefault;
exports.getOrRaise                         = getOrRaise;
exports.toIndexedReversed                  = toIndexedReversed;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterable                    = toKeyedIterable;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toMap                              = toMap;
exports.toMapReversed                      = toMapReversed;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toNavigableMap                     = toNavigableMap;
exports.toNavigableMapReversed             = toNavigableMapReversed;
exports.empty                              = empty;
exports.toIndexed                          = toIndexed;
/* include Not a pure module */


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                    = __webpack_require__(1);
var ImmMap                   = __webpack_require__(71);
var Sequence                 = __webpack_require__(56);
var Functions                = __webpack_require__(55);
var Pervasives               = __webpack_require__(2);
var KeyedReducer             = __webpack_require__(62);
var NavigableSet             = __webpack_require__(68);
var NavigableKeyedCollection = __webpack_require__(82);

function Make1(Base) {
  var include = ImmMap.Make1([
        Base[0],
        Base[1],
        Base[3],
        Base[4],
        Base[5],
        Base[7],
        Base[9],
        Base[11],
        Base[13]
      ]);
  var get = include[23];
  var getOrDefault = include[24];
  var getOrRaise = include[25];
  var include$1 = NavigableKeyedCollection.Make1([
        Base[0],
        Base[1],
        Base[2],
        Base[6],
        Base[7],
        Base[8],
        Base[9],
        Base[10],
        Base[11],
        Base[12],
        Base[13],
        Base[14]
      ]);
  var containsKey = include$1[13];
  var count = include$1[14];
  var isEmpty = include$1[15];
  var keysSequence = include$1[18];
  var toSequence = include$1[20];
  var firstOrRaise = include$1[24];
  var keysSequenceReversed = include$1[31];
  var lastOrRaise = include$1[33];
  var toSequenceReversed = include$1[42];
  var reduce = Base[/* reduceReversed */8];
  var reduceKeys = Base[/* reduceKeysReversed */10];
  var reduceValues = Base[/* reduceValuesReversed */12];
  var ReversedImmMap = ImmMap.Make1(/* module */[
        /* containsKey */containsKey,
        /* count */count,
        /* get */get,
        /* getOrDefault */getOrDefault,
        /* getOrRaise */getOrRaise,
        /* reduce */reduce,
        /* reduceKeys */reduceKeys,
        /* reduceValues */reduceValues,
        /* toSequence */toSequenceReversed
      ]);
  var toMapReversed = ReversedImmMap[/* toMap */27];
  var firstKeyOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getKey, collection);
  };
  var lastKeyOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getKey, collection);
  };
  var keysNavigableSetImpl_003 = /* reduce */Base[/* reduceKeys */9];
  var keysNavigableSetImpl = /* record */[
    /* contains */containsKey,
    /* count */count,
    /* firstOrRaise */firstKeyOrRaise,
    keysNavigableSetImpl_003,
    /* toSequence */keysSequence
  ];
  var keysNavigableSetReversedImpl_003 = /* reduce */Base[/* reduceKeysReversed */10];
  var keysNavigableSetReversedImpl = /* record */[
    /* contains */containsKey,
    /* count */count,
    /* firstOrRaise */lastKeyOrRaise,
    keysNavigableSetReversedImpl_003,
    /* toSequence */keysSequenceReversed
  ];
  var keysNavigableSet = function (map) {
    if (Curry._1(isEmpty, map)) {
      return NavigableSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysNavigableSetImpl,
              keysNavigableSetReversedImpl
            ];
    }
  };
  var keysNavigableSetReversed = function (map) {
    if (Curry._1(isEmpty, map)) {
      return NavigableSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysNavigableSetReversedImpl,
              keysNavigableSetImpl
            ];
    }
  };
  var sequentialMapImpl_006 = /* reduce */Base[/* reduce */7];
  var sequentialMapImpl = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    sequentialMapImpl_006,
    /* toSequence */toSequence
  ];
  var sequentialMapReversedImpl_006 = /* reduce */Base[/* reduceReversed */8];
  var sequentialMapReversedImpl = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    sequentialMapReversedImpl_006,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableMap = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              sequentialMapImpl,
              sequentialMapReversedImpl
            ];
    }
  };
  var toNavigableMapReversed = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              sequentialMapReversedImpl,
              sequentialMapImpl
            ];
    }
  };
  return /* module */[
          /* first */include$1[23],
          /* firstOrRaise */firstOrRaise,
          /* keysCollectionReversed */include$1[25],
          /* keysNavigableCollection */include$1[26],
          /* keysNavigableCollectionReversed */include$1[27],
          /* keysReversed */include$1[28],
          /* keysSequentialCollection */include$1[29],
          /* keysSequentialCollectionReversed */include$1[30],
          /* keysSequenceReversed */keysSequenceReversed,
          /* last */include$1[32],
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */include$1[34],
          /* reduceKeysReversed */include$1[35],
          /* reduceValuesReversed */include$1[36],
          /* toIterableReversed */include$1[37],
          /* toKeyedCollectionReversed */include$1[38],
          /* toKeyedIterableReversed */include$1[39],
          /* toNavigableKeyedCollection */include$1[40],
          /* toNavigableKeyedCollectionReversed */include$1[41],
          /* toSequenceReversed */toSequenceReversed,
          /* valuesCollectionReversed */include$1[43],
          /* valuesNavigableCollection */include$1[44],
          /* valuesNavigableCollectionReversed */include$1[45],
          /* valuesReversed */include$1[46],
          /* valuesSequentialCollection */include$1[47],
          /* valuesSequentialCollectionReversed */include$1[48],
          /* valuesSequenceReversed */include$1[49],
          /* every */include$1[0],
          /* find */include$1[1],
          /* findOrRaise */include$1[2],
          /* forEach */include$1[3],
          /* keys */include$1[4],
          /* none */include$1[5],
          /* reduce */include$1[6],
          /* reduceKeys */include$1[7],
          /* reduceValues */include$1[8],
          /* some */include$1[9],
          /* toIterable */include$1[10],
          /* toKeyedIterable */include$1[11],
          /* values */include$1[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include$1[16],
          /* keysCollection */include$1[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include$1[19],
          /* toSequence */toSequence,
          /* valuesCollection */include$1[21],
          /* valuesSequence */include$1[22],
          /* get */get,
          /* getOrDefault */getOrDefault,
          /* getOrRaise */getOrRaise,
          /* toMap */include[27],
          /* keysNavigableSet */keysNavigableSet,
          /* keysNavigableSetReversed */keysNavigableSetReversed,
          /* keysSet */include[26],
          /* toMapReversed */toMapReversed,
          /* toNavigableMap */toNavigableMap,
          /* toNavigableMapReversed */toNavigableMapReversed
        ];
}

function Make2(Base) {
  var include = ImmMap.Make2([
        Base[0],
        Base[1],
        Base[3],
        Base[4],
        Base[5],
        Base[7],
        Base[9],
        Base[11],
        Base[13]
      ]);
  var get = include[23];
  var getOrDefault = include[24];
  var getOrRaise = include[25];
  var include$1 = NavigableKeyedCollection.Make2([
        Base[0],
        Base[1],
        Base[2],
        Base[6],
        Base[7],
        Base[8],
        Base[9],
        Base[10],
        Base[11],
        Base[12],
        Base[13],
        Base[14]
      ]);
  var containsKey = include$1[13];
  var count = include$1[14];
  var isEmpty = include$1[15];
  var keysSequence = include$1[18];
  var toSequence = include$1[20];
  var firstOrRaise = include$1[24];
  var keysSequenceReversed = include$1[31];
  var lastOrRaise = include$1[33];
  var toSequenceReversed = include$1[42];
  var reduce = Base[/* reduceReversed */8];
  var reduceKeys = Base[/* reduceKeysReversed */10];
  var reduceValues = Base[/* reduceValuesReversed */12];
  var ReversedImmMap = ImmMap.Make2(/* module */[
        /* containsKey */containsKey,
        /* count */count,
        /* get */get,
        /* getOrDefault */getOrDefault,
        /* getOrRaise */getOrRaise,
        /* reduce */reduce,
        /* reduceKeys */reduceKeys,
        /* reduceValues */reduceValues,
        /* toSequence */toSequenceReversed
      ]);
  var toMapReversed = ReversedImmMap[/* toMap */27];
  var firstKeyOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getKey, collection);
  };
  var lastKeyOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getKey, collection);
  };
  var keysNavigableSetImpl_003 = /* reduce */Base[/* reduceKeys */9];
  var keysNavigableSetImpl = /* record */[
    /* contains */containsKey,
    /* count */count,
    /* firstOrRaise */firstKeyOrRaise,
    keysNavigableSetImpl_003,
    /* toSequence */keysSequence
  ];
  var keysNavigableSetReversedImpl_003 = /* reduce */Base[/* reduceKeysReversed */10];
  var keysNavigableSetReversedImpl = /* record */[
    /* contains */containsKey,
    /* count */count,
    /* firstOrRaise */lastKeyOrRaise,
    keysNavigableSetReversedImpl_003,
    /* toSequence */keysSequenceReversed
  ];
  var keysNavigableSet = function (map) {
    if (Curry._1(isEmpty, map)) {
      return NavigableSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysNavigableSetImpl,
              keysNavigableSetReversedImpl
            ];
    }
  };
  var keysNavigableSetReversed = function (map) {
    if (Curry._1(isEmpty, map)) {
      return NavigableSet.empty(/* () */0);
    } else {
      return /* Instance */[
              map,
              keysNavigableSetReversedImpl,
              keysNavigableSetImpl
            ];
    }
  };
  var sequentialMapImpl_006 = /* reduce */Base[/* reduce */7];
  var sequentialMapImpl = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    sequentialMapImpl_006,
    /* toSequence */toSequence
  ];
  var sequentialMapReversedImpl_006 = /* reduce */Base[/* reduceReversed */8];
  var sequentialMapReversedImpl = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    /* get */get,
    /* getOrDefault */getOrDefault,
    /* getOrRaise */getOrRaise,
    sequentialMapReversedImpl_006,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableMap = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              sequentialMapImpl,
              sequentialMapReversedImpl
            ];
    }
  };
  var toNavigableMapReversed = function (map) {
    if (Curry._1(isEmpty, map)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              map,
              sequentialMapReversedImpl,
              sequentialMapImpl
            ];
    }
  };
  return /* module */[
          /* first */include$1[23],
          /* firstOrRaise */firstOrRaise,
          /* keysCollectionReversed */include$1[25],
          /* keysNavigableCollection */include$1[26],
          /* keysNavigableCollectionReversed */include$1[27],
          /* keysReversed */include$1[28],
          /* keysSequentialCollection */include$1[29],
          /* keysSequentialCollectionReversed */include$1[30],
          /* keysSequenceReversed */keysSequenceReversed,
          /* last */include$1[32],
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */include$1[34],
          /* reduceKeysReversed */include$1[35],
          /* reduceValuesReversed */include$1[36],
          /* toIterableReversed */include$1[37],
          /* toKeyedCollectionReversed */include$1[38],
          /* toKeyedIterableReversed */include$1[39],
          /* toNavigableKeyedCollection */include$1[40],
          /* toNavigableKeyedCollectionReversed */include$1[41],
          /* toSequenceReversed */toSequenceReversed,
          /* valuesCollectionReversed */include$1[43],
          /* valuesNavigableCollection */include$1[44],
          /* valuesNavigableCollectionReversed */include$1[45],
          /* valuesReversed */include$1[46],
          /* valuesSequentialCollection */include$1[47],
          /* valuesSequentialCollectionReversed */include$1[48],
          /* valuesSequenceReversed */include$1[49],
          /* every */include$1[0],
          /* find */include$1[1],
          /* findOrRaise */include$1[2],
          /* forEach */include$1[3],
          /* keys */include$1[4],
          /* none */include$1[5],
          /* reduce */include$1[6],
          /* reduceKeys */include$1[7],
          /* reduceValues */include$1[8],
          /* some */include$1[9],
          /* toIterable */include$1[10],
          /* toKeyedIterable */include$1[11],
          /* values */include$1[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include$1[16],
          /* keysCollection */include$1[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include$1[19],
          /* toSequence */toSequence,
          /* valuesCollection */include$1[21],
          /* valuesSequence */include$1[22],
          /* get */get,
          /* getOrDefault */getOrDefault,
          /* getOrRaise */getOrRaise,
          /* toMap */include[27],
          /* keysNavigableSet */keysNavigableSet,
          /* keysNavigableSetReversed */keysNavigableSetReversed,
          /* keysSet */include[26],
          /* toMapReversed */toMapReversed,
          /* toNavigableMap */toNavigableMap,
          /* toNavigableMapReversed */toNavigableMapReversed
        ];
}

function containsKey(key, map) {
  if (map) {
    return Curry._2(map[1][/* containsKey */0], key, map[0]);
  } else {
    return /* false */0;
  }
}

function count(map) {
  if (map) {
    return Curry._1(map[1][/* count */1], map[0]);
  } else {
    return 0;
  }
}

function firstOrRaise(selector, map) {
  if (map) {
    return Curry._2(map[1][/* firstOrRaise */2], selector, map[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function get(key, map) {
  if (map) {
    return Curry._2(map[1][/* get */3], key, map[0]);
  } else {
    return /* None */0;
  }
}

function getOrDefault($$default, key, map) {
  if (map) {
    return Curry._3(map[1][/* getOrDefault */4], $$default, key, map[0]);
  } else {
    return $$default;
  }
}

function getOrRaise(key, map) {
  if (map) {
    return Curry._2(map[1][/* getOrRaise */5], key, map[0]);
  } else {
    return Pervasives.failwith("not found");
  }
}

function lastOrRaise(selector, map) {
  if (map) {
    return Curry._2(map[2][/* firstOrRaise */2], selector, map[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[1][/* reduce */6], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

var reduce$1 = include[0];

var reduceKeys = include[1];

var reduceValues = include[2];

function reduce$2(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[2][/* reduce */6], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var KeyedReducerReversed = KeyedReducer.Make2(/* module */[/* reduce */reduce$2]);

var reduceReversed = KeyedReducerReversed[/* reduce */0];

var reduceKeysReversed = KeyedReducerReversed[/* reduceKeys */1];

var reduceValuesReversed = KeyedReducerReversed[/* reduceValues */2];

function toSequence(selector, map) {
  if (map) {
    return Curry._2(map[1][/* toSequence */7], selector, map[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function toSequenceReversed(selector, map) {
  if (map) {
    return Curry._2(map[2][/* toSequence */7], selector, map[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include$1 = ImmMap.Make2([
      containsKey,
      count,
      get,
      getOrDefault,
      getOrRaise,
      reduce$1,
      reduceKeys,
      reduceValues,
      toSequence
    ]);

var get$1 = include$1[23];

var getOrDefault$1 = include$1[24];

var getOrRaise$1 = include$1[25];

var include$2 = NavigableKeyedCollection.Make2([
      containsKey,
      count,
      firstOrRaise,
      lastOrRaise,
      reduce$1,
      reduceReversed,
      reduceKeys,
      reduceKeysReversed,
      reduceValues,
      reduceValuesReversed,
      toSequence,
      toSequenceReversed
    ]);

var containsKey$1 = include$2[13];

var count$1 = include$2[14];

var isEmpty = include$2[15];

var keysSequence = include$2[18];

var toSequence$1 = include$2[20];

var firstOrRaise$1 = include$2[24];

var keysSequenceReversed = include$2[31];

var lastOrRaise$1 = include$2[33];

var toSequenceReversed$1 = include$2[42];

var ReversedImmMap = ImmMap.Make2(/* module */[
      /* containsKey */containsKey$1,
      /* count */count$1,
      /* get */get$1,
      /* getOrDefault */getOrDefault$1,
      /* getOrRaise */getOrRaise$1,
      /* reduce */reduceReversed,
      /* reduceKeys */reduceKeysReversed,
      /* reduceValues */reduceValuesReversed,
      /* toSequence */toSequenceReversed$1
    ]);

var toMapReversed = ReversedImmMap[/* toMap */27];

function firstKeyOrRaise(collection) {
  return Curry._2(firstOrRaise$1, Functions.getKey, collection);
}

function lastKeyOrRaise(collection) {
  return Curry._2(lastOrRaise$1, Functions.getKey, collection);
}

var keysNavigableSetImpl = /* record */[
  /* contains */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */firstKeyOrRaise,
  /* reduce */reduceKeys,
  /* toSequence */keysSequence
];

var keysNavigableSetReversedImpl = /* record */[
  /* contains */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */lastKeyOrRaise,
  /* reduce */reduceKeysReversed,
  /* toSequence */keysSequenceReversed
];

function keysNavigableSet(map) {
  if (Curry._1(isEmpty, map)) {
    return NavigableSet.empty(/* () */0);
  } else {
    return /* Instance */[
            map,
            keysNavigableSetImpl,
            keysNavigableSetReversedImpl
          ];
  }
}

function keysNavigableSetReversed(map) {
  if (Curry._1(isEmpty, map)) {
    return NavigableSet.empty(/* () */0);
  } else {
    return /* Instance */[
            map,
            keysNavigableSetReversedImpl,
            keysNavigableSetImpl
          ];
  }
}

var sequentialMapImpl = /* record */[
  /* containsKey */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */firstOrRaise$1,
  /* get */get$1,
  /* getOrDefault */getOrDefault$1,
  /* getOrRaise */getOrRaise$1,
  /* reduce */reduce$1,
  /* toSequence */toSequence$1
];

var sequentialMapReversedImpl = /* record */[
  /* containsKey */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */lastOrRaise$1,
  /* get */get$1,
  /* getOrDefault */getOrDefault$1,
  /* getOrRaise */getOrRaise$1,
  /* reduce */reduceReversed,
  /* toSequence */toSequenceReversed$1
];

function toNavigableMapReversed(map) {
  if (Curry._1(isEmpty, map)) {
    return /* Empty */0;
  } else {
    return /* Instance */[
            map,
            sequentialMapReversedImpl,
            sequentialMapImpl
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toNavigableMap(map) {
  return map;
}

var first = include$2[23];

var keysCollectionReversed = include$2[25];

var keysNavigableCollection = include$2[26];

var keysNavigableCollectionReversed = include$2[27];

var keysReversed = include$2[28];

var keysSequentialCollection = include$2[29];

var keysSequentialCollectionReversed = include$2[30];

var last = include$2[32];

var reduceReversed$1 = include$2[34];

var reduceKeysReversed$1 = include$2[35];

var reduceValuesReversed$1 = include$2[36];

var toIterableReversed = include$2[37];

var toKeyedCollectionReversed = include$2[38];

var toKeyedIterableReversed = include$2[39];

var toNavigableKeyedCollection = include$2[40];

var toNavigableKeyedCollectionReversed = include$2[41];

var valuesCollectionReversed = include$2[43];

var valuesNavigableCollection = include$2[44];

var valuesNavigableCollectionReversed = include$2[45];

var valuesReversed = include$2[46];

var valuesSequentialCollection = include$2[47];

var valuesSequentialCollectionReversed = include$2[48];

var valuesSequenceReversed = include$2[49];

var every = include$2[0];

var find = include$2[1];

var findOrRaise = include$2[2];

var forEach = include$2[3];

var keys = include$2[4];

var none = include$2[5];

var reduce$3 = include$2[6];

var reduceKeys$1 = include$2[7];

var reduceValues$1 = include$2[8];

var some = include$2[9];

var toIterable = include$2[10];

var toKeyedIterable = include$2[11];

var values = include$2[12];

var isNotEmpty = include$2[16];

var keysCollection = include$2[17];

var toKeyedCollection = include$2[19];

var valuesCollection = include$2[21];

var valuesSequence = include$2[22];

var toMap = include$1[27];

var keysSet = include$1[26];

exports.Make1                              = Make1;
exports.Make2                              = Make2;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise$1;
exports.keysCollectionReversed             = keysCollectionReversed;
exports.keysNavigableCollection            = keysNavigableCollection;
exports.keysNavigableCollectionReversed    = keysNavigableCollectionReversed;
exports.keysReversed                       = keysReversed;
exports.keysSequentialCollection           = keysSequentialCollection;
exports.keysSequentialCollectionReversed   = keysSequentialCollectionReversed;
exports.keysSequenceReversed               = keysSequenceReversed;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise$1;
exports.reduceReversed                     = reduceReversed$1;
exports.reduceKeysReversed                 = reduceKeysReversed$1;
exports.reduceValuesReversed               = reduceValuesReversed$1;
exports.toIterableReversed                 = toIterableReversed;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed$1;
exports.valuesCollectionReversed           = valuesCollectionReversed;
exports.valuesNavigableCollection          = valuesNavigableCollection;
exports.valuesNavigableCollectionReversed  = valuesNavigableCollectionReversed;
exports.valuesReversed                     = valuesReversed;
exports.valuesSequentialCollection         = valuesSequentialCollection;
exports.valuesSequentialCollectionReversed = valuesSequentialCollectionReversed;
exports.valuesSequenceReversed             = valuesSequenceReversed;
exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.keys                               = keys;
exports.none                               = none;
exports.reduce                             = reduce$3;
exports.reduceKeys                         = reduceKeys$1;
exports.reduceValues                       = reduceValues$1;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.toKeyedIterable                    = toKeyedIterable;
exports.values                             = values;
exports.containsKey                        = containsKey$1;
exports.count                              = count$1;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.keysCollection                     = keysCollection;
exports.keysSequence                       = keysSequence;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toSequence                         = toSequence$1;
exports.valuesCollection                   = valuesCollection;
exports.valuesSequence                     = valuesSequence;
exports.get                                = get$1;
exports.getOrDefault                       = getOrDefault$1;
exports.getOrRaise                         = getOrRaise$1;
exports.toMap                              = toMap;
exports.keysNavigableSet                   = keysNavigableSet;
exports.keysNavigableSetReversed           = keysNavigableSetReversed;
exports.keysSet                            = keysSet;
exports.toMapReversed                      = toMapReversed;
exports.toNavigableMapReversed             = toNavigableMapReversed;
exports.empty                              = empty;
exports.toNavigableMap                     = toNavigableMap;
/* include Not a pure module */


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var Sequence      = __webpack_require__(56);
var Functions     = __webpack_require__(55);
var Collection    = __webpack_require__(69);
var KeyedReducer  = __webpack_require__(62);
var KeyedIterable = __webpack_require__(67);

function Make1(Base) {
  var containsKey = Base[0];
  var count = Base[1];
  var toSequence = Base[5];
  var isEmpty = function (keyed) {
    return +(Curry._1(count, keyed) === 0);
  };
  var isNotEmpty = function (keyed) {
    return +(Curry._1(count, keyed) !== 0);
  };
  var include = KeyedIterable.Make1(/* module */[
        /* isEmpty */isEmpty,
        /* reduce */Base[2],
        /* reduceKeys */Base[3],
        /* reduceValues */Base[4]
      ]);
  var keysSequence = function (keyed) {
    if (Curry._1(count, keyed)) {
      return Curry._2(toSequence, Functions.getKey, keyed);
    } else {
      return Sequence.empty(/* () */0);
    }
  };
  var keysCollectionImpl_001 = /* reduce */Base[/* reduceKeys */3];
  var keysCollectionImpl = /* record */[
    /* count */count,
    keysCollectionImpl_001,
    /* toSequence */keysSequence
  ];
  var keysCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              keysCollectionImpl
            ];
    } else {
      return Collection.empty(/* () */0);
    }
  };
  var valuesSequence = function (keyed) {
    if (Curry._1(count, keyed)) {
      return Curry._2(toSequence, Functions.getValue, keyed);
    } else {
      return Sequence.empty(/* () */0);
    }
  };
  var valuesCollectionImpl_001 = /* reduce */Base[/* reduceValues */4];
  var valuesCollectionImpl = /* record */[
    /* count */count,
    valuesCollectionImpl_001,
    /* toSequence */valuesSequence
  ];
  var valuesCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              valuesCollectionImpl
            ];
    } else {
      return Collection.empty(/* () */0);
    }
  };
  var keyedCollectionBase_002 = /* reduce */Base[/* reduce */2];
  var keyedCollectionBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    keyedCollectionBase_002,
    /* toSequence */toSequence
  ];
  var toKeyedCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              keyedCollectionBase
            ];
    } else {
      return /* Empty */0;
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */isNotEmpty,
          /* keysCollection */keysCollection,
          /* keysSequence */keysSequence,
          /* toKeyedCollection */toKeyedCollection,
          /* toSequence */toSequence,
          /* valuesCollection */valuesCollection,
          /* valuesSequence */valuesSequence
        ];
}

function Make2(Base) {
  var containsKey = Base[0];
  var count = Base[1];
  var toSequence = Base[5];
  var isEmpty = function (keyed) {
    return +(Curry._1(count, keyed) === 0);
  };
  var isNotEmpty = function (keyed) {
    return +(Curry._1(count, keyed) !== 0);
  };
  var include = KeyedIterable.Make2(/* module */[
        /* isEmpty */isEmpty,
        /* reduce */Base[2],
        /* reduceKeys */Base[3],
        /* reduceValues */Base[4]
      ]);
  var keysSequence = function (keyed) {
    if (Curry._1(count, keyed)) {
      return Curry._2(toSequence, Functions.getKey, keyed);
    } else {
      return Sequence.empty(/* () */0);
    }
  };
  var keysCollectionImpl_001 = /* reduce */Base[/* reduceKeys */3];
  var keysCollectionImpl = /* record */[
    /* count */count,
    keysCollectionImpl_001,
    /* toSequence */keysSequence
  ];
  var keysCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              keysCollectionImpl
            ];
    } else {
      return Collection.empty(/* () */0);
    }
  };
  var valuesSequence = function (keyed) {
    if (Curry._1(count, keyed)) {
      return Curry._2(toSequence, Functions.getValue, keyed);
    } else {
      return Sequence.empty(/* () */0);
    }
  };
  var valuesCollectionImpl_001 = /* reduce */Base[/* reduceValues */4];
  var valuesCollectionImpl = /* record */[
    /* count */count,
    valuesCollectionImpl_001,
    /* toSequence */valuesSequence
  ];
  var valuesCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              valuesCollectionImpl
            ];
    } else {
      return Collection.empty(/* () */0);
    }
  };
  var keyedCollectionBase_002 = /* reduce */Base[/* reduce */2];
  var keyedCollectionBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    keyedCollectionBase_002,
    /* toSequence */toSequence
  ];
  var toKeyedCollection = function (keyed) {
    if (Curry._1(count, keyed)) {
      return /* Instance */[
              keyed,
              keyedCollectionBase
            ];
    } else {
      return /* Empty */0;
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */isNotEmpty,
          /* keysCollection */keysCollection,
          /* keysSequence */keysSequence,
          /* toKeyedCollection */toKeyedCollection,
          /* toSequence */toSequence,
          /* valuesCollection */valuesCollection,
          /* valuesSequence */valuesSequence
        ];
}

function containsKey(key, keyed) {
  if (keyed) {
    return Curry._2(keyed[1][/* containsKey */0], key, keyed[0]);
  } else {
    return /* false */0;
  }
}

function count(keyed) {
  if (keyed) {
    return Curry._1(keyed[1][/* count */1], keyed[0]);
  } else {
    return 0;
  }
}

function reduce(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[1][/* reduce */2], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

var reduceKeys = include[1];

var reduceValues = include[2];

function toSequence(selector, keyed) {
  if (keyed) {
    return Curry._2(keyed[1][/* toSequence */3], selector, keyed[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function isEmpty(keyed) {
  return +(count(keyed) === 0);
}

function isNotEmpty(keyed) {
  return +(count(keyed) !== 0);
}

var include$1 = KeyedIterable.Make2(/* module */[
      /* isEmpty */isEmpty,
      /* reduce */include[0],
      /* reduceKeys */reduceKeys,
      /* reduceValues */reduceValues
    ]);

function keysSequence(keyed) {
  if (count(keyed)) {
    return toSequence(Functions.getKey, keyed);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var keysCollectionImpl = /* record */[
  /* count */count,
  /* reduce */reduceKeys,
  /* toSequence */keysSequence
];

function keysCollection(keyed) {
  if (count(keyed)) {
    return /* Instance */[
            keyed,
            keysCollectionImpl
          ];
  } else {
    return Collection.empty(/* () */0);
  }
}

function valuesSequence(keyed) {
  if (count(keyed)) {
    return toSequence(Functions.getValue, keyed);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var valuesCollectionImpl = /* record */[
  /* count */count,
  /* reduce */reduceValues,
  /* toSequence */valuesSequence
];

function valuesCollection(keyed) {
  if (count(keyed)) {
    return /* Instance */[
            keyed,
            valuesCollectionImpl
          ];
  } else {
    return Collection.empty(/* () */0);
  }
}

function empty() {
  return /* Empty */0;
}

function toKeyedCollection(keyed) {
  return keyed;
}

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var keys = include$1[4];

var none = include$1[5];

var reduce$1 = include$1[6];

var reduceKeys$1 = include$1[7];

var reduceValues$1 = include$1[8];

var some = include$1[9];

var toIterable = include$1[10];

var toKeyedIterable = include$1[11];

var values = include$1[12];

exports.Make1             = Make1;
exports.Make2             = Make2;
exports.every             = every;
exports.find              = find;
exports.findOrRaise       = findOrRaise;
exports.forEach           = forEach;
exports.keys              = keys;
exports.none              = none;
exports.reduce            = reduce$1;
exports.reduceKeys        = reduceKeys$1;
exports.reduceValues      = reduceValues$1;
exports.some              = some;
exports.toIterable        = toIterable;
exports.toKeyedIterable   = toKeyedIterable;
exports.values            = values;
exports.containsKey       = containsKey;
exports.count             = count;
exports.isEmpty           = isEmpty;
exports.isNotEmpty        = isNotEmpty;
exports.keysCollection    = keysCollection;
exports.keysSequence      = keysSequence;
exports.toSequence        = toSequence;
exports.valuesCollection  = valuesCollection;
exports.valuesSequence    = valuesSequence;
exports.empty             = empty;
exports.toKeyedCollection = toKeyedCollection;
/* include Not a pure module */


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var $$Array                 = __webpack_require__(24);
var Curry                   = __webpack_require__(1);
var Iterable                = __webpack_require__(57);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var Caml_array              = __webpack_require__(7);
var Pervasives              = __webpack_require__(2);
var IndexedTrie             = __webpack_require__(75);
var Preconditions           = __webpack_require__(63);
var CopyOnWriteArray        = __webpack_require__(60);
var PersistentVector        = __webpack_require__(83);
var Caml_builtin_exceptions = __webpack_require__(0);

function tailCopyAndExpand(arr) {
  var arrCount = Curry._1(CopyOnWriteArray.count, arr);
  var retval = Caml_array.caml_make_vect(IndexedTrie.width, Caml_array.caml_array_get(arr, 0));
  $$Array.blit(arr, 0, retval, 0, Pervasives.min(arrCount, IndexedTrie.width));
  return retval;
}

function tailIsEmpty(count) {
  return +(count === 0);
}

function tailIsFull(count) {
  return +(count === IndexedTrie.width);
}

function tailIsNotEmpty(count) {
  return +(count !== 0);
}

function tailIsNotFull(count) {
  return +(count !== IndexedTrie.width);
}

function tailAddFirst(value, arr) {
  var arr$1 = Curry._1(CopyOnWriteArray.isEmpty, arr) ? Caml_array.caml_make_vect(IndexedTrie.width, value) : arr;
  var loop = function (_index) {
    while(true) {
      var index = _index;
      if (index > 0) {
        Caml_array.caml_array_set(arr$1, index, Caml_array.caml_array_get(arr$1, index - 1 | 0));
        _index = index - 1 | 0;
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  loop(CopyOnWriteArray.lastIndexOrRaise(arr$1));
  Caml_array.caml_array_set(arr$1, 0, value);
  return arr$1;
}

function tailRemoveFirst(arr) {
  var countArr = Curry._1(CopyOnWriteArray.count, arr);
  var _index = 1;
  while(true) {
    var index = _index;
    if (index < countArr) {
      Caml_array.caml_array_set(arr, index - 1 | 0, Caml_array.caml_array_get(arr, index));
      _index = index + 1 | 0;
      continue ;
      
    } else {
      return arr;
    }
  };
}

function tailUpdate(index, value, arr) {
  var arr$1 = Curry._1(CopyOnWriteArray.isEmpty, arr) ? Caml_array.caml_make_vect(IndexedTrie.width, value) : arr;
  Caml_array.caml_array_set(arr$1, index, value);
  return arr$1;
}

function count(param) {
  var leftCount = param[/* leftCount */1];
  var middle = param[/* middle */2];
  var rightCount = param[/* rightCount */4];
  var middleCount = IndexedTrie.count(middle);
  return (leftCount + middleCount | 0) + rightCount | 0;
}

function empty() {
  return /* record */[
          /* left : array */[],
          /* leftCount */0,
          /* middle */IndexedTrie.empty,
          /* right : array */[],
          /* rightCount */0
        ];
}

function addFirst(owner, value, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var rightCount = transientVec[/* rightCount */4];
  if (leftCount === IndexedTrie.width && rightCount !== 0) {
    transientVec[/* left */0] = Caml_array.caml_make_vect(IndexedTrie.width, value);
    transientVec[/* leftCount */1] = 1;
    transientVec[/* middle */2] = IndexedTrie.addFirstLeafUsingMutator(IndexedTrie.updateLevelTransient, owner, left, middle);
  } else if (leftCount === IndexedTrie.width && rightCount === 0) {
    transientVec[/* left */0] = Caml_array.caml_make_vect(IndexedTrie.width, value);
    transientVec[/* leftCount */1] = 1;
    transientVec[/* right */3] = left;
    transientVec[/* rightCount */4] = leftCount;
  } else {
    transientVec[/* left */0] = tailAddFirst(value, left);
    transientVec[/* leftCount */1] = leftCount + 1 | 0;
  }
  return transientVec;
}

function addFirstAll(owner, iter, vector) {
  return Iterable.reduce(/* None */0, (function (acc, next) {
                return addFirst(owner, next, acc);
              }), vector, iter);
}

function addLast(owner, value, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var right = transientVec[/* right */3];
  var rightCount = transientVec[/* rightCount */4];
  if (leftCount !== IndexedTrie.width && rightCount === 0) {
    transientVec[/* left */0] = tailUpdate(leftCount, value, left);
    transientVec[/* leftCount */1] = leftCount + 1 | 0;
  } else if (rightCount !== IndexedTrie.width) {
    transientVec[/* right */3] = tailUpdate(rightCount, value, right);
    transientVec[/* rightCount */4] = rightCount + 1 | 0;
  } else {
    transientVec[/* middle */2] = IndexedTrie.addLastLeafUsingMutator(IndexedTrie.updateLevelTransient, owner, right, middle);
    transientVec[/* right */3] = Caml_array.caml_make_vect(IndexedTrie.width, value);
    transientVec[/* rightCount */4] = 1;
  }
  return transientVec;
}

function addLastAll(owner, iter, vector) {
  return Iterable.reduce(/* None */0, (function (acc, next) {
                return addLast(owner, next, acc);
              }), vector, iter);
}

function removeFirstOrRaise(owner, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var right = transientVec[/* right */3];
  var rightCount = transientVec[/* rightCount */4];
  if (leftCount > 1) {
    transientVec[/* left */0] = tailRemoveFirst(left);
    transientVec[/* leftCount */1] = leftCount - 1 | 0;
  } else if (IndexedTrie.count(middle) > 0) {
    var match = IndexedTrie.removeFirstLeafUsingMutator(IndexedTrie.updateLevelTransient, owner, middle);
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/TransientVector.re",
              170,
              10
            ]
          ];
    } else if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/TransientVector.re",
              170,
              10
            ]
          ];
    } else {
      var left$1 = match$1[1];
      var leftCount$1 = Curry._1(CopyOnWriteArray.count, left$1);
      var left$2 = match$1[0] === owner && leftCount$1 === IndexedTrie.width ? left$1 : tailCopyAndExpand(left$1);
      transientVec[/* left */0] = left$2;
      transientVec[/* leftCount */1] = leftCount$1;
      transientVec[/* middle */2] = match[1];
    }
  } else if (rightCount > 0) {
    transientVec[/* left */0] = right;
    transientVec[/* leftCount */1] = rightCount;
    transientVec[/* right */3] = Caml_array.caml_make_vect(IndexedTrie.width, Caml_array.caml_array_get(right, 0));
    transientVec[/* rightCount */4] = 0;
  } else if (leftCount === 1) {
    transientVec[/* leftCount */1] = 0;
  } else {
    Pervasives.failwith("vector is empty");
  }
  return transientVec;
}

function removeLastOrRaise(owner, transientVec) {
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var rightCount = transientVec[/* rightCount */4];
  if (rightCount > 1) {
    transientVec[/* rightCount */4] = rightCount - 1 | 0;
  } else if (IndexedTrie.count(middle) > 0) {
    var match = IndexedTrie.removeLastLeafUsingMutator(IndexedTrie.updateLevelTransient, owner, middle);
    var match$1 = match[1];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/TransientVector.re",
              207,
              10
            ]
          ];
    } else if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/TransientVector.re",
              207,
              10
            ]
          ];
    } else {
      var right = match$1[1];
      var rightCount$1 = Curry._1(CopyOnWriteArray.count, right);
      var right$1 = match$1[0] === owner && rightCount$1 === IndexedTrie.width ? right : tailCopyAndExpand(right);
      transientVec[/* middle */2] = match[0];
      transientVec[/* right */3] = right$1;
      transientVec[/* rightCount */4] = rightCount$1;
    }
  } else if (rightCount === 1) {
    transientVec[/* rightCount */4] = 0;
  } else if (leftCount > 0) {
    transientVec[/* leftCount */1] = leftCount - 1 | 0;
  } else {
    Pervasives.failwith("vector is empty");
  }
  return transientVec;
}

function getOrRaise(index, param) {
  var left = param[/* left */0];
  var leftCount = param[/* leftCount */1];
  var middle = param[/* middle */2];
  var right = param[/* right */3];
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    return Caml_array.caml_array_get(left, index);
  } else if (rightIndex >= 0) {
    return Caml_array.caml_array_get(right, rightIndex);
  } else {
    var index$1 = index - leftCount | 0;
    return IndexedTrie.get(index$1, middle);
  }
}

function getOrDefault($$default, index, vector) {
  if (index < 0 || index >= count(vector)) {
    return $$default;
  } else {
    return getOrRaise(index, vector);
  }
}

function get(index, vector) {
  var trieCount = count(vector);
  return Preconditions.noneIfIndexOutOfRange(trieCount, index, (function (param) {
                return Functions.flip(getOrRaise, vector, param);
              }));
}

function last(vector) {
  return get(count(vector) - 1 | 0, vector);
}

function lastOrRaise(vector) {
  return getOrRaise(count(vector) - 1 | 0, vector);
}

function update(owner, index, value, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var right = transientVec[/* right */3];
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    transientVec[/* left */0] = tailUpdate(index, value, left);
  } else if (rightIndex >= 0) {
    transientVec[/* right */3] = tailUpdate(rightIndex, value, right);
  } else {
    var index$1 = index - leftCount | 0;
    var middle$1 = IndexedTrie.updateUsingMutator(IndexedTrie.updateLevelTransient, IndexedTrie.updateLeafTransient, owner, index$1, value, middle);
    transientVec[/* middle */2] = middle$1;
  }
  return transientVec;
}

function updateWith(owner, index, f, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var right = transientVec[/* right */3];
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    transientVec[/* left */0] = tailUpdate(index, Curry._1(f, Caml_array.caml_array_get(left, index)), left);
  } else if (rightIndex >= 0) {
    transientVec[/* right */3] = tailUpdate(rightIndex, Curry._1(f, Caml_array.caml_array_get(right, rightIndex)), right);
  } else {
    var index$1 = index - leftCount | 0;
    var middle$1 = IndexedTrie.updateWithUsingMutator(IndexedTrie.updateLevelTransient, IndexedTrie.updateLeafTransient, owner, index$1, f, middle);
    transientVec[/* middle */2] = middle$1;
  }
  return transientVec;
}

var TransientVectorImpl = /* module */[
  /* tailCopyAndExpand */tailCopyAndExpand,
  /* tailIsEmpty */tailIsEmpty,
  /* tailIsFull */tailIsFull,
  /* tailIsNotEmpty */tailIsNotEmpty,
  /* tailIsNotFull */tailIsNotFull,
  /* tailAddFirst */tailAddFirst,
  /* tailRemoveFirst */tailRemoveFirst,
  /* tailUpdate */tailUpdate,
  /* count */count,
  /* empty */empty,
  /* addFirst */addFirst,
  /* addFirstAll */addFirstAll,
  /* addLast */addLast,
  /* addLastAll */addLastAll,
  /* removeFirstOrRaise */removeFirstOrRaise,
  /* removeLastOrRaise */removeLastOrRaise,
  /* getOrRaise */getOrRaise,
  /* getOrDefault */getOrDefault,
  /* get */get,
  /* last */last,
  /* lastOrRaise */lastOrRaise,
  /* update */update,
  /* updateWith */updateWith
];

function mutate(param) {
  var right = param[/* right */2];
  var left = param[/* left */0];
  return Transient.create(/* record */[
              /* left */Curry._1(CopyOnWriteArray.count, left) > 0 ? tailCopyAndExpand(left) : /* array */[],
              /* leftCount */Curry._1(CopyOnWriteArray.count, left),
              /* middle */param[/* middle */1],
              /* right */Curry._1(CopyOnWriteArray.count, right) > 0 ? tailCopyAndExpand(right) : /* array */[],
              /* rightCount */Curry._1(CopyOnWriteArray.count, right)
            ]);
}

function addFirst$1(value, $$transient) {
  return Transient.update1(addFirst, value, $$transient);
}

function addFirstAll$1(iter, $$transient) {
  return Transient.update1(addFirstAll, iter, $$transient);
}

function addLast$1(value, $$transient) {
  return Transient.update1(addLast, value, $$transient);
}

function addLastAll$1(iter, $$transient) {
  return Transient.update1(addLastAll, iter, $$transient);
}

function count$1($$transient) {
  return count(Transient.get($$transient));
}

function empty$1() {
  return mutate(PersistentVector.empty(/* () */0));
}

function isEmpty($$transient) {
  return +(count(Transient.get($$transient)) === 0);
}

function isNotEmpty($$transient) {
  return +(count(Transient.get($$transient)) !== 0);
}

function tailCompress(count, arr) {
  var arrCount = Curry._1(CopyOnWriteArray.count, arr);
  if (arrCount === count) {
    return arr;
  } else if (arrCount > 0) {
    var retval = Caml_array.caml_make_vect(count, Caml_array.caml_array_get(arr, 0));
    $$Array.blit(arr, 0, retval, 0, count);
    return retval;
  } else {
    return /* array */[];
  }
}

function persist($$transient) {
  var match = Transient.persist($$transient);
  var left = match[/* left */0];
  var leftCount = match[/* leftCount */1];
  var middle = match[/* middle */2];
  var right = match[/* right */3];
  var rightCount = match[/* rightCount */4];
  return /* record */[
          /* left */tailCompress(leftCount, left),
          /* middle */middle,
          /* right */tailCompress(rightCount, right)
        ];
}

function removeImpl(_, _$1) {
  return /* record */[
          /* left : array */[],
          /* leftCount */0,
          /* middle */IndexedTrie.empty,
          /* right : array */[],
          /* rightCount */0
        ];
}

function removeAll($$transient) {
  return Transient.update(removeImpl, $$transient);
}

function removeFirstOrRaise$1($$transient) {
  return Transient.update(removeFirstOrRaise, $$transient);
}

function removeLastOrRaise$1($$transient) {
  return Transient.update(removeLastOrRaise, $$transient);
}

function get$1(index, $$transient) {
  return get(index, Transient.get($$transient));
}

function getOrDefault$1($$default, index, $$transient) {
  return getOrDefault($$default, index, Transient.get($$transient));
}

function getOrRaise$1(index, $$transient) {
  return getOrRaise(index, Transient.get($$transient));
}

function first($$transient) {
  return get(0, Transient.get($$transient));
}

function firstOrRaise($$transient) {
  return getOrRaise(0, Transient.get($$transient));
}

function last$1($$transient) {
  return last(Transient.get($$transient));
}

function lastOrRaise$1($$transient) {
  return lastOrRaise(Transient.get($$transient));
}

function update$1(index, value, $$transient) {
  return Transient.update2(update, index, value, $$transient);
}

function updateAllImpl(owner, f, transientVec) {
  var left = transientVec[/* left */0];
  var leftCount = transientVec[/* leftCount */1];
  var middle = transientVec[/* middle */2];
  var right = transientVec[/* right */3];
  var rightCount = transientVec[/* rightCount */4];
  var index = [0];
  var updater = function (value) {
    var result = Curry._2(f, index[0], value);
    index[0] = index[0] + 1 | 0;
    return result;
  };
  for(var i = 0 ,i_finish = leftCount - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(left, i, updater(Caml_array.caml_array_get(left, i)));
  }
  var middle$1 = IndexedTrie.updateAllUsingMutator(IndexedTrie.updateLevelTransient, IndexedTrie.updateLeafTransient, owner, updater, middle);
  for(var i$1 = 0 ,i_finish$1 = rightCount - 1 | 0; i$1 <= i_finish$1; ++i$1){
    Caml_array.caml_array_set(right, i$1, updater(Caml_array.caml_array_get(right, i$1)));
  }
  transientVec[/* middle */2] = middle$1;
  return transientVec;
}

function updateAll(f, $$transient) {
  return Transient.update1(updateAllImpl, f, $$transient);
}

function updateWith$1(index, f, $$transient) {
  return Transient.update2(updateWith, index, f, $$transient);
}

function insertAt(_, _$1, _$2) {
  return Pervasives.failwith("Not Implemented");
}

function removeAt(_, _$1) {
  return Pervasives.failwith("Not Implemented");
}

var Owner = 0;

exports.TransientVectorImpl = TransientVectorImpl;
exports.Owner               = Owner;
exports.mutate              = mutate;
exports.addFirst            = addFirst$1;
exports.addFirstAll         = addFirstAll$1;
exports.addLast             = addLast$1;
exports.addLastAll          = addLastAll$1;
exports.count               = count$1;
exports.empty               = empty$1;
exports.isEmpty             = isEmpty;
exports.isNotEmpty          = isNotEmpty;
exports.tailCompress        = tailCompress;
exports.persist             = persist;
exports.removeImpl          = removeImpl;
exports.removeAll           = removeAll;
exports.removeFirstOrRaise  = removeFirstOrRaise$1;
exports.removeLastOrRaise   = removeLastOrRaise$1;
exports.get                 = get$1;
exports.getOrDefault        = getOrDefault$1;
exports.getOrRaise          = getOrRaise$1;
exports.first               = first;
exports.firstOrRaise        = firstOrRaise;
exports.last                = last$1;
exports.lastOrRaise         = lastOrRaise$1;
exports.update              = update$1;
exports.updateAllImpl       = updateAllImpl;
exports.updateAll           = updateAll;
exports.updateWith          = updateWith$1;
exports.insertAt            = insertAt;
exports.removeAt            = removeAt;
/* IndexedTrie Not a pure module */


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                   = __webpack_require__(1);
var ImmList                 = __webpack_require__(64);
var IntRange                = __webpack_require__(74);
var Transient               = __webpack_require__(58);
var Pervasives              = __webpack_require__(2);
var IndexedTrie             = __webpack_require__(75);
var TransientVector         = __webpack_require__(79);
var CopyOnWriteArray        = __webpack_require__(60);
var PersistentVector        = __webpack_require__(83);
var Caml_builtin_exceptions = __webpack_require__(0);

function addFirstAll(iter, vec) {
  return TransientVector.persist(TransientVector.addFirstAll(iter, TransientVector.mutate(vec)));
}

function addLastAll(iter, vec) {
  return TransientVector.persist(TransientVector.addLastAll(iter, TransientVector.mutate(vec)));
}

function from(iter) {
  return addLastAll(iter, PersistentVector.empty(/* () */0));
}

function fromReverse(iter) {
  return addFirstAll(iter, PersistentVector.empty(/* () */0));
}

function init(count, f) {
  return TransientVector.persist(Curry._4(IntRange.reduce, /* None */0, (function (acc, next) {
                    return TransientVector.addLast(Curry._1(f, next), acc);
                  }), TransientVector.mutate(PersistentVector.empty(/* () */0)), IntRange.create(0, count)));
}

function skip(skipCount, vec) {
  var right = vec[/* right */2];
  var middle = vec[/* middle */1];
  var left = vec[/* left */0];
  var vectorCount = Curry._1(PersistentVector.count, vec);
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  if (skipCount >= vectorCount) {
    return PersistentVector.empty(/* () */0);
  } else if (skipCount <= 0) {
    return vec;
  } else if (skipCount < leftCount) {
    return /* record */[
            /* left */CopyOnWriteArray.skip(skipCount, left),
            /* middle */middle,
            /* right */right
          ];
  } else if (skipCount === leftCount) {
    var match = IndexedTrie.removeFirstLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], middle);
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/Vector.re",
              51,
              8
            ]
          ];
    } else if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/Vector.re",
              51,
              8
            ]
          ];
    } else {
      return /* record */[
              /* left */match$1[1],
              /* middle */match[1],
              /* right */right
            ];
    }
  } else if ((skipCount - leftCount | 0) < middleCount) {
    var skipCount$1 = skipCount - leftCount | 0;
    var match$2 = IndexedTrie.skip(Transient.Owner[/* none */1], skipCount$1, middle);
    return /* record */[
            /* left */match$2[0],
            /* middle */match$2[1],
            /* right */right
          ];
  } else {
    var skipCount$2 = (skipCount - leftCount | 0) - middleCount | 0;
    return /* record */[
            /* left */CopyOnWriteArray.skip(skipCount$2, right),
            /* middle */IndexedTrie.empty,
            /* right : array */[]
          ];
  }
}

function take(takeCount, vec) {
  var middle = vec[/* middle */1];
  var left = vec[/* left */0];
  var vectorCount = Curry._1(PersistentVector.count, vec);
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  if (takeCount >= vectorCount) {
    return vec;
  } else if (takeCount <= leftCount) {
    return /* record */[
            /* left */CopyOnWriteArray.take(takeCount, left),
            /* middle */IndexedTrie.empty,
            /* right : array */[]
          ];
  } else if ((takeCount - leftCount | 0) < middleCount) {
    var takeCount$1 = takeCount - leftCount | 0;
    var match = IndexedTrie.take(Transient.Owner[/* none */1], takeCount$1, middle);
    return /* record */[
            /* left */left,
            /* middle */match[0],
            /* right */match[1]
          ];
  } else if ((takeCount - leftCount | 0) === middleCount) {
    var match$1 = IndexedTrie.removeLastLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], middle);
    var match$2 = match$1[1];
    if (typeof match$2 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/Vector.re",
              90,
              8
            ]
          ];
    } else if (match$2.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/Vector.re",
              90,
              8
            ]
          ];
    } else {
      return /* record */[
              /* left */left,
              /* middle */match$1[0],
              /* right */match$2[1]
            ];
    }
  } else {
    var takeCount$2 = (takeCount - leftCount | 0) - middleCount | 0;
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right */CopyOnWriteArray.take(takeCount$2, vec[/* right */2])
          ];
  }
}

function slice($staropt$star, end_, vec) {
  var start = $staropt$star ? $staropt$star[0] : 0;
  var vecCount = Curry._1(PersistentVector.count, vec);
  var end_$1 = end_ ? end_[0] : vecCount;
  var start$1 = start < 0 ? start + vecCount | 0 : start;
  var end_$2 = end_$1 < 0 ? end_$1 + vecCount | 0 : end_$1;
  var takeCount = Pervasives.max(end_$2 - start$1 | 0, 0);
  if (start$1 === 0 && takeCount === vecCount) {
    return vec;
  } else if (takeCount) {
    return take(takeCount, skip(start$1, vec));
  } else {
    return PersistentVector.empty(/* () */0);
  }
}

function updateAll(f, vec) {
  return TransientVector.persist(TransientVector.updateAll(f, TransientVector.mutate(vec)));
}

function concat(vectors) {
  if (vectors) {
    var tail = vectors[1];
    var vector = vectors[0];
    if (tail) {
      return ImmList.reduce(/* None */0, (function (acc, next) {
                    return addLastAll(Curry._1(PersistentVector.toIterable, next), acc);
                  }), vector, tail);
    } else {
      return vector;
    }
  } else {
    return PersistentVector.empty(/* () */0);
  }
}

function insertAt(index, value, vec) {
  var start = PersistentVector.addLast(value, take(index, vec));
  return concat(/* :: */[
              start,
              /* :: */[
                skip(index, vec),
                /* [] */0
              ]
            ]);
}

function removeAt(index, vec) {
  var start = take(index, vec);
  var end_ = skip(index + 1 | 0, vec);
  return concat(/* :: */[
              start,
              /* :: */[
                end_,
                /* [] */0
              ]
            ]);
}

var every = PersistentVector.every;

var find = PersistentVector.find;

var findOrRaise = PersistentVector.findOrRaise;

var forEach = PersistentVector.forEach;

var none = PersistentVector.none;

var reduce = PersistentVector.reduce;

var some = PersistentVector.some;

var toIterable = PersistentVector.toIterable;

var count = PersistentVector.count;

var isEmpty = PersistentVector.isEmpty;

var isNotEmpty = PersistentVector.isNotEmpty;

var toCollection = PersistentVector.toCollection;

var toSequence = PersistentVector.toSequence;

var first = PersistentVector.first;

var firstOrRaise = PersistentVector.firstOrRaise;

var toSequentialCollection = PersistentVector.toSequentialCollection;

var last = PersistentVector.last;

var lastOrRaise = PersistentVector.lastOrRaise;

var reduceReversed = PersistentVector.reduceReversed;

var toCollectionReversed = PersistentVector.toCollectionReversed;

var toIterableReversed = PersistentVector.toIterableReversed;

var toNavigableCollection = PersistentVector.toNavigableCollection;

var toNavigableCollectionReversed = PersistentVector.toNavigableCollectionReversed;

var toSequenceReversed = PersistentVector.toSequenceReversed;

var toSequentialCollectionReversed = PersistentVector.toSequentialCollectionReversed;

var get = PersistentVector.get;

var getOrDefault = PersistentVector.getOrDefault;

var getOrRaise = PersistentVector.getOrRaise;

var toIndexed = PersistentVector.toIndexed;

var toIndexedReversed = PersistentVector.toIndexedReversed;

var toKeyedCollection = PersistentVector.toKeyedCollection;

var toKeyedCollectionReversed = PersistentVector.toKeyedCollectionReversed;

var toKeyedIterable = PersistentVector.toKeyedIterable;

var toKeyedIterableReversed = PersistentVector.toKeyedIterableReversed;

var toMap = PersistentVector.toMap;

var toMapReversed = PersistentVector.toMapReversed;

var toNavigableKeyedCollection = PersistentVector.toNavigableKeyedCollection;

var toNavigableKeyedCollectionReversed = PersistentVector.toNavigableKeyedCollectionReversed;

var toNavigableMap = PersistentVector.toNavigableMap;

var toNavigableMapReversed = PersistentVector.toNavigableMapReversed;

var emptyInstance = PersistentVector.emptyInstance;

var empty = PersistentVector.empty;

var tailIsFull = PersistentVector.tailIsFull;

var tailIsNotFull = PersistentVector.tailIsNotFull;

var addFirst = PersistentVector.addFirst;

var addLast = PersistentVector.addLast;

var removeAll = PersistentVector.removeAll;

var removeFirstOrRaise = PersistentVector.removeFirstOrRaise;

var removeLastOrRaise = PersistentVector.removeLastOrRaise;

var $$return = PersistentVector.$$return;

var update = PersistentVector.update;

var updateWith = PersistentVector.updateWith;

var Transient$1 = 0;

var mutate = TransientVector.mutate;

exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.none                               = none;
exports.reduce                             = reduce;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.count                              = count;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.toCollection                       = toCollection;
exports.toSequence                         = toSequence;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise;
exports.toSequentialCollection             = toSequentialCollection;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise;
exports.reduceReversed                     = reduceReversed;
exports.toCollectionReversed               = toCollectionReversed;
exports.toIterableReversed                 = toIterableReversed;
exports.toNavigableCollection              = toNavigableCollection;
exports.toNavigableCollectionReversed      = toNavigableCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed;
exports.toSequentialCollectionReversed     = toSequentialCollectionReversed;
exports.get                                = get;
exports.getOrDefault                       = getOrDefault;
exports.getOrRaise                         = getOrRaise;
exports.toIndexed                          = toIndexed;
exports.toIndexedReversed                  = toIndexedReversed;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterable                    = toKeyedIterable;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toMap                              = toMap;
exports.toMapReversed                      = toMapReversed;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toNavigableMap                     = toNavigableMap;
exports.toNavigableMapReversed             = toNavigableMapReversed;
exports.emptyInstance                      = emptyInstance;
exports.empty                              = empty;
exports.tailIsFull                         = tailIsFull;
exports.tailIsNotFull                      = tailIsNotFull;
exports.addFirst                           = addFirst;
exports.addLast                            = addLast;
exports.removeAll                          = removeAll;
exports.removeFirstOrRaise                 = removeFirstOrRaise;
exports.removeLastOrRaise                  = removeLastOrRaise;
exports.$$return                           = $$return;
exports.update                             = update;
exports.updateWith                         = updateWith;
exports.Transient                          = Transient$1;
exports.mutate                             = mutate;
exports.addFirstAll                        = addFirstAll;
exports.addLastAll                         = addLastAll;
exports.from                               = from;
exports.fromReverse                        = fromReverse;
exports.init                               = init;
exports.skip                               = skip;
exports.take                               = take;
exports.slice                              = slice;
exports.updateAll                          = updateAll;
exports.concat                             = concat;
exports.insertAt                           = insertAt;
exports.removeAt                           = removeAt;
/* IntRange Not a pure module */


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Caml_array = __webpack_require__(7);

function create(value) {
  return [/* array */[value]];
}

function empty() {
  return [/* array */[]];
}

function firstOrRaise(opt) {
  return Caml_array.caml_array_get(opt[0], 0);
}

function isEmpty(opt) {
  return +(opt[0].length === 0);
}

function isNotEmpty(opt) {
  return +(opt[0].length !== 0);
}

function set(value, opt) {
  if (isEmpty(opt)) {
    opt[0] = /* array */[value];
    return /* () */0;
  } else {
    return Caml_array.caml_array_set(opt[0], 0, value);
  }
}

function unset(opt) {
  opt[0] = /* array */[];
  return /* () */0;
}

exports.create       = create;
exports.empty        = empty;
exports.firstOrRaise = firstOrRaise;
exports.isEmpty      = isEmpty;
exports.isNotEmpty   = isNotEmpty;
exports.set          = set;
exports.unset        = unset;
/* No side effect */


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                = __webpack_require__(1);
var Sequence             = __webpack_require__(56);
var Functions            = __webpack_require__(55);
var Pervasives           = __webpack_require__(2);
var KeyedReducer         = __webpack_require__(62);
var KeyedCollection      = __webpack_require__(78);
var NavigableCollection  = __webpack_require__(66);
var SequentialCollection = __webpack_require__(70);

function Make1(Base) {
  var firstOrRaise = Base[2];
  var lastOrRaise = Base[3];
  var include = KeyedCollection.Make1([
        Base[0],
        Base[1],
        Base[4],
        Base[6],
        Base[8],
        Base[10]
      ]);
  var containsKey = include[13];
  var count = include[14];
  var isEmpty = include[15];
  var keysSequence = include[18];
  var toSequence = include[20];
  var valuesSequence = include[22];
  var first = function (selector, keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._2(firstOrRaise, selector, keyed)];
    }
  };
  var last = function (selector, keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._2(lastOrRaise, selector, keyed)];
    }
  };
  var reduce = Base[/* reduceReversed */5];
  var reduceKeys = Base[/* reduceKeysReversed */7];
  var reduceValues = Base[/* reduceValuesReversed */9];
  var ReversedKeyedCollection = KeyedCollection.Make1(/* module */[
        /* containsKey */containsKey,
        /* count */count,
        /* reduce */reduce,
        /* reduceKeys */reduceKeys,
        /* reduceValues */reduceValues,
        /* toSequence */Base[11]
      ]);
  var keysCollectionReversed = ReversedKeyedCollection[/* keysCollection */17];
  var keysReversed = ReversedKeyedCollection[/* keys */4];
  var keysSequenceReversed = ReversedKeyedCollection[/* keysSequence */18];
  var reduceReversed = ReversedKeyedCollection[/* reduce */6];
  var reduceKeysReversed = ReversedKeyedCollection[/* reduceKeys */7];
  var reduceValuesReversed = ReversedKeyedCollection[/* reduceValues */8];
  var toIterableReversed = ReversedKeyedCollection[/* toIterable */10];
  var toKeyedCollectionReversed = ReversedKeyedCollection[/* toKeyedCollection */19];
  var toKeyedIterableReversed = ReversedKeyedCollection[/* toKeyedIterable */11];
  var toSequenceReversed = ReversedKeyedCollection[/* toSequence */20];
  var valuesCollectionReversed = ReversedKeyedCollection[/* valuesCollection */21];
  var valuesReversed = ReversedKeyedCollection[/* values */12];
  var valuesSequenceReversed = ReversedKeyedCollection[/* valuesSequence */22];
  var firstKeyOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getKey, collection);
  };
  var lastKeyOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getKey, collection);
  };
  var firstValueOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getValue, collection);
  };
  var lastValueOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getValue, collection);
  };
  var keysSequentialCollectionBase_002 = /* reduce */Base[/* reduceKeys */6];
  var keysSequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstKeyOrRaise,
    keysSequentialCollectionBase_002,
    /* toSequence */keysSequence
  ];
  var keysSequentialCollectionReversedBase_002 = /* reduce */Base[/* reduceKeysReversed */7];
  var keysSequentialCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastKeyOrRaise,
    keysSequentialCollectionReversedBase_002,
    /* toSequence */keysSequenceReversed
  ];
  var keysSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionBase
            ];
    }
  };
  var keysSequentialCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionReversedBase
            ];
    }
  };
  var keysNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionBase,
              keysSequentialCollectionReversedBase
            ];
    }
  };
  var keysNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionReversedBase,
              keysSequentialCollectionBase
            ];
    }
  };
  var valuesSequentialCollectionBase_002 = /* reduce */Base[/* reduceValues */8];
  var valuesSequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstValueOrRaise,
    valuesSequentialCollectionBase_002,
    /* toSequence */valuesSequence
  ];
  var valuesSequentialCollectionReversedBase_002 = /* reduce */Base[/* reduceValuesReversed */9];
  var valuesSequentialCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastValueOrRaise,
    valuesSequentialCollectionReversedBase_002,
    /* toSequence */valuesSequenceReversed
  ];
  var valuesSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionBase
            ];
    }
  };
  var valuesSequentialCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionReversedBase
            ];
    }
  };
  var valuesNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionBase,
              valuesSequentialCollectionReversedBase
            ];
    }
  };
  var valuesNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionReversedBase,
              valuesSequentialCollectionBase
            ];
    }
  };
  var sequentialKeyedCollectionBase_003 = /* reduce */Base[/* reduce */4];
  var sequentialKeyedCollectionBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    sequentialKeyedCollectionBase_003,
    /* toSequence */toSequence
  ];
  var sequentialKeyedCollectionReversedBase_003 = /* reduce */Base[/* reduceReversed */5];
  var sequentialKeyedCollectionReversedBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    sequentialKeyedCollectionReversedBase_003,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableKeyedCollection = function (keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyed,
              sequentialKeyedCollectionBase,
              sequentialKeyedCollectionReversedBase
            ];
    }
  };
  var toNavigableKeyedCollectionReversed = function (keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyed,
              sequentialKeyedCollectionReversedBase,
              sequentialKeyedCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[16],
          /* keysCollection */include[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include[19],
          /* toSequence */toSequence,
          /* valuesCollection */include[21],
          /* valuesSequence */valuesSequence,
          /* first */first,
          /* firstOrRaise */firstOrRaise,
          /* keysCollectionReversed */keysCollectionReversed,
          /* keysNavigableCollection */keysNavigableCollection,
          /* keysNavigableCollectionReversed */keysNavigableCollectionReversed,
          /* keysReversed */keysReversed,
          /* keysSequentialCollection */keysSequentialCollection,
          /* keysSequentialCollectionReversed */keysSequentialCollectionReversed,
          /* keysSequenceReversed */keysSequenceReversed,
          /* last */last,
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */reduceReversed,
          /* reduceKeysReversed */reduceKeysReversed,
          /* reduceValuesReversed */reduceValuesReversed,
          /* toIterableReversed */toIterableReversed,
          /* toKeyedCollectionReversed */toKeyedCollectionReversed,
          /* toKeyedIterableReversed */toKeyedIterableReversed,
          /* toNavigableKeyedCollection */toNavigableKeyedCollection,
          /* toNavigableKeyedCollectionReversed */toNavigableKeyedCollectionReversed,
          /* toSequenceReversed */toSequenceReversed,
          /* valuesCollectionReversed */valuesCollectionReversed,
          /* valuesNavigableCollection */valuesNavigableCollection,
          /* valuesNavigableCollectionReversed */valuesNavigableCollectionReversed,
          /* valuesReversed */valuesReversed,
          /* valuesSequentialCollection */valuesSequentialCollection,
          /* valuesSequentialCollectionReversed */valuesSequentialCollectionReversed,
          /* valuesSequenceReversed */valuesSequenceReversed
        ];
}

function Make2(Base) {
  var firstOrRaise = Base[2];
  var lastOrRaise = Base[3];
  var include = KeyedCollection.Make2([
        Base[0],
        Base[1],
        Base[4],
        Base[6],
        Base[8],
        Base[10]
      ]);
  var containsKey = include[13];
  var count = include[14];
  var isEmpty = include[15];
  var keysSequence = include[18];
  var toSequence = include[20];
  var valuesSequence = include[22];
  var first = function (selector, keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._2(firstOrRaise, selector, keyed)];
    }
  };
  var last = function (selector, keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* None */0;
    } else {
      return /* Some */[Curry._2(lastOrRaise, selector, keyed)];
    }
  };
  var reduce = Base[/* reduceReversed */5];
  var reduceKeys = Base[/* reduceKeysReversed */7];
  var reduceValues = Base[/* reduceValuesReversed */9];
  var ReversedKeyedCollection = KeyedCollection.Make2(/* module */[
        /* containsKey */containsKey,
        /* count */count,
        /* reduce */reduce,
        /* reduceKeys */reduceKeys,
        /* reduceValues */reduceValues,
        /* toSequence */Base[11]
      ]);
  var keysCollectionReversed = ReversedKeyedCollection[/* keysCollection */17];
  var keysReversed = ReversedKeyedCollection[/* keys */4];
  var keysSequenceReversed = ReversedKeyedCollection[/* keysSequence */18];
  var reduceReversed = ReversedKeyedCollection[/* reduce */6];
  var reduceKeysReversed = ReversedKeyedCollection[/* reduceKeys */7];
  var reduceValuesReversed = ReversedKeyedCollection[/* reduceValues */8];
  var toIterableReversed = ReversedKeyedCollection[/* toIterable */10];
  var toKeyedCollectionReversed = ReversedKeyedCollection[/* toKeyedCollection */19];
  var toKeyedIterableReversed = ReversedKeyedCollection[/* toKeyedIterable */11];
  var toSequenceReversed = ReversedKeyedCollection[/* toSequence */20];
  var valuesCollectionReversed = ReversedKeyedCollection[/* valuesCollection */21];
  var valuesReversed = ReversedKeyedCollection[/* values */12];
  var valuesSequenceReversed = ReversedKeyedCollection[/* valuesSequence */22];
  var firstKeyOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getKey, collection);
  };
  var lastKeyOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getKey, collection);
  };
  var firstValueOrRaise = function (collection) {
    return Curry._2(firstOrRaise, Functions.getValue, collection);
  };
  var lastValueOrRaise = function (collection) {
    return Curry._2(lastOrRaise, Functions.getValue, collection);
  };
  var keysSequentialCollectionBase_002 = /* reduce */Base[/* reduceKeys */6];
  var keysSequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstKeyOrRaise,
    keysSequentialCollectionBase_002,
    /* toSequence */keysSequence
  ];
  var keysSequentialCollectionReversedBase_002 = /* reduce */Base[/* reduceKeysReversed */7];
  var keysSequentialCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastKeyOrRaise,
    keysSequentialCollectionReversedBase_002,
    /* toSequence */keysSequenceReversed
  ];
  var keysSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionBase
            ];
    }
  };
  var keysSequentialCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionReversedBase
            ];
    }
  };
  var keysNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionBase,
              keysSequentialCollectionReversedBase
            ];
    }
  };
  var keysNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              keysSequentialCollectionReversedBase,
              keysSequentialCollectionBase
            ];
    }
  };
  var valuesSequentialCollectionBase_002 = /* reduce */Base[/* reduceValues */8];
  var valuesSequentialCollectionBase = /* record */[
    /* count */count,
    /* firstOrRaise */firstValueOrRaise,
    valuesSequentialCollectionBase_002,
    /* toSequence */valuesSequence
  ];
  var valuesSequentialCollectionReversedBase_002 = /* reduce */Base[/* reduceValuesReversed */9];
  var valuesSequentialCollectionReversedBase = /* record */[
    /* count */count,
    /* firstOrRaise */lastValueOrRaise,
    valuesSequentialCollectionReversedBase_002,
    /* toSequence */valuesSequenceReversed
  ];
  var valuesSequentialCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionBase
            ];
    }
  };
  var valuesSequentialCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return SequentialCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionReversedBase
            ];
    }
  };
  var valuesNavigableCollection = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionBase,
              valuesSequentialCollectionReversedBase
            ];
    }
  };
  var valuesNavigableCollectionReversed = function (collection) {
    if (Curry._1(isEmpty, collection)) {
      return NavigableCollection.empty(/* () */0);
    } else {
      return /* Instance */[
              collection,
              valuesSequentialCollectionReversedBase,
              valuesSequentialCollectionBase
            ];
    }
  };
  var sequentialKeyedCollectionBase_003 = /* reduce */Base[/* reduce */4];
  var sequentialKeyedCollectionBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */firstOrRaise,
    sequentialKeyedCollectionBase_003,
    /* toSequence */toSequence
  ];
  var sequentialKeyedCollectionReversedBase_003 = /* reduce */Base[/* reduceReversed */5];
  var sequentialKeyedCollectionReversedBase = /* record */[
    /* containsKey */containsKey,
    /* count */count,
    /* firstOrRaise */lastOrRaise,
    sequentialKeyedCollectionReversedBase_003,
    /* toSequence */toSequenceReversed
  ];
  var toNavigableKeyedCollection = function (keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyed,
              sequentialKeyedCollectionBase,
              sequentialKeyedCollectionReversedBase
            ];
    }
  };
  var toNavigableKeyedCollectionReversed = function (keyed) {
    if (Curry._1(isEmpty, keyed)) {
      return /* Empty */0;
    } else {
      return /* Instance */[
              keyed,
              sequentialKeyedCollectionReversedBase,
              sequentialKeyedCollectionBase
            ];
    }
  };
  return /* module */[
          /* every */include[0],
          /* find */include[1],
          /* findOrRaise */include[2],
          /* forEach */include[3],
          /* keys */include[4],
          /* none */include[5],
          /* reduce */include[6],
          /* reduceKeys */include[7],
          /* reduceValues */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* toKeyedIterable */include[11],
          /* values */include[12],
          /* containsKey */containsKey,
          /* count */count,
          /* isEmpty */isEmpty,
          /* isNotEmpty */include[16],
          /* keysCollection */include[17],
          /* keysSequence */keysSequence,
          /* toKeyedCollection */include[19],
          /* toSequence */toSequence,
          /* valuesCollection */include[21],
          /* valuesSequence */valuesSequence,
          /* first */first,
          /* firstOrRaise */firstOrRaise,
          /* keysCollectionReversed */keysCollectionReversed,
          /* keysNavigableCollection */keysNavigableCollection,
          /* keysNavigableCollectionReversed */keysNavigableCollectionReversed,
          /* keysReversed */keysReversed,
          /* keysSequentialCollection */keysSequentialCollection,
          /* keysSequentialCollectionReversed */keysSequentialCollectionReversed,
          /* keysSequenceReversed */keysSequenceReversed,
          /* last */last,
          /* lastOrRaise */lastOrRaise,
          /* reduceReversed */reduceReversed,
          /* reduceKeysReversed */reduceKeysReversed,
          /* reduceValuesReversed */reduceValuesReversed,
          /* toIterableReversed */toIterableReversed,
          /* toKeyedCollectionReversed */toKeyedCollectionReversed,
          /* toKeyedIterableReversed */toKeyedIterableReversed,
          /* toNavigableKeyedCollection */toNavigableKeyedCollection,
          /* toNavigableKeyedCollectionReversed */toNavigableKeyedCollectionReversed,
          /* toSequenceReversed */toSequenceReversed,
          /* valuesCollectionReversed */valuesCollectionReversed,
          /* valuesNavigableCollection */valuesNavigableCollection,
          /* valuesNavigableCollectionReversed */valuesNavigableCollectionReversed,
          /* valuesReversed */valuesReversed,
          /* valuesSequentialCollection */valuesSequentialCollection,
          /* valuesSequentialCollectionReversed */valuesSequentialCollectionReversed,
          /* valuesSequenceReversed */valuesSequenceReversed
        ];
}

function containsKey(key, keyed) {
  if (keyed) {
    return Curry._2(keyed[1][/* containsKey */0], key, keyed[0]);
  } else {
    return /* false */0;
  }
}

function count(keyed) {
  if (keyed) {
    return Curry._1(keyed[1][/* count */1], keyed[0]);
  } else {
    return 0;
  }
}

function firstOrRaise(selector, keyed) {
  if (keyed) {
    return Curry._2(keyed[1][/* firstOrRaise */2], selector, keyed[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function lastOrRaise(selector, keyed) {
  if (keyed) {
    return Curry._2(keyed[2][/* firstOrRaise */2], selector, keyed[0]);
  } else {
    return Pervasives.failwith("empty");
  }
}

function reduce(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[1][/* reduce */3], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

var reduce$1 = include[0];

var reduceKeys = include[1];

var reduceValues = include[2];

function reduce$2(predicate, f, acc, iter) {
  if (iter) {
    return Curry._4(iter[2][/* reduce */3], predicate, f, acc, iter[0]);
  } else {
    return acc;
  }
}

var KeyedReducerReversed = KeyedReducer.Make2(/* module */[/* reduce */reduce$2]);

var reduceReversed = KeyedReducerReversed[/* reduce */0];

var reduceKeysReversed = KeyedReducerReversed[/* reduceKeys */1];

var reduceValuesReversed = KeyedReducerReversed[/* reduceValues */2];

function toSequence(selector, keyed) {
  if (keyed) {
    return Curry._2(keyed[1][/* toSequence */4], selector, keyed[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

function toSequenceReversed(selector, keyed) {
  if (keyed) {
    return Curry._2(keyed[2][/* toSequence */4], selector, keyed[0]);
  } else {
    return Sequence.empty(/* () */0);
  }
}

var include$1 = KeyedCollection.Make2([
      containsKey,
      count,
      reduce$1,
      reduceKeys,
      reduceValues,
      toSequence
    ]);

var containsKey$1 = include$1[13];

var count$1 = include$1[14];

var isEmpty = include$1[15];

var keysSequence = include$1[18];

var toSequence$1 = include$1[20];

var valuesSequence = include$1[22];

function first(selector, keyed) {
  if (Curry._1(isEmpty, keyed)) {
    return /* None */0;
  } else {
    return /* Some */[firstOrRaise(selector, keyed)];
  }
}

function last(selector, keyed) {
  if (Curry._1(isEmpty, keyed)) {
    return /* None */0;
  } else {
    return /* Some */[lastOrRaise(selector, keyed)];
  }
}

var ReversedKeyedCollection = KeyedCollection.Make2(/* module */[
      /* containsKey */containsKey$1,
      /* count */count$1,
      /* reduce */reduceReversed,
      /* reduceKeys */reduceKeysReversed,
      /* reduceValues */reduceValuesReversed,
      /* toSequence */toSequenceReversed
    ]);

var keysCollectionReversed = ReversedKeyedCollection[/* keysCollection */17];

var keysReversed = ReversedKeyedCollection[/* keys */4];

var keysSequenceReversed = ReversedKeyedCollection[/* keysSequence */18];

var reduceReversed$1 = ReversedKeyedCollection[/* reduce */6];

var reduceKeysReversed$1 = ReversedKeyedCollection[/* reduceKeys */7];

var reduceValuesReversed$1 = ReversedKeyedCollection[/* reduceValues */8];

var toIterableReversed = ReversedKeyedCollection[/* toIterable */10];

var toKeyedCollectionReversed = ReversedKeyedCollection[/* toKeyedCollection */19];

var toKeyedIterableReversed = ReversedKeyedCollection[/* toKeyedIterable */11];

var toSequenceReversed$1 = ReversedKeyedCollection[/* toSequence */20];

var valuesCollectionReversed = ReversedKeyedCollection[/* valuesCollection */21];

var valuesReversed = ReversedKeyedCollection[/* values */12];

var valuesSequenceReversed = ReversedKeyedCollection[/* valuesSequence */22];

function firstKeyOrRaise(collection) {
  return firstOrRaise(Functions.getKey, collection);
}

function lastKeyOrRaise(collection) {
  return lastOrRaise(Functions.getKey, collection);
}

function firstValueOrRaise(collection) {
  return firstOrRaise(Functions.getValue, collection);
}

function lastValueOrRaise(collection) {
  return lastOrRaise(Functions.getValue, collection);
}

var keysSequentialCollectionBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */firstKeyOrRaise,
  /* reduce */reduceKeys,
  /* toSequence */keysSequence
];

var keysSequentialCollectionReversedBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */lastKeyOrRaise,
  /* reduce */reduceKeysReversed,
  /* toSequence */keysSequenceReversed
];

function keysSequentialCollection(collection) {
  if (Curry._1(isEmpty, collection)) {
    return SequentialCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            keysSequentialCollectionBase
          ];
  }
}

function keysSequentialCollectionReversed(collection) {
  if (Curry._1(isEmpty, collection)) {
    return SequentialCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            keysSequentialCollectionReversedBase
          ];
  }
}

function keysNavigableCollection(collection) {
  if (Curry._1(isEmpty, collection)) {
    return NavigableCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            keysSequentialCollectionBase,
            keysSequentialCollectionReversedBase
          ];
  }
}

function keysNavigableCollectionReversed(collection) {
  if (Curry._1(isEmpty, collection)) {
    return NavigableCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            keysSequentialCollectionReversedBase,
            keysSequentialCollectionBase
          ];
  }
}

var valuesSequentialCollectionBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */firstValueOrRaise,
  /* reduce */reduceValues,
  /* toSequence */valuesSequence
];

var valuesSequentialCollectionReversedBase = /* record */[
  /* count */count$1,
  /* firstOrRaise */lastValueOrRaise,
  /* reduce */reduceValuesReversed,
  /* toSequence */valuesSequenceReversed
];

function valuesSequentialCollection(collection) {
  if (Curry._1(isEmpty, collection)) {
    return SequentialCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            valuesSequentialCollectionBase
          ];
  }
}

function valuesSequentialCollectionReversed(collection) {
  if (Curry._1(isEmpty, collection)) {
    return SequentialCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            valuesSequentialCollectionReversedBase
          ];
  }
}

function valuesNavigableCollection(collection) {
  if (Curry._1(isEmpty, collection)) {
    return NavigableCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            valuesSequentialCollectionBase,
            valuesSequentialCollectionReversedBase
          ];
  }
}

function valuesNavigableCollectionReversed(collection) {
  if (Curry._1(isEmpty, collection)) {
    return NavigableCollection.empty(/* () */0);
  } else {
    return /* Instance */[
            collection,
            valuesSequentialCollectionReversedBase,
            valuesSequentialCollectionBase
          ];
  }
}

var sequentialKeyedCollectionBase = /* record */[
  /* containsKey */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */firstOrRaise,
  /* reduce */reduce$1,
  /* toSequence */toSequence$1
];

var sequentialKeyedCollectionReversedBase = /* record */[
  /* containsKey */containsKey$1,
  /* count */count$1,
  /* firstOrRaise */lastOrRaise,
  /* reduce */reduceReversed,
  /* toSequence */toSequenceReversed$1
];

function toNavigableKeyedCollectionReversed(keyed) {
  if (Curry._1(isEmpty, keyed)) {
    return /* Empty */0;
  } else {
    return /* Instance */[
            keyed,
            sequentialKeyedCollectionReversedBase,
            sequentialKeyedCollectionBase
          ];
  }
}

function empty() {
  return /* Empty */0;
}

function toNavigableKeyedCollection(keyed) {
  return keyed;
}

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var keys = include$1[4];

var none = include$1[5];

var reduce$3 = include$1[6];

var reduceKeys$1 = include$1[7];

var reduceValues$1 = include$1[8];

var some = include$1[9];

var toIterable = include$1[10];

var toKeyedIterable = include$1[11];

var values = include$1[12];

var isNotEmpty = include$1[16];

var keysCollection = include$1[17];

var toKeyedCollection = include$1[19];

var valuesCollection = include$1[21];

exports.Make1                              = Make1;
exports.Make2                              = Make2;
exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.keys                               = keys;
exports.none                               = none;
exports.reduce                             = reduce$3;
exports.reduceKeys                         = reduceKeys$1;
exports.reduceValues                       = reduceValues$1;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.toKeyedIterable                    = toKeyedIterable;
exports.values                             = values;
exports.containsKey                        = containsKey$1;
exports.count                              = count$1;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.keysCollection                     = keysCollection;
exports.keysSequence                       = keysSequence;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toSequence                         = toSequence$1;
exports.valuesCollection                   = valuesCollection;
exports.valuesSequence                     = valuesSequence;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise;
exports.keysCollectionReversed             = keysCollectionReversed;
exports.keysNavigableCollection            = keysNavigableCollection;
exports.keysNavigableCollectionReversed    = keysNavigableCollectionReversed;
exports.keysReversed                       = keysReversed;
exports.keysSequentialCollection           = keysSequentialCollection;
exports.keysSequentialCollectionReversed   = keysSequentialCollectionReversed;
exports.keysSequenceReversed               = keysSequenceReversed;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise;
exports.reduceReversed                     = reduceReversed$1;
exports.reduceKeysReversed                 = reduceKeysReversed$1;
exports.reduceValuesReversed               = reduceValuesReversed$1;
exports.toIterableReversed                 = toIterableReversed;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed$1;
exports.valuesCollectionReversed           = valuesCollectionReversed;
exports.valuesNavigableCollection          = valuesNavigableCollection;
exports.valuesNavigableCollectionReversed  = valuesNavigableCollectionReversed;
exports.valuesReversed                     = valuesReversed;
exports.valuesSequentialCollection         = valuesSequentialCollection;
exports.valuesSequentialCollectionReversed = valuesSequentialCollectionReversed;
exports.valuesSequenceReversed             = valuesSequenceReversed;
exports.empty                              = empty;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
/* include Not a pure module */


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry                   = __webpack_require__(1);
var Indexed                 = __webpack_require__(76);
var Sequence                = __webpack_require__(56);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var Caml_array              = __webpack_require__(7);
var Pervasives              = __webpack_require__(2);
var IndexedTrie             = __webpack_require__(75);
var Preconditions           = __webpack_require__(63);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function count(param) {
  var leftCount = Curry._1(CopyOnWriteArray.count, param[/* left */0]);
  var middleCount = IndexedTrie.count(param[/* middle */1]);
  var rightCount = Curry._1(CopyOnWriteArray.count, param[/* right */2]);
  return (leftCount + middleCount | 0) + rightCount | 0;
}

function getOrRaise(index, param) {
  var middle = param[/* middle */1];
  var left = param[/* left */0];
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    return Caml_array.caml_array_get(left, index);
  } else if (rightIndex >= 0) {
    return Caml_array.caml_array_get(param[/* right */2], rightIndex);
  } else {
    var index$1 = index - leftCount | 0;
    return IndexedTrie.get(index$1, middle);
  }
}

function reduce(predicate, f, acc, vec) {
  if (predicate === Functions.alwaysTrue2) {
    var f$1 = f;
    var acc$1 = acc;
    var param = vec;
    var acc$2 = Curry._4(CopyOnWriteArray.reduce, /* None */0, f$1, acc$1, param[/* left */0]);
    var acc$3 = IndexedTrie.reduce(f$1, acc$2, param[/* middle */1]);
    return Curry._4(CopyOnWriteArray.reduce, /* None */0, f$1, acc$3, param[/* right */2]);
  } else {
    var predicate$1 = predicate;
    var f$2 = f;
    var acc$4 = acc;
    var param$1 = vec;
    var shouldContinue = [/* true */1];
    var predicate$2 = function (acc, next) {
      var result = Curry._2(predicate$1, acc, next);
      shouldContinue[0] = result;
      return result;
    };
    var triePredicate = function (_, _$1) {
      return shouldContinue[0];
    };
    var trieReducer = function (acc) {
      return (function (param) {
          return IndexedTrie.reduceWhileWithResult(triePredicate, trieReducer, predicate$2, f$2, acc, param);
        });
    };
    var acc$5 = Curry._4(CopyOnWriteArray.reduce, /* Some */[predicate$2], f$2, acc$4, param$1[/* left */0]);
    var acc$6 = shouldContinue[0] ? IndexedTrie.reduceWhileWithResult(triePredicate, trieReducer, predicate$2, f$2, acc$5, param$1[/* middle */1]) : acc$5;
    if (shouldContinue[0]) {
      return Curry._4(CopyOnWriteArray.reduce, /* Some */[predicate$2], f$2, acc$6, param$1[/* right */2]);
    } else {
      return acc$6;
    }
  }
}

function reduceReversed(predicate, f, acc, vec) {
  if (predicate === Functions.alwaysTrue2) {
    var f$1 = f;
    var acc$1 = acc;
    var param = vec;
    var acc$2 = Curry._4(CopyOnWriteArray.reduceReversed, /* None */0, f$1, acc$1, param[/* right */2]);
    var acc$3 = IndexedTrie.reduceReversed(f$1, acc$2, param[/* middle */1]);
    return Curry._4(CopyOnWriteArray.reduceReversed, /* None */0, f$1, acc$3, param[/* left */0]);
  } else {
    var predicate$1 = predicate;
    var f$2 = f;
    var acc$4 = acc;
    var param$1 = vec;
    var shouldContinue = [/* true */1];
    var predicate$2 = function (acc, next) {
      var result = Curry._2(predicate$1, acc, next);
      shouldContinue[0] = result;
      return result;
    };
    var triePredicate = function (_, _$1) {
      return shouldContinue[0];
    };
    var trieReducer = function (acc) {
      return (function (param) {
          return IndexedTrie.reduceReversedWhileWithResult(triePredicate, trieReducer, predicate$2, f$2, acc, param);
        });
    };
    var acc$5 = Curry._4(CopyOnWriteArray.reduceReversed, /* Some */[predicate$2], f$2, acc$4, param$1[/* right */2]);
    var acc$6 = shouldContinue[0] ? IndexedTrie.reduceReversedWhileWithResult(triePredicate, trieReducer, predicate$2, f$2, acc$5, param$1[/* middle */1]) : acc$5;
    if (shouldContinue[0]) {
      return Curry._4(CopyOnWriteArray.reduceReversed, /* Some */[predicate$2], f$2, acc$6, param$1[/* left */0]);
    } else {
      return acc$6;
    }
  }
}

function toSequence(param) {
  return Sequence.concat(/* :: */[
              Curry._1(CopyOnWriteArray.toSequence, param[/* left */0]),
              /* :: */[
                IndexedTrie.toSequence(param[/* middle */1]),
                /* :: */[
                  Curry._1(CopyOnWriteArray.toSequence, param[/* right */2]),
                  /* [] */0
                ]
              ]
            ]);
}

function toSequenceReversed(param) {
  return Sequence.concat(/* :: */[
              Curry._1(CopyOnWriteArray.toSequenceReversed, param[/* right */2]),
              /* :: */[
                IndexedTrie.toSequenceReversed(param[/* middle */1]),
                /* :: */[
                  Curry._1(CopyOnWriteArray.toSequenceReversed, param[/* left */0]),
                  /* [] */0
                ]
              ]
            ]);
}

var include = Indexed.Make1(/* module */[
      /* count */count,
      /* getOrRaise */getOrRaise,
      /* reduce */reduce,
      /* reduceReversed */reduceReversed,
      /* toSequence */toSequence,
      /* toSequenceReversed */toSequenceReversed
    ]);

var count$1 = include[8];

var emptyInstance_000 = /* left : array */[];

var emptyInstance_002 = /* right : array */[];

var emptyInstance = /* record */[
  emptyInstance_000,
  /* middle */IndexedTrie.empty,
  emptyInstance_002
];

function empty() {
  return emptyInstance;
}

function tailIsFull(arr) {
  return +(Curry._1(CopyOnWriteArray.count, arr) === IndexedTrie.width);
}

function tailIsNotFull(arr) {
  return +(Curry._1(CopyOnWriteArray.count, arr) !== IndexedTrie.width);
}

function addFirst(value, param) {
  var right = param[/* right */2];
  var middle = param[/* middle */1];
  var left = param[/* left */0];
  if (Curry._1(CopyOnWriteArray.count, left) === IndexedTrie.width && Curry._1(CopyOnWriteArray.isNotEmpty, right)) {
    return /* record */[
            /* left : array */[value],
            /* middle */IndexedTrie.addFirstLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], left, middle),
            /* right */right
          ];
  } else if (Curry._1(CopyOnWriteArray.count, left) === IndexedTrie.width && Curry._1(CopyOnWriteArray.isEmpty, right)) {
    return /* record */[
            /* left : array */[value],
            /* middle */middle,
            /* right */left
          ];
  } else {
    return /* record */[
            /* left */CopyOnWriteArray.addFirst(value, left),
            /* middle */middle,
            /* right */right
          ];
  }
}

function addLast(value, param) {
  var right = param[/* right */2];
  var middle = param[/* middle */1];
  var left = param[/* left */0];
  if (Curry._1(CopyOnWriteArray.count, left) !== IndexedTrie.width && Curry._1(CopyOnWriteArray.isEmpty, right)) {
    return /* record */[
            /* left */CopyOnWriteArray.addLast(value, left),
            /* middle */middle,
            /* right */right
          ];
  } else if (Curry._1(CopyOnWriteArray.count, right) !== IndexedTrie.width) {
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right */CopyOnWriteArray.addLast(value, right)
          ];
  } else {
    return /* record */[
            /* left */left,
            /* middle */IndexedTrie.addLastLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], right, middle),
            /* right : array */[value]
          ];
  }
}

function removeAll() {
  return emptyInstance;
}

function removeFirstOrRaise(param) {
  var right = param[/* right */2];
  var middle = param[/* middle */1];
  var left = param[/* left */0];
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  var rightCount = Curry._1(CopyOnWriteArray.count, right);
  if (leftCount > 1) {
    return /* record */[
            /* left */CopyOnWriteArray.removeFirstOrRaise(left),
            /* middle */middle,
            /* right */right
          ];
  } else if (middleCount > 0) {
    var match = IndexedTrie.removeFirstLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], middle);
    var match$1 = match[0];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/PersistentVector.re",
              218,
              8
            ]
          ];
    } else if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/PersistentVector.re",
              218,
              8
            ]
          ];
    } else {
      return /* record */[
              /* left */match$1[1],
              /* middle */match[1],
              /* right */right
            ];
    }
  } else if (rightCount > 0) {
    return /* record */[
            /* left */right,
            /* middle */middle,
            /* right : array */[]
          ];
  } else if (leftCount === 1) {
    return emptyInstance;
  } else {
    return Pervasives.failwith("vector is empty");
  }
}

function removeLastOrRaise(param) {
  var right = param[/* right */2];
  var middle = param[/* middle */1];
  var left = param[/* left */0];
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  var rightCount = Curry._1(CopyOnWriteArray.count, right);
  if (rightCount > 1) {
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right */CopyOnWriteArray.removeLastOrRaise(right)
          ];
  } else if (middleCount > 0) {
    var match = IndexedTrie.removeLastLeafUsingMutator(IndexedTrie.updateLevelPersistent, Transient.Owner[/* none */1], middle);
    var match$1 = match[1];
    if (typeof match$1 === "number") {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/PersistentVector.re",
              242,
              10
            ]
          ];
    } else if (match$1.tag) {
      throw [
            Caml_builtin_exceptions.match_failure,
            [
              "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/indexed/PersistentVector.re",
              242,
              10
            ]
          ];
    } else {
      return /* record */[
              /* left */left,
              /* middle */match[0],
              /* right */match$1[1]
            ];
    }
  } else if (rightCount === 1) {
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right : array */[]
          ];
  } else if (leftCount > 0) {
    return /* record */[
            /* left */CopyOnWriteArray.removeLastOrRaise(left),
            /* middle */middle,
            /* right */right
          ];
  } else {
    return Pervasives.failwith("vector is empty");
  }
}

function $$return(value) {
  return addLast(value, emptyInstance);
}

function update(index, value, vector) {
  var right = vector[/* right */2];
  var middle = vector[/* middle */1];
  var left = vector[/* left */0];
  Preconditions.failIfOutOfRange(Curry._1(count$1, vector), index);
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    return /* record */[
            /* left */CopyOnWriteArray.update(index, value, left),
            /* middle */middle,
            /* right */right
          ];
  } else if (rightIndex >= 0) {
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right */CopyOnWriteArray.update(rightIndex, value, right)
          ];
  } else {
    var index$1 = index - leftCount | 0;
    var middle$1 = IndexedTrie.updateUsingMutator(IndexedTrie.updateLevelPersistent, IndexedTrie.updateLeafPersistent, Transient.Owner[/* none */1], index$1, value, middle);
    return /* record */[
            /* left */left,
            /* middle */middle$1,
            /* right */right
          ];
  }
}

function updateWith(index, f, vector) {
  var right = vector[/* right */2];
  var middle = vector[/* middle */1];
  var left = vector[/* left */0];
  Preconditions.failIfOutOfRange(Curry._1(count$1, vector), index);
  var leftCount = Curry._1(CopyOnWriteArray.count, left);
  var middleCount = IndexedTrie.count(middle);
  var rightIndex = (index - middleCount | 0) - leftCount | 0;
  if (index < leftCount) {
    return /* record */[
            /* left */CopyOnWriteArray.updateWith(index, f, left),
            /* middle */middle,
            /* right */right
          ];
  } else if (rightIndex >= 0) {
    return /* record */[
            /* left */left,
            /* middle */middle,
            /* right */CopyOnWriteArray.updateWith(rightIndex, f, right)
          ];
  } else {
    var index$1 = index - leftCount | 0;
    var middle$1 = IndexedTrie.updateWithUsingMutator(IndexedTrie.updateLevelPersistent, IndexedTrie.updateLeafPersistent, Transient.Owner[/* none */1], index$1, f, middle);
    return /* record */[
            /* left */left,
            /* middle */middle$1,
            /* right */right
          ];
  }
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var isEmpty = include[9];

var isNotEmpty = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

var first = include[13];

var firstOrRaise = include[14];

var toSequentialCollection = include[15];

var last = include[16];

var lastOrRaise = include[17];

var reduceReversed$1 = include[18];

var toCollectionReversed = include[19];

var toIterableReversed = include[20];

var toNavigableCollection = include[21];

var toNavigableCollectionReversed = include[22];

var toSequenceReversed$1 = include[23];

var toSequentialCollectionReversed = include[24];

var get = include[25];

var getOrDefault = include[26];

var getOrRaise$1 = include[27];

var toIndexed = include[28];

var toIndexedReversed = include[29];

var toKeyedCollection = include[30];

var toKeyedCollectionReversed = include[31];

var toKeyedIterable = include[32];

var toKeyedIterableReversed = include[33];

var toMap = include[34];

var toMapReversed = include[35];

var toNavigableKeyedCollection = include[36];

var toNavigableKeyedCollectionReversed = include[37];

var toNavigableMap = include[38];

var toNavigableMapReversed = include[39];

exports.every                              = every;
exports.find                               = find;
exports.findOrRaise                        = findOrRaise;
exports.forEach                            = forEach;
exports.none                               = none;
exports.reduce                             = reduce$1;
exports.some                               = some;
exports.toIterable                         = toIterable;
exports.count                              = count$1;
exports.isEmpty                            = isEmpty;
exports.isNotEmpty                         = isNotEmpty;
exports.toCollection                       = toCollection;
exports.toSequence                         = toSequence$1;
exports.first                              = first;
exports.firstOrRaise                       = firstOrRaise;
exports.toSequentialCollection             = toSequentialCollection;
exports.last                               = last;
exports.lastOrRaise                        = lastOrRaise;
exports.reduceReversed                     = reduceReversed$1;
exports.toCollectionReversed               = toCollectionReversed;
exports.toIterableReversed                 = toIterableReversed;
exports.toNavigableCollection              = toNavigableCollection;
exports.toNavigableCollectionReversed      = toNavigableCollectionReversed;
exports.toSequenceReversed                 = toSequenceReversed$1;
exports.toSequentialCollectionReversed     = toSequentialCollectionReversed;
exports.get                                = get;
exports.getOrDefault                       = getOrDefault;
exports.getOrRaise                         = getOrRaise$1;
exports.toIndexed                          = toIndexed;
exports.toIndexedReversed                  = toIndexedReversed;
exports.toKeyedCollection                  = toKeyedCollection;
exports.toKeyedCollectionReversed          = toKeyedCollectionReversed;
exports.toKeyedIterable                    = toKeyedIterable;
exports.toKeyedIterableReversed            = toKeyedIterableReversed;
exports.toMap                              = toMap;
exports.toMapReversed                      = toMapReversed;
exports.toNavigableKeyedCollection         = toNavigableKeyedCollection;
exports.toNavigableKeyedCollectionReversed = toNavigableKeyedCollectionReversed;
exports.toNavigableMap                     = toNavigableMap;
exports.toNavigableMapReversed             = toNavigableMapReversed;
exports.emptyInstance                      = emptyInstance;
exports.empty                              = empty;
exports.tailIsFull                         = tailIsFull;
exports.tailIsNotFull                      = tailIsNotFull;
exports.addFirst                           = addFirst;
exports.addLast                            = addLast;
exports.removeAll                          = removeAll;
exports.removeFirstOrRaise                 = removeFirstOrRaise;
exports.removeLastOrRaise                  = removeLastOrRaise;
exports.$$return                           = $$return;
exports.update                             = update;
exports.updateWith                         = updateWith;
/* include Not a pure module */


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block         = __webpack_require__(25);
var Curry         = __webpack_require__(1);
var Option        = __webpack_require__(61);
var Ordering      = __webpack_require__(65);
var Sequence      = __webpack_require__(56);
var Functions     = __webpack_require__(55);
var Pervasives    = __webpack_require__(2);
var Preconditions = __webpack_require__(63);

function containsKey(comparator, xK, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return /* false */0;
    } else if (tree.tag) {
      var k = tree[2];
      if (xK === k) {
        return /* true */1;
      } else {
        var cmp = Curry._2(comparator, xK, k);
        if (cmp === Ordering.lessThan) {
          _tree = tree[1];
          continue ;
          
        } else if (cmp === Ordering.greaterThan) {
          _tree = tree[4];
          continue ;
          
        } else {
          return /* true */1;
        }
      }
    } else {
      var k$1 = tree[0];
      if (xK === k$1) {
        return /* true */1;
      } else {
        var cmp$1 = Curry._2(comparator, xK, k$1);
        return +(cmp$1 === Ordering.equal);
      }
    }
  };
}

function firstOrRaise(selector, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return Preconditions.failEmpty(/* () */0);
    } else if (tree.tag) {
      var left = tree[1];
      if (typeof left === "number") {
        return Curry._2(selector, tree[2], tree[3]);
      } else {
        _tree = left;
        continue ;
        
      }
    } else {
      return Curry._2(selector, tree[0], tree[1]);
    }
  };
}

function get(comparator, xK, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return /* None */0;
    } else if (tree.tag) {
      var v = tree[3];
      var k = tree[2];
      if (xK === k) {
        return /* Some */[v];
      } else {
        var cmp = Curry._2(comparator, xK, k);
        if (cmp === Ordering.lessThan) {
          _tree = tree[1];
          continue ;
          
        } else if (cmp === Ordering.greaterThan) {
          _tree = tree[4];
          continue ;
          
        } else {
          return /* Some */[v];
        }
      }
    } else {
      var v$1 = tree[1];
      var k$1 = tree[0];
      if (xK === k$1) {
        return /* Some */[v$1];
      } else {
        var cmp$1 = Curry._2(comparator, xK, k$1);
        if (cmp$1 === Ordering.equal) {
          return /* Some */[v$1];
        } else {
          return /* None */0;
        }
      }
    }
  };
}

function getOrDefault(comparator, $$default, xK, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return $$default;
    } else if (tree.tag) {
      var v = tree[3];
      var k = tree[2];
      if (xK === k) {
        return v;
      } else {
        var cmp = Curry._2(comparator, xK, k);
        if (cmp === Ordering.lessThan) {
          _tree = tree[1];
          continue ;
          
        } else if (cmp === Ordering.greaterThan) {
          _tree = tree[4];
          continue ;
          
        } else {
          return v;
        }
      }
    } else {
      var v$1 = tree[1];
      var k$1 = tree[0];
      if (xK === k$1) {
        return v$1;
      } else {
        var cmp$1 = Curry._2(comparator, xK, k$1);
        if (cmp$1 === Ordering.equal) {
          return v$1;
        } else {
          return $$default;
        }
      }
    }
  };
}

function getOrRaise(comparator, xK, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return Pervasives.failwith("Not found");
    } else if (tree.tag) {
      var v = tree[3];
      var k = tree[2];
      if (xK === k) {
        return v;
      } else {
        var cmp = Curry._2(comparator, xK, k);
        if (cmp === Ordering.lessThan) {
          _tree = tree[1];
          continue ;
          
        } else if (cmp === Ordering.greaterThan) {
          _tree = tree[4];
          continue ;
          
        } else {
          return v;
        }
      }
    } else {
      var v$1 = tree[1];
      var k$1 = tree[0];
      if (xK === k$1) {
        return v$1;
      } else {
        var cmp$1 = Curry._2(comparator, xK, k$1);
        if (cmp$1 === Ordering.equal) {
          return v$1;
        } else {
          return Pervasives.failwith("Not found");
        }
      }
    }
  };
}

function lastOrRaise(selector, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return Preconditions.failEmpty(/* () */0);
    } else if (tree.tag) {
      var right = tree[4];
      if (typeof right === "number") {
        return Curry._2(selector, tree[2], tree[3]);
      } else {
        _tree = right;
        continue ;
        
      }
    } else {
      return Curry._2(selector, tree[0], tree[1]);
    }
  };
}

function reduceWhile(predicate, f, _acc, _tree) {
  while(true) {
    var tree = _tree;
    var acc = _acc;
    if (typeof tree === "number") {
      return acc;
    } else if (tree.tag) {
      var v = tree[3];
      var k = tree[2];
      var acc$1 = reduceWhile(predicate, f, acc, tree[1]);
      if (Curry._3(predicate, acc$1, k, v)) {
        var acc$2 = Curry._3(f, acc$1, k, v);
        _tree = tree[4];
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      var v$1 = tree[1];
      var k$1 = tree[0];
      if (Curry._3(predicate, acc, k$1, v$1)) {
        return Curry._3(f, acc, k$1, v$1);
      } else {
        return acc;
      }
    }
  };
}

function reduce(predicate, f, acc, tree) {
  if (predicate === Functions.alwaysTrue3) {
    return reduceWhile(Functions.alwaysTrue3, f, acc, tree);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, k, v) {
      if (shouldContinue[0]) {
        var result = Curry._3(predicate, acc, k, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    return reduceWhile(predicate$1, f, acc, tree);
  }
}

function reduceReversedWhile(predicate, f, _acc, _tree) {
  while(true) {
    var tree = _tree;
    var acc = _acc;
    if (typeof tree === "number") {
      return acc;
    } else if (tree.tag) {
      var v = tree[3];
      var k = tree[2];
      var acc$1 = reduceReversedWhile(predicate, f, acc, tree[4]);
      if (Curry._3(predicate, acc$1, k, v)) {
        var acc$2 = Curry._3(f, acc$1, k, v);
        _tree = tree[1];
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      var v$1 = tree[1];
      var k$1 = tree[0];
      if (Curry._3(predicate, acc, k$1, v$1)) {
        return Curry._3(f, acc, k$1, v$1);
      } else {
        return acc;
      }
    }
  };
}

function reduceReversed(predicate, f, acc, tree) {
  if (predicate === Functions.alwaysTrue3) {
    return reduceReversedWhile(Functions.alwaysTrue3, f, acc, tree);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, k, v) {
      if (shouldContinue[0]) {
        var result = Curry._3(predicate, acc, k, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    return reduceReversedWhile(predicate$1, f, acc, tree);
  }
}

function height(tree) {
  if (typeof tree === "number") {
    return 0;
  } else if (tree.tag) {
    return tree[0];
  } else {
    return 1;
  }
}

function makeTree(left, k, v, right) {
  var lh = height(left);
  var rh = height(right);
  var exit = 0;
  if (typeof left === "number") {
    if (typeof right === "number") {
      return /* Leaf */Block.__(0, [
                k,
                v
              ]);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var h = lh >= rh ? lh + 1 | 0 : rh + 1 | 0;
    return /* Node */Block.__(1, [
              h,
              left,
              k,
              v,
              right
            ]);
  }
  
}

function rebalance(left, k, v, right) {
  var lh = height(left);
  var rh = height(right);
  var exit = 0;
  var exit$1 = 0;
  if (typeof left === "number") {
    exit$1 = 2;
  } else if (left.tag) {
    if (lh > (rh + 2 | 0)) {
      var lr = left[4];
      var lv = left[3];
      var lk = left[2];
      var ll = left[1];
      var exit$2 = 0;
      if (typeof lr === "number") {
        exit$2 = 3;
      } else if (lr.tag) {
        if (height(ll) < lr[0]) {
          return makeTree(makeTree(ll, lk, lv, lr[1]), lr[2], lr[3], makeTree(lr[4], k, v, right));
        } else {
          exit$2 = 3;
        }
      } else {
        exit$2 = 3;
      }
      if (exit$2 === 3) {
        return makeTree(ll, lk, lv, makeTree(lr, k, v, right));
      }
      
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (typeof right === "number") {
      exit = 1;
    } else if (right.tag) {
      if (rh > (lh + 2 | 0)) {
        var rr = right[4];
        var rv = right[3];
        var rk = right[2];
        var rl = right[1];
        var exit$3 = 0;
        if (typeof rl === "number") {
          exit$3 = 3;
        } else if (rl.tag) {
          if (height(rr) < rl[0]) {
            return makeTree(makeTree(left, k, v, rl[1]), rl[2], rl[3], makeTree(rl[4], rk, rv, rr));
          } else {
            exit$3 = 3;
          }
        } else {
          exit$3 = 3;
        }
        if (exit$3 === 3) {
          return makeTree(makeTree(left, k, v, rl), rk, rv, rr);
        }
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var exit$4 = 0;
    if (typeof left === "number") {
      if (typeof right === "number") {
        return /* Leaf */Block.__(0, [
                  k,
                  v
                ]);
      } else {
        exit$4 = 2;
      }
    } else {
      exit$4 = 2;
    }
    if (exit$4 === 2) {
      var h = lh >= rh ? lh + 1 | 0 : rh + 1 | 0;
      return /* Node */Block.__(1, [
                h,
                left,
                k,
                v,
                right
              ]);
    }
    
  }
  
}

function removeFirstOrRaise(tree) {
  if (typeof tree === "number") {
    return Preconditions.failEmpty(/* () */0);
  } else if (tree.tag) {
    var left = tree[1];
    if (typeof left === "number") {
      return tree[4];
    } else {
      return rebalance(removeFirstOrRaise(left), tree[2], tree[3], tree[4]);
    }
  } else {
    return /* Empty */0;
  }
}

function removeLastOrRaise(tree) {
  if (typeof tree === "number") {
    return Preconditions.failEmpty(/* () */0);
  } else if (tree.tag) {
    var right = tree[4];
    var left = tree[1];
    if (typeof right === "number") {
      return left;
    } else {
      return rebalance(left, tree[2], tree[3], removeLastOrRaise(right));
    }
  } else {
    return /* Empty */0;
  }
}

function toSequence(selector, tree) {
  if (typeof tree === "number") {
    return Sequence.empty(/* () */0);
  } else if (tree.tag) {
    var right = tree[4];
    var left = tree[1];
    var partial_arg = Curry._2(selector, tree[2], tree[3]);
    return Sequence.concat(/* :: */[
                (function (param) {
                    return Sequence.defer((function () {
                                  return toSequence(selector, left);
                                }), param);
                  }),
                /* :: */[
                  (function (param) {
                      return Sequence.$$return(partial_arg, param);
                    }),
                  /* :: */[
                    (function (param) {
                        return Sequence.defer((function () {
                                      return toSequence(selector, right);
                                    }), param);
                      }),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    var partial_arg$1 = Curry._2(selector, tree[0], tree[1]);
    return (function (param) {
        return Sequence.$$return(partial_arg$1, param);
      });
  }
}

function toSequenceReversed(selector, tree) {
  if (typeof tree === "number") {
    return Sequence.empty(/* () */0);
  } else if (tree.tag) {
    var right = tree[4];
    var left = tree[1];
    var partial_arg = Curry._2(selector, tree[2], tree[3]);
    return Sequence.concat(/* :: */[
                (function (param) {
                    return Sequence.defer((function () {
                                  return toSequenceReversed(selector, right);
                                }), param);
                  }),
                /* :: */[
                  (function (param) {
                      return Sequence.$$return(partial_arg, param);
                    }),
                  /* :: */[
                    (function (param) {
                        return Sequence.defer((function () {
                                      return toSequenceReversed(selector, left);
                                    }), param);
                      }),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    var partial_arg$1 = Curry._2(selector, tree[0], tree[1]);
    return (function (param) {
        return Sequence.$$return(partial_arg$1, param);
      });
  }
}

function alter(comparator, result, xK, f, tree) {
  if (typeof tree === "number") {
    var match = Curry._1(f, /* None */0);
    if (match) {
      result[0] = /* Added */0;
      return /* Leaf */Block.__(0, [
                xK,
                match[0]
              ]);
    } else {
      result[0] = /* NoChange */1;
      return tree;
    }
  } else if (tree.tag) {
    var right = tree[4];
    var v = tree[3];
    var k = tree[2];
    var left = tree[1];
    var height = tree[0];
    var cmp = Curry._2(comparator, xK, k);
    if (cmp === Ordering.lessThan) {
      var newLeft = alter(comparator, result, xK, f, left);
      var match$1 = result[0];
      if (match$1 !== 0) {
        switch (match$1 - 1 | 0) {
          case 0 : 
              return tree;
          case 1 : 
              return rebalance(newLeft, k, v, right);
          case 2 : 
              return /* Node */Block.__(1, [
                        height,
                        newLeft,
                        k,
                        v,
                        right
                      ]);
          
        }
      } else {
        return rebalance(newLeft, k, v, right);
      }
    } else if (cmp === Ordering.greaterThan) {
      var newRight = alter(comparator, result, xK, f, right);
      var match$2 = result[0];
      if (match$2 !== 1) {
        if (match$2 !== 0) {
          return /* Node */Block.__(1, [
                    height,
                    left,
                    k,
                    v,
                    newRight
                  ]);
        } else {
          return rebalance(left, k, v, newRight);
        }
      } else {
        return tree;
      }
    } else {
      var match$3 = Curry._1(f, Option.$$return(v));
      if (match$3) {
        result[0] = /* Replace */3;
        return /* Node */Block.__(1, [
                  height,
                  left,
                  xK,
                  match$3[0],
                  right
                ]);
      } else {
        result[0] = /* Removed */2;
        if (typeof left === "number") {
          return right;
        } else if (typeof right === "number") {
          return left;
        } else {
          var match$4 = firstOrRaise(Functions.pairify, right);
          return rebalance(left, match$4[0], match$4[1], removeFirstOrRaise(right));
        }
      }
    }
  } else {
    var cmp$1 = Curry._2(comparator, xK, tree[0]);
    if (cmp$1 === Ordering.lessThan) {
      var match$5 = Curry._1(f, /* None */0);
      if (match$5) {
        result[0] = /* Added */0;
        return /* Node */Block.__(1, [
                  2,
                  /* Empty */0,
                  xK,
                  match$5[0],
                  tree
                ]);
      } else {
        result[0] = /* NoChange */1;
        return tree;
      }
    } else if (cmp$1 === Ordering.greaterThan) {
      var match$6 = Curry._1(f, /* None */0);
      if (match$6) {
        result[0] = /* Added */0;
        return /* Node */Block.__(1, [
                  2,
                  tree,
                  xK,
                  match$6[0],
                  /* Empty */0
                ]);
      } else {
        result[0] = /* NoChange */1;
        return tree;
      }
    } else {
      var match$7 = Curry._1(f, Option.$$return(tree[1]));
      if (match$7) {
        result[0] = /* Replace */3;
        return /* Leaf */Block.__(0, [
                  xK,
                  match$7[0]
                ]);
      } else {
        result[0] = /* Removed */2;
        return /* Empty */0;
      }
    }
  }
}

function put(comparator, xK, xV, tree) {
  if (typeof tree === "number") {
    return /* Leaf */Block.__(0, [
              xK,
              xV
            ]);
  } else if (tree.tag) {
    var right = tree[4];
    var v = tree[3];
    var k = tree[2];
    var left = tree[1];
    var cmp = Curry._2(comparator, xK, k);
    if (cmp === Ordering.lessThan) {
      var newLeft = put(comparator, xK, xV, left);
      if (newLeft === left) {
        return tree;
      } else {
        return rebalance(newLeft, k, v, right);
      }
    } else if (cmp === Ordering.greaterThan) {
      var newRight = put(comparator, xK, xV, right);
      if (newRight === right) {
        return tree;
      } else {
        return rebalance(left, k, v, newRight);
      }
    } else if (xV === v) {
      return tree;
    } else {
      return /* Node */Block.__(1, [
                tree[0],
                left,
                xK,
                xV,
                right
              ]);
    }
  } else {
    var cmp$1 = Curry._2(comparator, xK, tree[0]);
    if (cmp$1 === Ordering.lessThan) {
      return /* Node */Block.__(1, [
                2,
                /* Empty */0,
                xK,
                xV,
                tree
              ]);
    } else if (cmp$1 === Ordering.greaterThan) {
      return /* Node */Block.__(1, [
                2,
                tree,
                xK,
                xV,
                /* Empty */0
              ]);
    } else if (xV === tree[1]) {
      return tree;
    } else {
      return /* Leaf */Block.__(0, [
                xK,
                xV
              ]);
    }
  }
}

function putWithResult(comparator, result, xK, xV, tree) {
  if (typeof tree === "number") {
    result[0] = /* Added */0;
    return /* Leaf */Block.__(0, [
              xK,
              xV
            ]);
  } else if (tree.tag) {
    var right = tree[4];
    var v = tree[3];
    var k = tree[2];
    var left = tree[1];
    var cmp = Curry._2(comparator, xK, k);
    if (cmp === Ordering.lessThan) {
      var newLeft = putWithResult(comparator, result, xK, xV, left);
      if (newLeft === left) {
        return tree;
      } else {
        return rebalance(newLeft, k, v, right);
      }
    } else if (cmp === Ordering.greaterThan) {
      var newRight = putWithResult(comparator, result, xK, xV, right);
      if (newRight === right) {
        return tree;
      } else {
        return rebalance(left, k, v, newRight);
      }
    } else if (xV === v) {
      return tree;
    } else {
      result[0] = /* Replace */3;
      return /* Node */Block.__(1, [
                tree[0],
                left,
                xK,
                xV,
                right
              ]);
    }
  } else {
    var cmp$1 = Curry._2(comparator, xK, tree[0]);
    if (cmp$1 === Ordering.lessThan) {
      result[0] = /* Added */0;
      return /* Node */Block.__(1, [
                2,
                /* Empty */0,
                xK,
                xV,
                tree
              ]);
    } else if (cmp$1 === Ordering.greaterThan) {
      result[0] = /* Added */0;
      return /* Node */Block.__(1, [
                2,
                tree,
                xK,
                xV,
                /* Empty */0
              ]);
    } else if (xV === tree[1]) {
      return tree;
    } else {
      result[0] = /* Replace */3;
      return /* Leaf */Block.__(0, [
                xK,
                xV
              ]);
    }
  }
}

var maxHeightDiff = 2;

exports.containsKey         = containsKey;
exports.firstOrRaise        = firstOrRaise;
exports.get                 = get;
exports.getOrDefault        = getOrDefault;
exports.getOrRaise          = getOrRaise;
exports.lastOrRaise         = lastOrRaise;
exports.reduceWhile         = reduceWhile;
exports.reduce              = reduce;
exports.reduceReversedWhile = reduceReversedWhile;
exports.reduceReversed      = reduceReversed;
exports.height              = height;
exports.maxHeightDiff       = maxHeightDiff;
exports.makeTree            = makeTree;
exports.rebalance           = rebalance;
exports.removeFirstOrRaise  = removeFirstOrRaise;
exports.removeLastOrRaise   = removeLastOrRaise;
exports.toSequence          = toSequence;
exports.toSequenceReversed  = toSequenceReversed;
exports.alter               = alter;
exports.put                 = put;
exports.putWithResult       = putWithResult;
/* Sequence Not a pure module */


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block      = __webpack_require__(25);
var Curry      = __webpack_require__(1);
var Ordering   = __webpack_require__(65);
var Sequence   = __webpack_require__(56);
var Functions  = __webpack_require__(55);
var Pervasives = __webpack_require__(2);

function height(tree) {
  if (typeof tree === "number") {
    return 0;
  } else if (tree.tag) {
    return tree[0];
  } else {
    return 1;
  }
}

function makeTree(left, v, right) {
  var lh = height(left);
  var rh = height(right);
  var exit = 0;
  if (typeof left === "number") {
    if (typeof right === "number") {
      return /* Leaf */Block.__(0, [v]);
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var h = lh >= rh ? lh + 1 | 0 : rh + 1 | 0;
    return /* Node */Block.__(1, [
              h,
              left,
              v,
              right
            ]);
  }
  
}

function rebalance(left, v, right) {
  var lh = height(left);
  var rh = height(right);
  var exit = 0;
  var exit$1 = 0;
  if (typeof left === "number") {
    exit$1 = 2;
  } else if (left.tag) {
    if (lh > (rh + 2 | 0)) {
      var lr = left[3];
      var lv = left[2];
      var ll = left[1];
      var exit$2 = 0;
      if (typeof lr === "number") {
        exit$2 = 3;
      } else if (lr.tag) {
        if (height(ll) < lr[0]) {
          return makeTree(makeTree(ll, lv, lr[1]), lr[2], makeTree(lr[3], v, right));
        } else {
          exit$2 = 3;
        }
      } else {
        exit$2 = 3;
      }
      if (exit$2 === 3) {
        return makeTree(ll, lv, makeTree(lr, v, right));
      }
      
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (typeof right === "number") {
      exit = 1;
    } else if (right.tag) {
      if (rh > (lh + 2 | 0)) {
        var rr = right[3];
        var rv = right[2];
        var rl = right[1];
        var exit$3 = 0;
        if (typeof rl === "number") {
          exit$3 = 3;
        } else if (rl.tag) {
          if (height(rr) < rl[0]) {
            return makeTree(makeTree(left, v, rl[1]), rl[2], makeTree(rl[3], rv, rr));
          } else {
            exit$3 = 3;
          }
        } else {
          exit$3 = 3;
        }
        if (exit$3 === 3) {
          return makeTree(makeTree(left, v, rl), rv, rr);
        }
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    var exit$4 = 0;
    if (typeof left === "number") {
      if (typeof right === "number") {
        return /* Leaf */Block.__(0, [v]);
      } else {
        exit$4 = 2;
      }
    } else {
      exit$4 = 2;
    }
    if (exit$4 === 2) {
      var h = lh >= rh ? lh + 1 | 0 : rh + 1 | 0;
      return /* Node */Block.__(1, [
                h,
                left,
                v,
                right
              ]);
    }
    
  }
  
}

function add(comparator, x, tree) {
  if (typeof tree === "number") {
    return /* Leaf */Block.__(0, [x]);
  } else if (tree.tag) {
    var right = tree[3];
    var v = tree[2];
    var left = tree[1];
    var cmp = Curry._2(comparator, x, v);
    if (cmp === Ordering.lessThan) {
      var newLeft = add(comparator, x, left);
      if (newLeft === left) {
        return tree;
      } else {
        return rebalance(newLeft, v, right);
      }
    } else if (cmp === Ordering.greaterThan) {
      var newRight = add(comparator, x, right);
      if (newRight === right) {
        return tree;
      } else {
        return rebalance(left, v, newRight);
      }
    } else {
      return tree;
    }
  } else {
    var cmp$1 = Curry._2(comparator, x, tree[0]);
    if (cmp$1 === Ordering.lessThan) {
      return /* Node */Block.__(1, [
                2,
                /* Empty */0,
                x,
                tree
              ]);
    } else if (cmp$1 === Ordering.greaterThan) {
      return /* Node */Block.__(1, [
                2,
                tree,
                x,
                /* Empty */0
              ]);
    } else {
      return tree;
    }
  }
}

function contains(comparator, x, _tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return /* false */0;
    } else if (tree.tag) {
      var v = tree[2];
      if (x === v) {
        return /* true */1;
      } else {
        var cmp = Curry._2(comparator, x, v);
        if (cmp === Ordering.lessThan) {
          _tree = tree[1];
          continue ;
          
        } else if (cmp === Ordering.greaterThan) {
          _tree = tree[3];
          continue ;
          
        } else {
          return /* true */1;
        }
      }
    } else {
      var v$1 = tree[0];
      if (x === v$1) {
        return /* true */1;
      } else {
        var cmp$1 = Curry._2(comparator, x, v$1);
        return +(cmp$1 === Ordering.equal);
      }
    }
  };
}

function firstOrRaise(_tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return Pervasives.failwith("empty");
    } else if (tree.tag) {
      var left = tree[1];
      if (typeof left === "number") {
        return tree[2];
      } else {
        _tree = left;
        continue ;
        
      }
    } else {
      return tree[0];
    }
  };
}

function lastOrRaise(_tree) {
  while(true) {
    var tree = _tree;
    if (typeof tree === "number") {
      return Pervasives.failwith("empty");
    } else if (tree.tag) {
      var right = tree[3];
      if (typeof right === "number") {
        return tree[2];
      } else {
        _tree = right;
        continue ;
        
      }
    } else {
      return tree[0];
    }
  };
}

function reduceWhile(predicate, f, _acc, _tree) {
  while(true) {
    var tree = _tree;
    var acc = _acc;
    if (typeof tree === "number") {
      return acc;
    } else if (tree.tag) {
      var v = tree[2];
      var acc$1 = reduceWhile(predicate, f, acc, tree[1]);
      if (Curry._2(predicate, acc$1, v)) {
        var acc$2 = Curry._2(f, acc$1, v);
        _tree = tree[3];
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      var v$1 = tree[0];
      if (Curry._2(predicate, acc, v$1)) {
        return Curry._2(f, acc, v$1);
      } else {
        return acc;
      }
    }
  };
}

function reduce(predicate, f, acc, tree) {
  if (predicate === Functions.alwaysTrue2) {
    return reduceWhile(Functions.alwaysTrue2, f, acc, tree);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, v) {
      if (shouldContinue[0]) {
        var result = Curry._2(predicate, acc, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    return reduceWhile(predicate$1, f, acc, tree);
  }
}

function reduceReversedWhile(predicate, f, _acc, _tree) {
  while(true) {
    var tree = _tree;
    var acc = _acc;
    if (typeof tree === "number") {
      return acc;
    } else if (tree.tag) {
      var v = tree[2];
      var acc$1 = reduceReversedWhile(predicate, f, acc, tree[3]);
      if (Curry._2(predicate, acc$1, v)) {
        var acc$2 = Curry._2(f, acc$1, v);
        _tree = tree[1];
        _acc = acc$2;
        continue ;
        
      } else {
        return acc$1;
      }
    } else {
      var v$1 = tree[0];
      if (Curry._2(predicate, acc, v$1)) {
        return Curry._2(f, acc, v$1);
      } else {
        return acc;
      }
    }
  };
}

function reduceReversed(predicate, f, acc, tree) {
  if (predicate === Functions.alwaysTrue2) {
    return reduceReversedWhile(Functions.alwaysTrue2, f, acc, tree);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, v) {
      if (shouldContinue[0]) {
        var result = Curry._2(predicate, acc, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    return reduceReversedWhile(predicate$1, f, acc, tree);
  }
}

function removeFirstOrRaise(tree) {
  if (typeof tree === "number") {
    return Pervasives.failwith("empty");
  } else if (tree.tag) {
    var left = tree[1];
    if (typeof left === "number") {
      return tree[3];
    } else {
      return rebalance(removeFirstOrRaise(left), tree[2], tree[3]);
    }
  } else {
    return /* Empty */0;
  }
}

function removeFirstOrRaiseWithValue(first, tree) {
  if (typeof tree === "number") {
    return Pervasives.failwith("empty");
  } else if (tree.tag) {
    var left = tree[1];
    if (typeof left === "number") {
      first[0] = tree[2];
      return tree[3];
    } else {
      return rebalance(removeFirstOrRaiseWithValue(first, left), tree[2], tree[3]);
    }
  } else {
    first[0] = tree[0];
    return /* Empty */0;
  }
}

function removeLastOrRaise(tree) {
  if (typeof tree === "number") {
    return Pervasives.failwith("empty");
  } else if (tree.tag) {
    var right = tree[3];
    var left = tree[1];
    if (typeof right === "number") {
      return left;
    } else {
      return rebalance(left, tree[2], removeLastOrRaise(right));
    }
  } else {
    return /* Empty */0;
  }
}

function remove(comparator, x, tree) {
  if (typeof tree === "number") {
    return /* Empty */0;
  } else if (tree.tag) {
    var right = tree[3];
    var v = tree[2];
    var left = tree[1];
    if (x === v) {
      if (typeof left === "number") {
        return right;
      } else if (typeof right === "number") {
        return left;
      } else {
        return rebalance(left, firstOrRaise(right), removeFirstOrRaise(right));
      }
    } else {
      var cmp = Curry._2(comparator, x, v);
      if (cmp === Ordering.lessThan) {
        var newLeft = remove(comparator, x, left);
        if (newLeft === left) {
          return tree;
        } else {
          return rebalance(newLeft, v, right);
        }
      } else if (cmp === Ordering.greaterThan) {
        var newRight = remove(comparator, x, right);
        if (newRight === right) {
          return tree;
        } else {
          return rebalance(left, v, newRight);
        }
      } else if (typeof left === "number") {
        return right;
      } else if (typeof right === "number") {
        return left;
      } else if (tree[0] > 4) {
        var first = [x];
        var newRight$1 = removeFirstOrRaiseWithValue(first, right);
        return rebalance(left, first[0], newRight$1);
      } else {
        return rebalance(left, firstOrRaise(right), removeFirstOrRaise(right));
      }
    }
  } else {
    var v$1 = tree[0];
    if (x === v$1) {
      return /* Empty */0;
    } else {
      var cmp$1 = Curry._2(comparator, x, v$1);
      if (cmp$1 === Ordering.equal) {
        return /* Empty */0;
      } else {
        return tree;
      }
    }
  }
}

function toSequence(tree) {
  if (typeof tree === "number") {
    return Sequence.empty(/* () */0);
  } else if (tree.tag) {
    var right = tree[3];
    var v = tree[2];
    var left = tree[1];
    return Sequence.concat(/* :: */[
                (function (param) {
                    return Sequence.defer((function () {
                                  return toSequence(left);
                                }), param);
                  }),
                /* :: */[
                  (function (param) {
                      return Sequence.$$return(v, param);
                    }),
                  /* :: */[
                    (function (param) {
                        return Sequence.defer((function () {
                                      return toSequence(right);
                                    }), param);
                      }),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    var partial_arg = tree[0];
    return (function (param) {
        return Sequence.$$return(partial_arg, param);
      });
  }
}

function toSequenceReversed(tree) {
  if (typeof tree === "number") {
    return Sequence.empty(/* () */0);
  } else if (tree.tag) {
    var right = tree[3];
    var v = tree[2];
    var left = tree[1];
    return Sequence.concat(/* :: */[
                (function (param) {
                    return Sequence.defer((function () {
                                  return toSequenceReversed(right);
                                }), param);
                  }),
                /* :: */[
                  (function (param) {
                      return Sequence.$$return(v, param);
                    }),
                  /* :: */[
                    (function (param) {
                        return Sequence.defer((function () {
                                      return toSequenceReversed(left);
                                    }), param);
                      }),
                    /* [] */0
                  ]
                ]
              ]);
  } else {
    var partial_arg = tree[0];
    return (function (param) {
        return Sequence.$$return(partial_arg, param);
      });
  }
}

var maxHeightDiff = 2;

exports.height                      = height;
exports.makeTree                    = makeTree;
exports.maxHeightDiff               = maxHeightDiff;
exports.rebalance                   = rebalance;
exports.add                         = add;
exports.contains                    = contains;
exports.firstOrRaise                = firstOrRaise;
exports.lastOrRaise                 = lastOrRaise;
exports.reduceWhile                 = reduceWhile;
exports.reduce                      = reduce;
exports.reduceReversedWhile         = reduceReversedWhile;
exports.reduceReversed              = reduceReversed;
exports.removeFirstOrRaise          = removeFirstOrRaise;
exports.removeFirstOrRaiseWithValue = removeFirstOrRaiseWithValue;
exports.removeLastOrRaise           = removeLastOrRaise;
exports.remove                      = remove;
exports.toSequence                  = toSequence;
exports.toSequenceReversed          = toSequenceReversed;
/* Sequence Not a pure module */


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Deque                    = __webpack_require__(87);
var ImmMap                   = __webpack_require__(71);
var ImmSet                   = __webpack_require__(59);
var IntMap                   = __webpack_require__(88);
var IntSet                   = __webpack_require__(90);
var Vector                   = __webpack_require__(80);
var HashMap                  = __webpack_require__(92);
var HashSet                  = __webpack_require__(94);
var ImmList                  = __webpack_require__(64);
var Indexed                  = __webpack_require__(76);
var Equality                 = __webpack_require__(96);
var ImmStack                 = __webpack_require__(97);
var IntRange                 = __webpack_require__(74);
var Iterable                 = __webpack_require__(57);
var Ordering                 = __webpack_require__(65);
var Sequence                 = __webpack_require__(56);
var SortedMap                = __webpack_require__(98);
var SortedSet                = __webpack_require__(99);
var Collection               = __webpack_require__(69);
var Comparator               = __webpack_require__(73);
var NavigableMap             = __webpack_require__(77);
var NavigableSet             = __webpack_require__(68);
var KeyedIterable            = __webpack_require__(67);
var KeyedCollection          = __webpack_require__(78);
var TransientVector          = __webpack_require__(79);
var CopyOnWriteArray         = __webpack_require__(60);
var NavigableCollection      = __webpack_require__(66);
var SequentialCollection     = __webpack_require__(70);
var NavigableKeyedCollection = __webpack_require__(82);

var Hashable = /* module */[];

var Streamable = /* module */[];

var Persistent = /* module */[];

var Transient = /* module */[];

var Persistent$1 = /* module */[];

var Transient$1 = /* module */[];

var Persistent$2 = /* module */[];

var Transient$2 = /* module */[];

var Persistent$3 = /* module */[];

var Transient$3 = /* module */[];

var Persistent$4 = /* module */[];

var KeyedStreamable = /* module */[];

var Persistent$5 = /* module */[];

var Transient$4 = /* module */[];

var Persistent$6 = /* module */[];

var Transient$5 = /* module */[];

var Persistent$7 = /* module */[];

var Persistent$8 = /* module */[];

var Transient$6 = /* module */[];

var include = Iterable.Make1(/* module */[
      /* isEmpty */ImmList.isEmpty,
      /* reduce */ImmList.reduceImpl
    ]);

var Equality$1 = [
  Equality.bytes,
  Equality.$$char,
  Equality.$$int,
  Equality.int32,
  Equality.int64,
  Equality.nativeInt,
  Equality.reference,
  Equality.string
];

var Ordering$1 = /* Ordering */[
  Ordering.equal,
  Ordering.greaterThan,
  Ordering.lessThan
];

var Comparator$1 = [
  Comparator.bytes,
  Comparator.$$char,
  Comparator.$$int,
  Comparator.int32,
  Comparator.int64,
  Comparator.nativeInt,
  Comparator.string,
  Comparator.toEquality
];

var Hash = /* Hash */[];

var Equatable = /* Equatable */[];

var Comparable = /* Comparable */[];

var Iterable$1 = [
  Iterable.defer,
  Iterable.distinctUntilChangedWith,
  Iterable.doOnNext,
  Iterable.filter,
  Iterable.flatMap,
  Iterable.flatten,
  Iterable.map,
  Iterable.scan,
  Iterable.skip,
  Iterable.skipWhile,
  Iterable.startWith,
  Iterable.take,
  Iterable.takeWhile,
  Iterable.every,
  Iterable.find,
  Iterable.findOrRaise,
  Iterable.forEach,
  Iterable.none,
  Iterable.reduce,
  Iterable.some,
  Iterable.toIterable,
  Iterable.concat,
  Iterable.empty,
  Iterable.generate,
  Iterable.$$return
];

var Sequence$1 = [
  Sequence.every,
  Sequence.find,
  Sequence.findOrRaise,
  Sequence.forEach,
  Sequence.none,
  Sequence.reduce,
  Sequence.some,
  Sequence.toIterable,
  Sequence.defer,
  Sequence.distinctUntilChangedWith,
  Sequence.doOnNext,
  Sequence.filter,
  Sequence.flatMap,
  Sequence.flatten,
  Sequence.map,
  Sequence.scan,
  Sequence.skip,
  Sequence.skipWhile,
  Sequence.startWith,
  Sequence.take,
  Sequence.takeWhile,
  Sequence.concat,
  Sequence.empty,
  Sequence.first,
  Sequence.firstOrRaise,
  Sequence.generate,
  Sequence.$$return,
  Sequence.seek,
  Sequence.seekWhile,
  Sequence.zip,
  Sequence.zip2With,
  Sequence.zip3With,
  Sequence.zipLongest,
  Sequence.zipLongest2With,
  Sequence.zipLongest3With
];

var Collection$1 = [
  Collection.every,
  Collection.find,
  Collection.findOrRaise,
  Collection.forEach,
  Collection.none,
  Collection.reduce,
  Collection.some,
  Collection.toIterable,
  Collection.count,
  Collection.isEmpty,
  Collection.isNotEmpty,
  Collection.toCollection,
  Collection.toSequence,
  Collection.empty,
  Persistent,
  Transient
];

var SequentialCollection$1 = [
  SequentialCollection.every,
  SequentialCollection.find,
  SequentialCollection.findOrRaise,
  SequentialCollection.forEach,
  SequentialCollection.none,
  SequentialCollection.reduce,
  SequentialCollection.some,
  SequentialCollection.toIterable,
  SequentialCollection.count,
  SequentialCollection.isEmpty,
  SequentialCollection.isNotEmpty,
  SequentialCollection.toCollection,
  SequentialCollection.toSequence,
  SequentialCollection.first,
  SequentialCollection.firstOrRaise,
  SequentialCollection.toSequentialCollection,
  SequentialCollection.empty,
  Persistent$1,
  Transient$1
];

var NavigableCollection$1 = [
  NavigableCollection.every,
  NavigableCollection.find,
  NavigableCollection.findOrRaise,
  NavigableCollection.forEach,
  NavigableCollection.none,
  NavigableCollection.reduce,
  NavigableCollection.some,
  NavigableCollection.toIterable,
  NavigableCollection.count,
  NavigableCollection.isEmpty,
  NavigableCollection.isNotEmpty,
  NavigableCollection.toCollection,
  NavigableCollection.toSequence,
  NavigableCollection.first,
  NavigableCollection.firstOrRaise,
  NavigableCollection.toSequentialCollection,
  NavigableCollection.last,
  NavigableCollection.lastOrRaise,
  NavigableCollection.reduceReversed,
  NavigableCollection.toCollectionReversed,
  NavigableCollection.toIterableReversed,
  NavigableCollection.toNavigableCollection,
  NavigableCollection.toNavigableCollectionReversed,
  NavigableCollection.toSequenceReversed,
  NavigableCollection.toSequentialCollectionReversed,
  NavigableCollection.empty,
  Persistent$2,
  Transient$2
];

var $$Set = [
  ImmSet.every,
  ImmSet.find,
  ImmSet.findOrRaise,
  ImmSet.forEach,
  ImmSet.none,
  ImmSet.reduce,
  ImmSet.some,
  ImmSet.toIterable,
  ImmSet.count,
  ImmSet.isEmpty,
  ImmSet.isNotEmpty,
  ImmSet.toCollection,
  ImmSet.toSequence,
  ImmSet.contains,
  ImmSet.equals,
  ImmSet.toSet,
  ImmSet.empty,
  ImmSet.intersect,
  ImmSet.subtract,
  ImmSet.union,
  Persistent$3,
  Transient$3
];

var NavigableSet$1 = [
  NavigableSet.contains,
  NavigableSet.equals,
  NavigableSet.toSet,
  NavigableSet.every,
  NavigableSet.find,
  NavigableSet.findOrRaise,
  NavigableSet.forEach,
  NavigableSet.none,
  NavigableSet.reduce,
  NavigableSet.some,
  NavigableSet.toIterable,
  NavigableSet.count,
  NavigableSet.isEmpty,
  NavigableSet.isNotEmpty,
  NavigableSet.toCollection,
  NavigableSet.toSequence,
  NavigableSet.first,
  NavigableSet.firstOrRaise,
  NavigableSet.toSequentialCollection,
  NavigableSet.last,
  NavigableSet.lastOrRaise,
  NavigableSet.reduceReversed,
  NavigableSet.toCollectionReversed,
  NavigableSet.toIterableReversed,
  NavigableSet.toNavigableCollection,
  NavigableSet.toNavigableCollectionReversed,
  NavigableSet.toSequenceReversed,
  NavigableSet.toSequentialCollectionReversed,
  NavigableSet.toNavigableSet,
  NavigableSet.toNavigableSetReversed,
  NavigableSet.toSetReversed,
  NavigableSet.empty,
  Persistent$4
];

var KeyedIterable$1 = [
  KeyedIterable.defer,
  KeyedIterable.distinctUntilChangedWith,
  KeyedIterable.doOnNext,
  KeyedIterable.filter,
  KeyedIterable.flatMap,
  KeyedIterable.map,
  KeyedIterable.mapKeys,
  KeyedIterable.mapValues,
  KeyedIterable.skip,
  KeyedIterable.skipWhile,
  KeyedIterable.startWith,
  KeyedIterable.take,
  KeyedIterable.takeWhile,
  KeyedIterable.every,
  KeyedIterable.find,
  KeyedIterable.findOrRaise,
  KeyedIterable.forEach,
  KeyedIterable.keys,
  KeyedIterable.none,
  KeyedIterable.reduce,
  KeyedIterable.reduceKeys,
  KeyedIterable.reduceValues,
  KeyedIterable.some,
  KeyedIterable.toIterable,
  KeyedIterable.toKeyedIterable,
  KeyedIterable.values,
  KeyedIterable.concat,
  KeyedIterable.empty,
  KeyedIterable.fromEntries,
  KeyedIterable.generate,
  KeyedIterable.$$return,
  KeyedIterable.scan
];

var KeyedCollection$1 = [
  KeyedCollection.every,
  KeyedCollection.find,
  KeyedCollection.findOrRaise,
  KeyedCollection.forEach,
  KeyedCollection.keys,
  KeyedCollection.none,
  KeyedCollection.reduce,
  KeyedCollection.reduceKeys,
  KeyedCollection.reduceValues,
  KeyedCollection.some,
  KeyedCollection.toIterable,
  KeyedCollection.toKeyedIterable,
  KeyedCollection.values,
  KeyedCollection.containsKey,
  KeyedCollection.count,
  KeyedCollection.isEmpty,
  KeyedCollection.isNotEmpty,
  KeyedCollection.keysCollection,
  KeyedCollection.keysSequence,
  KeyedCollection.toKeyedCollection,
  KeyedCollection.toSequence,
  KeyedCollection.valuesCollection,
  KeyedCollection.valuesSequence,
  KeyedCollection.empty,
  Persistent$5,
  Transient$4
];

var NavigableKeyedCollection$1 = [
  NavigableKeyedCollection.every,
  NavigableKeyedCollection.find,
  NavigableKeyedCollection.findOrRaise,
  NavigableKeyedCollection.forEach,
  NavigableKeyedCollection.keys,
  NavigableKeyedCollection.none,
  NavigableKeyedCollection.reduce,
  NavigableKeyedCollection.reduceKeys,
  NavigableKeyedCollection.reduceValues,
  NavigableKeyedCollection.some,
  NavigableKeyedCollection.toIterable,
  NavigableKeyedCollection.toKeyedIterable,
  NavigableKeyedCollection.values,
  NavigableKeyedCollection.containsKey,
  NavigableKeyedCollection.count,
  NavigableKeyedCollection.isEmpty,
  NavigableKeyedCollection.isNotEmpty,
  NavigableKeyedCollection.keysCollection,
  NavigableKeyedCollection.keysSequence,
  NavigableKeyedCollection.toKeyedCollection,
  NavigableKeyedCollection.toSequence,
  NavigableKeyedCollection.valuesCollection,
  NavigableKeyedCollection.valuesSequence,
  NavigableKeyedCollection.first,
  NavigableKeyedCollection.firstOrRaise,
  NavigableKeyedCollection.keysCollectionReversed,
  NavigableKeyedCollection.keysNavigableCollection,
  NavigableKeyedCollection.keysNavigableCollectionReversed,
  NavigableKeyedCollection.keysReversed,
  NavigableKeyedCollection.keysSequentialCollection,
  NavigableKeyedCollection.keysSequentialCollectionReversed,
  NavigableKeyedCollection.keysSequenceReversed,
  NavigableKeyedCollection.last,
  NavigableKeyedCollection.lastOrRaise,
  NavigableKeyedCollection.reduceReversed,
  NavigableKeyedCollection.reduceKeysReversed,
  NavigableKeyedCollection.reduceValuesReversed,
  NavigableKeyedCollection.toIterableReversed,
  NavigableKeyedCollection.toKeyedCollectionReversed,
  NavigableKeyedCollection.toKeyedIterableReversed,
  NavigableKeyedCollection.toNavigableKeyedCollection,
  NavigableKeyedCollection.toNavigableKeyedCollectionReversed,
  NavigableKeyedCollection.toSequenceReversed,
  NavigableKeyedCollection.valuesCollectionReversed,
  NavigableKeyedCollection.valuesNavigableCollection,
  NavigableKeyedCollection.valuesNavigableCollectionReversed,
  NavigableKeyedCollection.valuesReversed,
  NavigableKeyedCollection.valuesSequentialCollection,
  NavigableKeyedCollection.valuesSequentialCollectionReversed,
  NavigableKeyedCollection.valuesSequenceReversed,
  NavigableKeyedCollection.empty
];

var $$Map = [
  ImmMap.every,
  ImmMap.find,
  ImmMap.findOrRaise,
  ImmMap.forEach,
  ImmMap.keys,
  ImmMap.none,
  ImmMap.reduce,
  ImmMap.reduceKeys,
  ImmMap.reduceValues,
  ImmMap.some,
  ImmMap.toIterable,
  ImmMap.toKeyedIterable,
  ImmMap.values,
  ImmMap.containsKey,
  ImmMap.count,
  ImmMap.isEmpty,
  ImmMap.isNotEmpty,
  ImmMap.keysCollection,
  ImmMap.keysSequence,
  ImmMap.toKeyedCollection,
  ImmMap.toSequence,
  ImmMap.valuesCollection,
  ImmMap.valuesSequence,
  ImmMap.get,
  ImmMap.getOrDefault,
  ImmMap.getOrRaise,
  ImmMap.keysSet,
  ImmMap.toMap,
  ImmMap.empty,
  Persistent$6,
  Transient$5
];

var NavigableMap$1 = [
  NavigableMap.first,
  NavigableMap.firstOrRaise,
  NavigableMap.keysCollectionReversed,
  NavigableMap.keysNavigableCollection,
  NavigableMap.keysNavigableCollectionReversed,
  NavigableMap.keysReversed,
  NavigableMap.keysSequentialCollection,
  NavigableMap.keysSequentialCollectionReversed,
  NavigableMap.keysSequenceReversed,
  NavigableMap.last,
  NavigableMap.lastOrRaise,
  NavigableMap.reduceReversed,
  NavigableMap.reduceKeysReversed,
  NavigableMap.reduceValuesReversed,
  NavigableMap.toIterableReversed,
  NavigableMap.toKeyedCollectionReversed,
  NavigableMap.toKeyedIterableReversed,
  NavigableMap.toNavigableKeyedCollection,
  NavigableMap.toNavigableKeyedCollectionReversed,
  NavigableMap.toSequenceReversed,
  NavigableMap.valuesCollectionReversed,
  NavigableMap.valuesNavigableCollection,
  NavigableMap.valuesNavigableCollectionReversed,
  NavigableMap.valuesReversed,
  NavigableMap.valuesSequentialCollection,
  NavigableMap.valuesSequentialCollectionReversed,
  NavigableMap.valuesSequenceReversed,
  NavigableMap.every,
  NavigableMap.find,
  NavigableMap.findOrRaise,
  NavigableMap.forEach,
  NavigableMap.keys,
  NavigableMap.none,
  NavigableMap.reduce,
  NavigableMap.reduceKeys,
  NavigableMap.reduceValues,
  NavigableMap.some,
  NavigableMap.toIterable,
  NavigableMap.toKeyedIterable,
  NavigableMap.values,
  NavigableMap.containsKey,
  NavigableMap.count,
  NavigableMap.isEmpty,
  NavigableMap.isNotEmpty,
  NavigableMap.keysCollection,
  NavigableMap.keysSequence,
  NavigableMap.toKeyedCollection,
  NavigableMap.toSequence,
  NavigableMap.valuesCollection,
  NavigableMap.valuesSequence,
  NavigableMap.get,
  NavigableMap.getOrDefault,
  NavigableMap.getOrRaise,
  NavigableMap.toMap,
  NavigableMap.keysNavigableSet,
  NavigableMap.keysNavigableSetReversed,
  NavigableMap.keysSet,
  NavigableMap.toMapReversed,
  NavigableMap.toNavigableMap,
  NavigableMap.toNavigableMapReversed,
  Persistent$7
];

var Indexed$1 = [
  Indexed.every,
  Indexed.find,
  Indexed.findOrRaise,
  Indexed.forEach,
  Indexed.none,
  Indexed.reduce,
  Indexed.some,
  Indexed.toIterable,
  Indexed.count,
  Indexed.isEmpty,
  Indexed.isNotEmpty,
  Indexed.toCollection,
  Indexed.toSequence,
  Indexed.first,
  Indexed.firstOrRaise,
  Indexed.toSequentialCollection,
  Indexed.last,
  Indexed.lastOrRaise,
  Indexed.reduceReversed,
  Indexed.toCollectionReversed,
  Indexed.toIterableReversed,
  Indexed.toNavigableCollection,
  Indexed.toNavigableCollectionReversed,
  Indexed.toSequenceReversed,
  Indexed.toSequentialCollectionReversed,
  Indexed.get,
  Indexed.getOrDefault,
  Indexed.getOrRaise,
  Indexed.toIndexed,
  Indexed.toIndexedReversed,
  Indexed.toKeyedCollection,
  Indexed.toKeyedCollectionReversed,
  Indexed.toKeyedIterable,
  Indexed.toKeyedIterableReversed,
  Indexed.toMap,
  Indexed.toMapReversed,
  Indexed.toNavigableKeyedCollection,
  Indexed.toNavigableKeyedCollectionReversed,
  Indexed.toNavigableMap,
  Indexed.toNavigableMapReversed,
  Persistent$8,
  Transient$6
];

var Deque_033 = [
  Deque.Transient[5],
  Deque.Transient[9],
  Deque.Transient[10],
  Deque.Transient[15],
  Deque.Transient[1],
  Deque.Transient[2],
  Deque.Transient[7],
  Deque.Transient[8],
  Deque.Transient[16],
  Deque.Transient[3],
  Deque.Transient[11],
  Deque.Transient[12],
  Deque.Transient[17],
  Deque.Transient[6],
  Deque.Transient[13],
  Deque.Transient[19]
];

var Deque$1 = [
  Deque.last,
  Deque.lastOrRaise,
  Deque.reduceReversed,
  Deque.toCollectionReversed,
  Deque.toIterableReversed,
  Deque.toNavigableCollection,
  Deque.toNavigableCollectionReversed,
  Deque.toSequenceReversed,
  Deque.toSequentialCollectionReversed,
  Deque.removeAll,
  Deque.every,
  Deque.find,
  Deque.findOrRaise,
  Deque.forEach,
  Deque.none,
  Deque.reduce,
  Deque.some,
  Deque.toIterable,
  Deque.count,
  Deque.isEmpty,
  Deque.isNotEmpty,
  Deque.toCollection,
  Deque.toSequence,
  Deque.first,
  Deque.firstOrRaise,
  Deque.toSequentialCollection,
  Deque.addFirst,
  Deque.addFirstAll,
  Deque.removeFirstOrRaise,
  Deque.addLast,
  Deque.addLastAll,
  Deque.removeLastOrRaise,
  Deque.reverse,
  Deque_033,
  Deque.empty,
  Deque.from,
  Deque.fromReverse,
  Deque.mutate,
  Deque.$$return
];

var HashMap_038 = [
  HashMap.Transient[3],
  HashMap.Transient[4],
  HashMap.Transient[10],
  HashMap.Transient[11],
  HashMap.Transient[17],
  HashMap.Transient[19],
  HashMap.Transient[2],
  HashMap.Transient[7],
  HashMap.Transient[8],
  HashMap.Transient[9],
  HashMap.Transient[14],
  HashMap.Transient[15],
  HashMap.Transient[16],
  HashMap.Transient[6],
  HashMap.Transient[12]
];

var HashMap$1 = [
  HashMap.remove,
  HashMap.removeAll,
  HashMap.every,
  HashMap.find,
  HashMap.findOrRaise,
  HashMap.forEach,
  HashMap.keys,
  HashMap.none,
  HashMap.reduce,
  HashMap.reduceKeys,
  HashMap.reduceValues,
  HashMap.some,
  HashMap.toIterable,
  HashMap.toKeyedIterable,
  HashMap.values,
  HashMap.containsKey,
  HashMap.count,
  HashMap.isEmpty,
  HashMap.isNotEmpty,
  HashMap.keysCollection,
  HashMap.keysSequence,
  HashMap.toKeyedCollection,
  HashMap.toSequence,
  HashMap.valuesCollection,
  HashMap.valuesSequence,
  HashMap.get,
  HashMap.getOrDefault,
  HashMap.getOrRaise,
  HashMap.keysSet,
  HashMap.toMap,
  HashMap.alter,
  HashMap.merge,
  HashMap.put,
  HashMap.putAll,
  HashMap.putAllEntries,
  HashMap.emptyWith,
  HashMap.fromWith,
  HashMap.fromEntriesWith,
  HashMap_038,
  HashMap.mutate
];

var HashSet_026 = [
  HashSet.Transient[6],
  HashSet.Transient[9],
  HashSet.Transient[10],
  HashSet.Transient[15],
  HashSet.Transient[2],
  HashSet.Transient[4],
  HashSet.Transient[5],
  HashSet.Transient[13],
  HashSet.Transient[8],
  HashSet.Transient[11]
];

var HashSet$1 = [
  HashSet.contains,
  HashSet.equals,
  HashSet.toSet,
  HashSet.every,
  HashSet.find,
  HashSet.findOrRaise,
  HashSet.forEach,
  HashSet.none,
  HashSet.reduce,
  HashSet.some,
  HashSet.toIterable,
  HashSet.count,
  HashSet.isEmpty,
  HashSet.isNotEmpty,
  HashSet.toCollection,
  HashSet.toSequence,
  HashSet.removeAll,
  HashSet.add,
  HashSet.addAll,
  HashSet.intersect,
  HashSet.remove,
  HashSet.subtract,
  HashSet.union,
  HashSet.emptyWith,
  HashSet.fromWith,
  HashSet.hash,
  HashSet_026,
  HashSet.mutate
];

var IntMap_035 = [
  IntMap.Transient[3],
  IntMap.Transient[4],
  IntMap.Transient[10],
  IntMap.Transient[11],
  IntMap.Transient[17],
  IntMap.Transient[19],
  IntMap.Transient[2],
  IntMap.Transient[7],
  IntMap.Transient[8],
  IntMap.Transient[9],
  IntMap.Transient[14],
  IntMap.Transient[15],
  IntMap.Transient[16],
  IntMap.Transient[6],
  IntMap.Transient[12]
];

var IntMap$1 = [
  IntMap.remove,
  IntMap.removeAll,
  IntMap.every,
  IntMap.find,
  IntMap.findOrRaise,
  IntMap.forEach,
  IntMap.keys,
  IntMap.none,
  IntMap.reduce,
  IntMap.reduceKeys,
  IntMap.reduceValues,
  IntMap.some,
  IntMap.toIterable,
  IntMap.toKeyedIterable,
  IntMap.values,
  IntMap.containsKey,
  IntMap.count,
  IntMap.isEmpty,
  IntMap.isNotEmpty,
  IntMap.keysCollection,
  IntMap.keysSequence,
  IntMap.toKeyedCollection,
  IntMap.toSequence,
  IntMap.valuesCollection,
  IntMap.valuesSequence,
  IntMap.get,
  IntMap.getOrDefault,
  IntMap.getOrRaise,
  IntMap.keysSet,
  IntMap.toMap,
  IntMap.alter,
  IntMap.merge,
  IntMap.put,
  IntMap.putAll,
  IntMap.putAllEntries,
  IntMap_035,
  IntMap.empty,
  IntMap.from,
  IntMap.fromEntries,
  IntMap.mutate
];

var IntRange$1 = [
  IntRange.contains,
  IntRange.toSet,
  IntRange.every,
  IntRange.find,
  IntRange.findOrRaise,
  IntRange.forEach,
  IntRange.none,
  IntRange.reduce,
  IntRange.some,
  IntRange.toIterable,
  IntRange.count,
  IntRange.isEmpty,
  IntRange.isNotEmpty,
  IntRange.toCollection,
  IntRange.toSequence,
  IntRange.first,
  IntRange.firstOrRaise,
  IntRange.toSequentialCollection,
  IntRange.last,
  IntRange.lastOrRaise,
  IntRange.reduceReversed,
  IntRange.toCollectionReversed,
  IntRange.toIterableReversed,
  IntRange.toNavigableCollection,
  IntRange.toNavigableCollectionReversed,
  IntRange.toSequenceReversed,
  IntRange.toSequentialCollectionReversed,
  IntRange.toNavigableSet,
  IntRange.toNavigableSetReversed,
  IntRange.toSetReversed,
  IntRange.equals,
  IntRange.compare,
  IntRange.hash,
  IntRange.create,
  IntRange.empty
];

var IntSet_023 = [
  IntSet.Transient[6],
  IntSet.Transient[8],
  IntSet.Transient[9],
  IntSet.Transient[14],
  IntSet.Transient[2],
  IntSet.Transient[4],
  IntSet.Transient[5],
  IntSet.Transient[12],
  IntSet.Transient[7],
  IntSet.Transient[10]
];

var IntSet$1 = [
  IntSet.equals,
  IntSet.contains,
  IntSet.toSet,
  IntSet.every,
  IntSet.find,
  IntSet.findOrRaise,
  IntSet.forEach,
  IntSet.none,
  IntSet.reduce,
  IntSet.some,
  IntSet.toIterable,
  IntSet.count,
  IntSet.isEmpty,
  IntSet.isNotEmpty,
  IntSet.toCollection,
  IntSet.toSequence,
  IntSet.removeAll,
  IntSet.add,
  IntSet.addAll,
  IntSet.intersect,
  IntSet.remove,
  IntSet.subtract,
  IntSet.union,
  IntSet_023,
  IntSet.empty,
  IntSet.from,
  IntSet.mutate
];

var List_000 = include[0];

var List_001 = include[1];

var List_002 = include[2];

var List_003 = include[3];

var List_004 = include[4];

var List_005 = include[5];

var List_006 = include[6];

var List = [
  List_000,
  List_001,
  List_002,
  List_003,
  List_004,
  List_005,
  List_006,
  Iterable.ofList,
  ImmList.addFirst,
  Iterable.listAddFirstAll,
  ImmList.empty,
  ImmList.first,
  ImmList.firstOrRaise,
  Iterable.listFromReverse,
  ImmList.removeAll,
  ImmList.removeFirstOrRaise,
  ImmList.$$return,
  Sequence.ofList
];

var ReadOnlyArray = [
  CopyOnWriteArray.every,
  CopyOnWriteArray.find,
  CopyOnWriteArray.findOrRaise,
  CopyOnWriteArray.forEach,
  CopyOnWriteArray.none,
  CopyOnWriteArray.reduce,
  CopyOnWriteArray.some,
  CopyOnWriteArray.toIterable,
  CopyOnWriteArray.count,
  CopyOnWriteArray.isEmpty,
  CopyOnWriteArray.isNotEmpty,
  CopyOnWriteArray.toCollection,
  CopyOnWriteArray.toSequence,
  CopyOnWriteArray.first,
  CopyOnWriteArray.firstOrRaise,
  CopyOnWriteArray.toSequentialCollection,
  CopyOnWriteArray.last,
  CopyOnWriteArray.lastOrRaise,
  CopyOnWriteArray.reduceReversed,
  CopyOnWriteArray.toCollectionReversed,
  CopyOnWriteArray.toIterableReversed,
  CopyOnWriteArray.toNavigableCollection,
  CopyOnWriteArray.toNavigableCollectionReversed,
  CopyOnWriteArray.toSequenceReversed,
  CopyOnWriteArray.toSequentialCollectionReversed,
  CopyOnWriteArray.get,
  CopyOnWriteArray.getOrDefault,
  CopyOnWriteArray.getOrRaise,
  CopyOnWriteArray.toIndexed,
  CopyOnWriteArray.toIndexedReversed,
  CopyOnWriteArray.toKeyedCollection,
  CopyOnWriteArray.toKeyedCollectionReversed,
  CopyOnWriteArray.toKeyedIterable,
  CopyOnWriteArray.toKeyedIterableReversed,
  CopyOnWriteArray.toMap,
  CopyOnWriteArray.toMapReversed,
  CopyOnWriteArray.toNavigableKeyedCollection,
  CopyOnWriteArray.toNavigableKeyedCollectionReversed,
  CopyOnWriteArray.toNavigableMap,
  CopyOnWriteArray.toNavigableMapReversed,
  CopyOnWriteArray.empty,
  CopyOnWriteArray.init,
  CopyOnWriteArray.ofUnsafe
];

var Stack = [
  ImmStack.removeAll,
  ImmStack.every,
  ImmStack.find,
  ImmStack.findOrRaise,
  ImmStack.forEach,
  ImmStack.none,
  ImmStack.reduce,
  ImmStack.some,
  ImmStack.toIterable,
  ImmStack.count,
  ImmStack.isEmpty,
  ImmStack.isNotEmpty,
  ImmStack.toCollection,
  ImmStack.toSequence,
  ImmStack.first,
  ImmStack.firstOrRaise,
  ImmStack.toSequentialCollection,
  ImmStack.addFirst,
  ImmStack.addFirstAll,
  ImmStack.removeFirstOrRaise,
  ImmStack.empty,
  ImmStack.fromList,
  ImmStack.fromReverse,
  ImmStack.$$return,
  ImmStack.toList
];

var SortedMap$1 = [(function (funarg) {
      var $$let = SortedMap.Make1(funarg);
      return [
              $$let[1],
              $$let[2],
              $$let[3],
              $$let[4],
              $$let[5],
              $$let[6],
              $$let[7],
              $$let[8],
              $$let[9],
              $$let[10],
              $$let[11],
              $$let[12],
              $$let[13],
              $$let[14],
              $$let[15],
              $$let[16],
              $$let[17],
              $$let[18],
              $$let[19],
              $$let[20],
              $$let[21],
              $$let[22],
              $$let[23],
              $$let[24],
              $$let[25],
              $$let[26],
              $$let[27],
              $$let[55],
              $$let[56],
              $$let[58],
              $$let[59],
              $$let[60],
              $$let[68],
              $$let[69],
              $$let[28],
              $$let[29],
              $$let[30],
              $$let[31],
              $$let[32],
              $$let[33],
              $$let[34],
              $$let[35],
              $$let[36],
              $$let[37],
              $$let[38],
              $$let[39],
              $$let[40],
              $$let[41],
              $$let[42],
              $$let[43],
              $$let[44],
              $$let[45],
              $$let[46],
              $$let[47],
              $$let[48],
              $$let[49],
              $$let[50],
              $$let[51],
              $$let[52],
              $$let[53],
              $$let[57],
              $$let[54],
              $$let[61],
              $$let[72],
              $$let[63],
              $$let[64],
              $$let[65],
              $$let[70],
              $$let[71],
              $$let[62],
              $$let[66],
              $$let[67]
            ];
    })];

var SortedSet$1 = [(function (funarg) {
      var $$let = SortedSet.Make(funarg);
      return [
              $$let[34],
              $$let[16],
              $$let[17],
              $$let[18],
              $$let[19],
              $$let[20],
              $$let[21],
              $$let[22],
              $$let[23],
              $$let[24],
              $$let[25],
              $$let[26],
              $$let[27],
              $$let[28],
              $$let[29],
              $$let[30],
              $$let[39],
              $$let[1],
              $$let[2],
              $$let[3],
              $$let[4],
              $$let[5],
              $$let[6],
              $$let[7],
              $$let[8],
              $$let[9],
              $$let[10],
              $$let[11],
              $$let[12],
              $$let[13],
              $$let[14],
              $$let[15],
              $$let[42],
              $$let[31],
              $$let[32],
              $$let[45],
              $$let[41],
              $$let[46],
              $$let[47],
              $$let[43],
              $$let[44],
              $$let[36],
              $$let[40]
            ];
    })];

var Vector_057 = [
  TransientVector.count,
  TransientVector.isEmpty,
  TransientVector.isNotEmpty,
  TransientVector.removeAll,
  TransientVector.addFirst,
  TransientVector.addFirstAll,
  TransientVector.first,
  TransientVector.firstOrRaise,
  TransientVector.removeFirstOrRaise,
  TransientVector.addLast,
  TransientVector.last,
  TransientVector.lastOrRaise,
  TransientVector.removeLastOrRaise,
  TransientVector.get,
  TransientVector.getOrDefault,
  TransientVector.getOrRaise,
  TransientVector.insertAt,
  TransientVector.removeAt,
  TransientVector.update,
  TransientVector.updateAll,
  TransientVector.updateWith,
  TransientVector.empty,
  TransientVector.persist
];

var Vector$1 = [
  Vector.get,
  Vector.getOrDefault,
  Vector.getOrRaise,
  Vector.toIndexed,
  Vector.toIndexedReversed,
  Vector.toKeyedCollection,
  Vector.toKeyedCollectionReversed,
  Vector.toKeyedIterable,
  Vector.toKeyedIterableReversed,
  Vector.toMap,
  Vector.toMapReversed,
  Vector.toNavigableKeyedCollection,
  Vector.toNavigableKeyedCollectionReversed,
  Vector.toNavigableMap,
  Vector.toNavigableMapReversed,
  Vector.last,
  Vector.lastOrRaise,
  Vector.reduceReversed,
  Vector.toCollectionReversed,
  Vector.toIterableReversed,
  Vector.toNavigableCollection,
  Vector.toNavigableCollectionReversed,
  Vector.toSequenceReversed,
  Vector.toSequentialCollectionReversed,
  Vector.removeAll,
  Vector.every,
  Vector.find,
  Vector.findOrRaise,
  Vector.forEach,
  Vector.none,
  Vector.reduce,
  Vector.some,
  Vector.toIterable,
  Vector.count,
  Vector.isEmpty,
  Vector.isNotEmpty,
  Vector.toCollection,
  Vector.toSequence,
  Vector.first,
  Vector.firstOrRaise,
  Vector.toSequentialCollection,
  Vector.addFirst,
  Vector.addFirstAll,
  Vector.removeFirstOrRaise,
  Vector.addLast,
  Vector.addLastAll,
  Vector.removeLastOrRaise,
  Vector.concat,
  Vector.insertAt,
  Vector.removeAt,
  Vector.skip,
  Vector.slice,
  Vector.take,
  Vector.update,
  Vector.updateAll,
  Vector.updateWith,
  Vector.init,
  Vector_057,
  Vector.empty,
  Vector.from,
  Vector.fromReverse,
  Vector.mutate,
  Vector.$$return
];

exports.Equality                 = Equality$1;
exports.Ordering                 = Ordering$1;
exports.Comparator               = Comparator$1;
exports.Hash                     = Hash;
exports.Equatable                = Equatable;
exports.Comparable               = Comparable;
exports.Hashable                 = Hashable;
exports.Streamable               = Streamable;
exports.Iterable                 = Iterable$1;
exports.Sequence                 = Sequence$1;
exports.Collection               = Collection$1;
exports.SequentialCollection     = SequentialCollection$1;
exports.NavigableCollection      = NavigableCollection$1;
exports.$$Set                    = $$Set;
exports.NavigableSet             = NavigableSet$1;
exports.KeyedStreamable          = KeyedStreamable;
exports.KeyedIterable            = KeyedIterable$1;
exports.KeyedCollection          = KeyedCollection$1;
exports.NavigableKeyedCollection = NavigableKeyedCollection$1;
exports.$$Map                    = $$Map;
exports.NavigableMap             = NavigableMap$1;
exports.Indexed                  = Indexed$1;
exports.Deque                    = Deque$1;
exports.HashMap                  = HashMap$1;
exports.HashSet                  = HashSet$1;
exports.IntMap                   = IntMap$1;
exports.IntRange                 = IntRange$1;
exports.IntSet                   = IntSet$1;
exports.List                     = List;
exports.ReadOnlyArray            = ReadOnlyArray;
exports.Stack                    = Stack;
exports.SortedMap                = SortedMap$1;
exports.SortedSet                = SortedSet$1;
exports.Vector                   = Vector$1;
/* include Not a pure module */


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block               = __webpack_require__(25);
var Curry               = __webpack_require__(1);
var Vector              = __webpack_require__(80);
var Transient           = __webpack_require__(58);
var TransientVector     = __webpack_require__(79);
var NavigableCollection = __webpack_require__(66);

function count(deque) {
  return Curry._1(Vector.count, deque[0]);
}

function firstOrRaise(deque) {
  if (deque.tag) {
    return Curry._1(Vector.lastOrRaise, deque[0]);
  } else {
    return Curry._1(Vector.firstOrRaise, deque[0]);
  }
}

function lastOrRaise(deque) {
  if (deque.tag) {
    return Curry._1(Vector.firstOrRaise, deque[0]);
  } else {
    return Curry._1(Vector.lastOrRaise, deque[0]);
  }
}

function reduce(predicate, f, acc, deque) {
  if (deque.tag) {
    return Curry._4(Vector.reduceReversed, /* Some */[predicate], f, acc, deque[0]);
  } else {
    return Curry._4(Vector.reduce, /* Some */[predicate], f, acc, deque[0]);
  }
}

function reduceReversed(predicate, f, acc, deque) {
  if (deque.tag) {
    return Curry._4(Vector.reduce, /* Some */[predicate], f, acc, deque[0]);
  } else {
    return Curry._4(Vector.reduceReversed, /* Some */[predicate], f, acc, deque[0]);
  }
}

function toSequence(deque) {
  if (deque.tag) {
    return Curry._1(Vector.toSequenceReversed, deque[0]);
  } else {
    return Curry._1(Vector.toSequence, deque[0]);
  }
}

function toSequenceReversed(deque) {
  if (deque.tag) {
    return Curry._1(Vector.toSequence, deque[0]);
  } else {
    return Curry._1(Vector.toSequenceReversed, deque[0]);
  }
}

var include = NavigableCollection.Make1(/* module */[
      /* count */count,
      /* firstOrRaise */firstOrRaise,
      /* lastOrRaise */lastOrRaise,
      /* reduce */reduce,
      /* reduceReversed */reduceReversed,
      /* toSequence */toSequence,
      /* toSequenceReversed */toSequenceReversed
    ]);

function addFirst(value, deque) {
  if (deque.tag) {
    return /* Descending */Block.__(1, [Vector.addLast(value, deque[0])]);
  } else {
    return /* Ascending */Block.__(0, [Vector.addFirst(value, deque[0])]);
  }
}

function addLast(value, deque) {
  if (deque.tag) {
    return /* Descending */Block.__(1, [Vector.addFirst(value, deque[0])]);
  } else {
    return /* Ascending */Block.__(0, [Vector.addLast(value, deque[0])]);
  }
}

function empty() {
  return /* Ascending */Block.__(0, [Vector.empty(/* () */0)]);
}

function removeFirstOrRaise(deque) {
  if (deque.tag) {
    return /* Descending */Block.__(1, [Vector.removeLastOrRaise(deque[0])]);
  } else {
    return /* Ascending */Block.__(0, [Vector.removeFirstOrRaise(deque[0])]);
  }
}

function removeLastOrRaise(deque) {
  if (deque.tag) {
    return /* Descending */Block.__(1, [Vector.removeFirstOrRaise(deque[0])]);
  } else {
    return /* Ascending */Block.__(0, [Vector.removeLastOrRaise(deque[0])]);
  }
}

function $$return(value) {
  return /* Ascending */Block.__(0, [Vector.$$return(value)]);
}

function reverse(deque) {
  if (deque.tag) {
    return /* Ascending */Block.__(0, [deque[0]]);
  } else {
    return /* Descending */Block.__(1, [deque[0]]);
  }
}

function removeAll() {
  return /* Ascending */Block.__(0, [Vector.empty(/* () */0)]);
}

function mutate(deque) {
  if (deque.tag) {
    return Transient.create(/* Descending */Block.__(1, [Vector.mutate(deque[0])]));
  } else {
    return Transient.create(/* Ascending */Block.__(0, [Vector.mutate(deque[0])]));
  }
}

function addFirst$1(value, $$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.addLast(value, match[0]);
    return $$transient;
  } else {
    TransientVector.addFirst(value, match[0]);
    return $$transient;
  }
}

function addFirstAll(iter, $$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.addLastAll(iter, match[0]);
    return $$transient;
  } else {
    TransientVector.addFirstAll(iter, match[0]);
    return $$transient;
  }
}

function addLast$1(value, $$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.addFirst(value, match[0]);
    return $$transient;
  } else {
    TransientVector.addLast(value, match[0]);
    return $$transient;
  }
}

function addLastAll(iter, $$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.addFirstAll(iter, match[0]);
    return $$transient;
  } else {
    TransientVector.addLastAll(iter, match[0]);
    return $$transient;
  }
}

function count$1($$transient) {
  var match = Transient.get($$transient);
  return TransientVector.count(match[0]);
}

function empty$1() {
  return mutate(/* Ascending */Block.__(0, [Vector.empty(/* () */0)]));
}

function first($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    return TransientVector.last(match[0]);
  } else {
    return TransientVector.first(match[0]);
  }
}

function firstOrRaise$1($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    return TransientVector.lastOrRaise(match[0]);
  } else {
    return TransientVector.firstOrRaise(match[0]);
  }
}

function isEmpty($$transient) {
  return +(count$1($$transient) === 0);
}

function isNotEmpty($$transient) {
  return +(count$1($$transient) !== 0);
}

function last($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    return TransientVector.first(match[0]);
  } else {
    return TransientVector.last(match[0]);
  }
}

function lastOrRaise$1($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    return TransientVector.firstOrRaise(match[0]);
  } else {
    return TransientVector.lastOrRaise(match[0]);
  }
}

function persist($$transient) {
  var match = Transient.persist($$transient);
  if (match.tag) {
    return /* Descending */Block.__(1, [TransientVector.persist(match[0])]);
  } else {
    return /* Ascending */Block.__(0, [TransientVector.persist(match[0])]);
  }
}

function removeAllImpl(_, _$1) {
  return /* Ascending */Block.__(0, [TransientVector.empty(/* () */0)]);
}

function removeAll$1($$transient) {
  return Transient.update(removeAllImpl, $$transient);
}

function removeFirstOrRaise$1($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.removeLastOrRaise(match[0]);
    return $$transient;
  } else {
    TransientVector.removeFirstOrRaise(match[0]);
    return $$transient;
  }
}

function removeLastOrRaise$1($$transient) {
  var match = Transient.get($$transient);
  if (match.tag) {
    TransientVector.removeFirstOrRaise(match[0]);
    return $$transient;
  } else {
    TransientVector.removeLastOrRaise(match[0]);
    return $$transient;
  }
}

function reverseImpl(_, vector) {
  if (vector.tag) {
    return /* Ascending */Block.__(0, [vector[0]]);
  } else {
    return /* Descending */Block.__(1, [vector[0]]);
  }
}

function reverse$1($$transient) {
  return Transient.update(reverseImpl, $$transient);
}

var Transient$1 = /* module */[
  /* mutate */mutate,
  /* addFirst */addFirst$1,
  /* addFirstAll */addFirstAll,
  /* addLast */addLast$1,
  /* addLastAll */addLastAll,
  /* count */count$1,
  /* empty */empty$1,
  /* first */first,
  /* firstOrRaise */firstOrRaise$1,
  /* isEmpty */isEmpty,
  /* isNotEmpty */isNotEmpty,
  /* last */last,
  /* lastOrRaise */lastOrRaise$1,
  /* persist */persist,
  /* removeAllImpl */removeAllImpl,
  /* removeAll */removeAll$1,
  /* removeFirstOrRaise */removeFirstOrRaise$1,
  /* removeLastOrRaise */removeLastOrRaise$1,
  /* reverseImpl */reverseImpl,
  /* reverse */reverse$1
];

function addFirstAll$1(iter, deque) {
  return persist(addFirstAll(iter, mutate(deque)));
}

function addLastAll$1(iter, deque) {
  return persist(addLastAll(iter, mutate(deque)));
}

function from(iter) {
  return addLastAll$1(iter, /* Ascending */Block.__(0, [Vector.empty(/* () */0)]));
}

function fromReverse(iter) {
  return addFirstAll$1(iter, /* Ascending */Block.__(0, [Vector.empty(/* () */0)]));
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var count$2 = include[8];

var isEmpty$1 = include[9];

var isNotEmpty$1 = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

var first$1 = include[13];

var firstOrRaise$2 = include[14];

var toSequentialCollection = include[15];

var last$1 = include[16];

var lastOrRaise$2 = include[17];

var reduceReversed$1 = include[18];

var toCollectionReversed = include[19];

var toIterableReversed = include[20];

var toNavigableCollection = include[21];

var toNavigableCollectionReversed = include[22];

var toSequenceReversed$1 = include[23];

var toSequentialCollectionReversed = include[24];

exports.every                          = every;
exports.find                           = find;
exports.findOrRaise                    = findOrRaise;
exports.forEach                        = forEach;
exports.none                           = none;
exports.reduce                         = reduce$1;
exports.some                           = some;
exports.toIterable                     = toIterable;
exports.count                          = count$2;
exports.isEmpty                        = isEmpty$1;
exports.isNotEmpty                     = isNotEmpty$1;
exports.toCollection                   = toCollection;
exports.toSequence                     = toSequence$1;
exports.first                          = first$1;
exports.firstOrRaise                   = firstOrRaise$2;
exports.toSequentialCollection         = toSequentialCollection;
exports.last                           = last$1;
exports.lastOrRaise                    = lastOrRaise$2;
exports.reduceReversed                 = reduceReversed$1;
exports.toCollectionReversed           = toCollectionReversed;
exports.toIterableReversed             = toIterableReversed;
exports.toNavigableCollection          = toNavigableCollection;
exports.toNavigableCollectionReversed  = toNavigableCollectionReversed;
exports.toSequenceReversed             = toSequenceReversed$1;
exports.toSequentialCollectionReversed = toSequentialCollectionReversed;
exports.addFirst                       = addFirst;
exports.addLast                        = addLast;
exports.empty                          = empty;
exports.removeFirstOrRaise             = removeFirstOrRaise;
exports.removeLastOrRaise              = removeLastOrRaise;
exports.$$return                       = $$return;
exports.reverse                        = reverse;
exports.removeAll                      = removeAll;
exports.Transient                      = Transient$1;
exports.mutate                         = mutate;
exports.addFirstAll                    = addFirstAll$1;
exports.addLastAll                     = addLastAll$1;
exports.from                           = from;
exports.fromReverse                    = fromReverse;
/* include Not a pure module */


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry            = __webpack_require__(1);
var ImmMap           = __webpack_require__(71);
var ImmSet           = __webpack_require__(59);
var Iterable         = __webpack_require__(57);
var Functions        = __webpack_require__(55);
var Transient        = __webpack_require__(58);
var Pervasives       = __webpack_require__(2);
var KeyedReducer     = __webpack_require__(62);
var KeyedIterable    = __webpack_require__(67);
var BitmapTrieIntMap = __webpack_require__(89);

function containsKey(key, param) {
  return BitmapTrieIntMap.containsKey(0, key, param[/* root */1]);
}

function count(param) {
  return param[/* count */0];
}

function get(key, param) {
  return BitmapTrieIntMap.get(0, key, param[/* root */1]);
}

function getOrDefault($$default, key, param) {
  return BitmapTrieIntMap.getOrDefault(0, $$default, key, param[/* root */1]);
}

function getOrRaise(key, param) {
  return BitmapTrieIntMap.getOrRaise(0, key, param[/* root */1]);
}

function reduce(predicate, f, acc, param) {
  return BitmapTrieIntMap.reduce(predicate, f, acc, param[/* root */1]);
}

var include = KeyedReducer.Make1(/* module */[/* reduce */reduce]);

function toSequence(selector, param) {
  return BitmapTrieIntMap.toSequence(selector, param[/* root */1]);
}

var include$1 = ImmMap.Make1(/* module */[
      /* containsKey */containsKey,
      /* count */count,
      /* get */get,
      /* getOrDefault */getOrDefault,
      /* getOrRaise */getOrRaise,
      /* reduce */include[0],
      /* reduceKeys */include[1],
      /* reduceValues */include[2],
      /* toSequence */toSequence
    ]);

var containsKey$1 = include$1[13];

var count$1 = include$1[14];

var isEmpty = include$1[15];

var isNotEmpty = include$1[16];

var get$1 = include$1[23];

var getOrDefault$1 = include$1[24];

var getOrRaise$1 = include$1[25];

var keysSet = include$1[26];

function alter(key, f, map) {
  var count = map[/* count */0];
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieIntMap.alter(BitmapTrieIntMap.updateLevelNodePersistent, Transient.Owner[/* none */1], alterResult, 0, key, f, map[/* root */1]);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot
              ];
    case 1 : 
        return map;
    case 2 : 
        return /* record */[
                /* count */count - 1 | 0,
                /* root */newRoot
              ];
    case 3 : 
        return /* record */[
                /* count */count,
                /* root */newRoot
              ];
    
  }
}

function empty() {
  return /* record */[
          /* count */0,
          /* root : Empty */0
        ];
}

function put(key, value, map) {
  var count = map[/* count */0];
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieIntMap.putWithResult(BitmapTrieIntMap.updateLevelNodePersistent, Transient.Owner[/* none */1], alterResult, 0, key, value, map[/* root */1]);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot
              ];
    case 1 : 
        return map;
    case 2 : 
        return Pervasives.failwith("invalid state");
    case 3 : 
        return /* record */[
                /* count */count,
                /* root */newRoot
              ];
    
  }
}

function remove(key, map) {
  return alter(key, Functions.alwaysNone, map);
}

function removeAll() {
  return /* record */[
          /* count */0,
          /* root : Empty */0
        ];
}

var mutate = Transient.create;

function alterImpl(owner, key, f, map) {
  var root = map[/* root */1];
  var count = map[/* count */0];
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieIntMap.alter(BitmapTrieIntMap.updateLevelNodeTransient, owner, alterResult, 0, key, f, root);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot
              ];
    case 1 : 
        return map;
    case 2 : 
        return /* record */[
                /* count */count - 1 | 0,
                /* root */newRoot
              ];
    case 3 : 
        if (root === newRoot) {
          return map;
        } else {
          return /* record */[
                  /* count */count,
                  /* root */newRoot
                ];
        }
    
  }
}

function alter$1(key, f, $$transient) {
  return Transient.update2(alterImpl, key, f, $$transient);
}

function containsKey$2(key, $$transient) {
  return Curry._2(containsKey$1, key, Transient.get($$transient));
}

function count$2($$transient) {
  return Curry._1(count$1, Transient.get($$transient));
}

function empty$1() {
  return Transient.create(/* record */[
              /* count */0,
              /* root : Empty */0
            ]);
}

function get$2(key, $$transient) {
  return Curry._2(get$1, key, Transient.get($$transient));
}

function getOrDefault$2($$default, key, $$transient) {
  return Curry._3(getOrDefault$1, $$default, key, Transient.get($$transient));
}

function getOrRaise$2(key, $$transient) {
  return Curry._2(getOrRaise$1, key, Transient.get($$transient));
}

function isEmpty$1($$transient) {
  return Curry._1(isEmpty, Transient.get($$transient));
}

function isNotEmpty$1($$transient) {
  return Curry._1(isNotEmpty, Transient.get($$transient));
}

var persist = Transient.persist;

function putImpl(owner, key, value, map) {
  var root = map[/* root */1];
  var count = map[/* count */0];
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieIntMap.putWithResult(BitmapTrieIntMap.updateLevelNodeTransient, owner, alterResult, 0, key, value, root);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot
              ];
    case 1 : 
        return map;
    case 2 : 
        return Pervasives.failwith("invalid state");
    case 3 : 
        if (root === newRoot) {
          return map;
        } else {
          return /* record */[
                  /* count */count,
                  /* root */newRoot
                ];
        }
    
  }
}

function put$1(key, value, $$transient) {
  return Transient.update2(putImpl, key, value, $$transient);
}

function putAll(iter, $$transient) {
  return KeyedIterable.reduce(/* None */0, (function (acc, k, v) {
                return put$1(k, v, acc);
              }), $$transient, iter);
}

function putAllEntries(iter, $$transient) {
  return Iterable.reduce(/* None */0, (function (acc, param) {
                return put$1(param[0], param[1], acc);
              }), $$transient, iter);
}

function remove$1(key, $$transient) {
  return alter$1(key, Functions.alwaysNone, $$transient);
}

function removeAllImpl(_, _$1) {
  return /* record */[
          /* count */0,
          /* root : Empty */0
        ];
}

function removeAll$1($$transient) {
  return Transient.update(removeAllImpl, $$transient);
}

var Transient$1 = /* module */[
  /* mutate */mutate,
  /* alterImpl */alterImpl,
  /* alter */alter$1,
  /* containsKey */containsKey$2,
  /* count */count$2,
  /* persistentEmpty */empty,
  /* empty */empty$1,
  /* get */get$2,
  /* getOrDefault */getOrDefault$2,
  /* getOrRaise */getOrRaise$2,
  /* isEmpty */isEmpty$1,
  /* isNotEmpty */isNotEmpty$1,
  /* persist */persist,
  /* putImpl */putImpl,
  /* put */put$1,
  /* putAll */putAll,
  /* putAllEntries */putAllEntries,
  /* remove */remove$1,
  /* removeAllImpl */removeAllImpl,
  /* removeAll */removeAll$1
];

function putAll$1(iter, map) {
  return Transient.persist(putAll(iter, Transient.create(map)));
}

function putAllEntries$1(iter, map) {
  return Transient.persist(putAllEntries(iter, Transient.create(map)));
}

function from(iter) {
  return putAll$1(iter, /* record */[
              /* count */0,
              /* root : Empty */0
            ]);
}

function fromEntries(iter) {
  return putAllEntries$1(iter, /* record */[
              /* count */0,
              /* root : Empty */0
            ]);
}

function merge(f, initialValue, next) {
  return Transient.persist(Iterable.reduce(/* None */0, (function (acc, key) {
                    var result = Curry._3(f, key, Curry._2(get$1, key, initialValue), Curry._2(get$1, key, next));
                    if (result) {
                      return put$1(key, result[0], acc);
                    } else {
                      return alter$1(key, Functions.alwaysNone, acc);
                    }
                  }), Transient.create(initialValue), ImmSet.union(Curry._1(keysSet, next), Curry._1(keysSet, initialValue))));
}

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var keys = include$1[4];

var none = include$1[5];

var reduce$1 = include$1[6];

var reduceKeys = include$1[7];

var reduceValues = include$1[8];

var some = include$1[9];

var toIterable = include$1[10];

var toKeyedIterable = include$1[11];

var values = include$1[12];

var keysCollection = include$1[17];

var keysSequence = include$1[18];

var toKeyedCollection = include$1[19];

var toSequence$1 = include$1[20];

var valuesCollection = include$1[21];

var valuesSequence = include$1[22];

var toMap = include$1[27];

exports.every             = every;
exports.find              = find;
exports.findOrRaise       = findOrRaise;
exports.forEach           = forEach;
exports.keys              = keys;
exports.none              = none;
exports.reduce            = reduce$1;
exports.reduceKeys        = reduceKeys;
exports.reduceValues      = reduceValues;
exports.some              = some;
exports.toIterable        = toIterable;
exports.toKeyedIterable   = toKeyedIterable;
exports.values            = values;
exports.containsKey       = containsKey$1;
exports.count             = count$1;
exports.isEmpty           = isEmpty;
exports.isNotEmpty        = isNotEmpty;
exports.keysCollection    = keysCollection;
exports.keysSequence      = keysSequence;
exports.toKeyedCollection = toKeyedCollection;
exports.toSequence        = toSequence$1;
exports.valuesCollection  = valuesCollection;
exports.valuesSequence    = valuesSequence;
exports.get               = get$1;
exports.getOrDefault      = getOrDefault$1;
exports.getOrRaise        = getOrRaise$1;
exports.keysSet           = keysSet;
exports.toMap             = toMap;
exports.alter             = alter;
exports.empty             = empty;
exports.put               = put;
exports.remove            = remove;
exports.removeAll         = removeAll;
exports.Transient         = Transient$1;
exports.mutate            = mutate;
exports.putAll            = putAll$1;
exports.putAllEntries     = putAllEntries$1;
exports.from              = from;
exports.fromEntries       = fromEntries;
exports.merge             = merge;
/* include Not a pure module */


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block                   = __webpack_require__(25);
var Curry                   = __webpack_require__(1);
var Option                  = __webpack_require__(61);
var Sequence                = __webpack_require__(56);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var BitmapTrie              = __webpack_require__(72);
var Caml_array              = __webpack_require__(7);
var Pervasives              = __webpack_require__(2);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function containsKey(_depth, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return /* false */0;
    } else if (map.tag) {
      return +(key === map[0]);
    } else {
      var bitmap = map[0];
      var bit = BitmapTrie.bitPos(key, depth);
      var index = BitmapTrie.index(bitmap, bit);
      if (BitmapTrie.containsNode(bitmap, bit)) {
        _map = Caml_array.caml_array_get(map[1], index);
        _depth = depth + 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    }
  };
}

function get(_depth, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return /* None */0;
    } else if (map.tag) {
      if (key === map[0]) {
        return /* Some */[map[1]];
      } else {
        return /* None */0;
      }
    } else {
      var bitmap = map[0];
      var bit = BitmapTrie.bitPos(key, depth);
      var index = BitmapTrie.index(bitmap, bit);
      if (BitmapTrie.containsNode(bitmap, bit)) {
        _map = Caml_array.caml_array_get(map[1], index);
        _depth = depth + 1 | 0;
        continue ;
        
      } else {
        return /* None */0;
      }
    }
  };
}

function getOrDefault(_depth, $$default, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return $$default;
    } else if (map.tag) {
      if (key === map[0]) {
        return map[1];
      } else {
        return $$default;
      }
    } else {
      var bitmap = map[0];
      var bit = BitmapTrie.bitPos(key, depth);
      var index = BitmapTrie.index(bitmap, bit);
      if (BitmapTrie.containsNode(bitmap, bit)) {
        _map = Caml_array.caml_array_get(map[1], index);
        _depth = depth + 1 | 0;
        continue ;
        
      } else {
        return $$default;
      }
    }
  };
}

function getOrRaise(_depth, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return Pervasives.failwith("not found");
    } else if (map.tag) {
      if (key === map[0]) {
        return map[1];
      } else {
        return Pervasives.failwith("not found");
      }
    } else {
      var bitmap = map[0];
      var bit = BitmapTrie.bitPos(key, depth);
      var index = BitmapTrie.index(bitmap, bit);
      if (BitmapTrie.containsNode(bitmap, bit)) {
        _map = Caml_array.caml_array_get(map[1], index);
        _depth = depth + 1 | 0;
        continue ;
        
      } else {
        return Pervasives.failwith("not found");
      }
    }
  };
}

function reduceWhile(levelPredicate, levelReducer, predicate, f, acc, map) {
  if (typeof map === "number") {
    return acc;
  } else if (map.tag) {
    var value = map[1];
    var key = map[0];
    if (Curry._3(predicate, acc, key, value)) {
      return Curry._3(f, acc, key, value);
    } else {
      return acc;
    }
  } else {
    return Curry._4(CopyOnWriteArray.reduce, levelPredicate, levelReducer, acc, map[1]);
  }
}

function reduce(predicate, f, acc, map) {
  if (predicate === Functions.alwaysTrue3) {
    var levelReducer = function (acc, node) {
      return reduceWhile(/* None */0, levelReducer, Functions.alwaysTrue3, f, acc, node);
    };
    return levelReducer(acc, map);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, k, v) {
      if (shouldContinue[0]) {
        var result = Curry._3(predicate, acc, k, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    var levelPredicate = /* Some */[(function (_, _$1) {
          return shouldContinue[0];
        })];
    var levelReducer$1 = function (acc, node) {
      return reduceWhile(levelPredicate, levelReducer$1, predicate$1, f, acc, node);
    };
    return levelReducer$1(acc, map);
  }
}

function toSequence(selector, map) {
  if (typeof map === "number") {
    return Sequence.empty(/* () */0);
  } else if (map.tag) {
    var partial_arg = Curry._2(selector, map[0], map[1]);
    return (function (param) {
        return Sequence.$$return(partial_arg, param);
      });
  } else {
    return Sequence.flatMap((function (param) {
                  return toSequence(selector, param);
                }), Curry._1(CopyOnWriteArray.toSequence, map[1]));
  }
}

function putWithResult(updateLevelNode, owner, alterResult, depth, key, newEntryValue, _map) {
  while(true) {
    var map = _map;
    if (typeof map === "number") {
      alterResult[0] = /* Added */0;
      return /* Entry */Block.__(1, [
                key,
                newEntryValue
              ]);
    } else if (map.tag) {
      var entryKey = map[0];
      if (key === entryKey) {
        if (newEntryValue === map[1]) {
          alterResult[0] = /* NoChange */1;
          return map;
        } else {
          alterResult[0] = /* Replace */3;
          return /* Entry */Block.__(1, [
                    key,
                    newEntryValue
                  ]);
        }
      } else {
        var bitmap = BitmapTrie.bitPos(entryKey, depth);
        _map = /* Level */Block.__(0, [
            bitmap,
            /* array */[map],
            owner
          ]);
        continue ;
        
      }
    } else {
      var nodes = map[1];
      var bitmap$1 = map[0];
      var bit = BitmapTrie.bitPos(key, depth);
      var index = BitmapTrie.index(bitmap$1, bit);
      if (BitmapTrie.containsNode(bitmap$1, bit)) {
        var childNode = Caml_array.caml_array_get(nodes, index);
        var newChildNode = putWithResult(updateLevelNode, owner, alterResult, depth + 1 | 0, key, newEntryValue, childNode);
        var match = alterResult[0];
        if (match !== 0) {
          switch (match - 1 | 0) {
            case 0 : 
                return map;
            case 1 : 
                return Pervasives.failwith("Illegal State");
            case 2 : 
                return Curry._4(updateLevelNode, owner, index, newChildNode, map);
            
          }
        } else {
          return Curry._4(updateLevelNode, owner, index, newChildNode, map);
        }
      } else {
        alterResult[0] = /* Added */0;
        var node = /* Entry */Block.__(1, [
            key,
            newEntryValue
          ]);
        var nodes$1 = CopyOnWriteArray.insertAt(index, node, nodes);
        return /* Level */Block.__(0, [
                  bitmap$1 | bit,
                  nodes$1,
                  owner
                ]);
      }
    }
  };
}

function alter(updateLevelNode, owner, alterResult, depth, key, f, map) {
  if (typeof map === "number") {
    var match = Curry._1(f, /* None */0);
    if (match) {
      alterResult[0] = /* Added */0;
      return /* Entry */Block.__(1, [
                key,
                match[0]
              ]);
    } else {
      alterResult[0] = /* NoChange */1;
      return map;
    }
  } else if (map.tag) {
    var entryValue = map[1];
    var entryKey = map[0];
    if (key === entryKey) {
      var match$1 = Curry._1(f, Option.$$return(entryValue));
      if (match$1) {
        var newEntryValue = match$1[0];
        if (newEntryValue === entryValue) {
          alterResult[0] = /* NoChange */1;
          return map;
        } else {
          alterResult[0] = /* Replace */3;
          return /* Entry */Block.__(1, [
                    key,
                    newEntryValue
                  ]);
        }
      } else {
        alterResult[0] = /* Removed */2;
        return /* Empty */0;
      }
    } else {
      var match$2 = Curry._1(f, /* None */0);
      if (match$2) {
        var bitmap = BitmapTrie.bitPos(entryKey, depth);
        return putWithResult(updateLevelNode, owner, alterResult, depth, key, match$2[0], /* Level */Block.__(0, [
                      bitmap,
                      /* array */[map],
                      owner
                    ]));
      } else {
        alterResult[0] = /* NoChange */1;
        return map;
      }
    }
  } else {
    var nodes = map[1];
    var bitmap$1 = map[0];
    var bit = BitmapTrie.bitPos(key, depth);
    var index = BitmapTrie.index(bitmap$1, bit);
    if (BitmapTrie.containsNode(bitmap$1, bit)) {
      var childNode = Caml_array.caml_array_get(nodes, index);
      var newChildNode = alter(updateLevelNode, owner, alterResult, depth + 1 | 0, key, f, childNode);
      var match$3 = alterResult[0];
      if (match$3 !== 0) {
        switch (match$3 - 1 | 0) {
          case 0 : 
              return map;
          case 1 : 
              if (typeof newChildNode === "number") {
                var nodes$1 = CopyOnWriteArray.removeAt(index, nodes);
                if (Curry._1(CopyOnWriteArray.count, nodes$1) > 0) {
                  return /* Level */Block.__(0, [
                            bitmap$1 ^ bit,
                            nodes$1,
                            owner
                          ]);
                } else {
                  return /* Empty */0;
                }
              } else {
                return Curry._4(updateLevelNode, owner, index, newChildNode, map);
              }
              break;
          case 2 : 
              return Curry._4(updateLevelNode, owner, index, newChildNode, map);
          
        }
      } else {
        return Curry._4(updateLevelNode, owner, index, newChildNode, map);
      }
    } else {
      var match$4 = Curry._1(f, /* None */0);
      if (match$4) {
        alterResult[0] = /* Added */0;
        var node_001 = match$4[0];
        var node = /* Entry */Block.__(1, [
            key,
            node_001
          ]);
        var nodes$2 = CopyOnWriteArray.insertAt(index, node, nodes);
        return /* Level */Block.__(0, [
                  bitmap$1 | bit,
                  nodes$2,
                  owner
                ]);
      } else {
        alterResult[0] = /* NoChange */1;
        return map;
      }
    }
  }
}

function updateLevelNodePersistent(_, index, childNode, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieIntMap.re",
            231,
            4
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieIntMap.re",
            231,
            4
          ]
        ];
  } else {
    return /* Level */Block.__(0, [
              param[0],
              CopyOnWriteArray.update(index, childNode, param[1]),
              Transient.Owner[/* none */1]
            ]);
  }
}

function updateLevelNodeTransient(owner, index, childNode, node) {
  if (typeof node === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieIntMap.re",
            238,
            4
          ]
        ];
  } else if (node.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieIntMap.re",
            238,
            4
          ]
        ];
  } else {
    var nodes = node[1];
    if (node[2] === owner) {
      Caml_array.caml_array_set(nodes, index, childNode);
      return node;
    } else {
      return /* Level */Block.__(0, [
                node[0],
                CopyOnWriteArray.update(index, childNode, nodes),
                owner
              ]);
    }
  }
}

exports.containsKey               = containsKey;
exports.get                       = get;
exports.getOrDefault              = getOrDefault;
exports.getOrRaise                = getOrRaise;
exports.reduceWhile               = reduceWhile;
exports.reduce                    = reduce;
exports.toSequence                = toSequence;
exports.putWithResult             = putWithResult;
exports.alter                     = alter;
exports.updateLevelNodePersistent = updateLevelNodePersistent;
exports.updateLevelNodeTransient  = updateLevelNodeTransient;
/* Sequence Not a pure module */


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry            = __webpack_require__(1);
var ImmSet           = __webpack_require__(59);
var Iterable         = __webpack_require__(57);
var Transient        = __webpack_require__(58);
var BitmapTrieIntSet = __webpack_require__(91);

function contains(value, param) {
  return BitmapTrieIntSet.contains(0, value, param[/* root */1]);
}

function count(param) {
  return param[/* count */0];
}

function reduce(predicate, f, acc, param) {
  return BitmapTrieIntSet.reduce(predicate, f, acc, param[/* root */1]);
}

function toSequence(param) {
  return BitmapTrieIntSet.toSequence(param[/* root */1]);
}

var include = ImmSet.Make(/* module */[
      /* contains */contains,
      /* count */count,
      /* reduce */reduce,
      /* toSequence */toSequence
    ]);

var reduce$1 = include[5];

var count$1 = include[8];

var isEmpty = include[9];

var isNotEmpty = include[10];

var contains$1 = include[14];

var toSet = include[15];

function add(value, set) {
  var root = set[/* root */1];
  var newRoot = BitmapTrieIntSet.add(BitmapTrieIntSet.updateLevelNodePersistent, Transient.Owner[/* none */1], 0, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] + 1 | 0,
            /* root */newRoot
          ];
  }
}

var emptyInstance = /* record */[
  /* count */0,
  /* root : Empty */0
];

function empty() {
  return emptyInstance;
}

function hash(set) {
  return Curry._4(reduce$1, /* None */0, (function (acc, next) {
                return acc + next | 0;
              }), 0, set);
}

function remove(value, set) {
  var root = set[/* root */1];
  var newRoot = BitmapTrieIntSet.remove(BitmapTrieIntSet.updateLevelNodePersistent, Transient.Owner[/* none */1], 0, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] - 1 | 0,
            /* root */newRoot
          ];
  }
}

function removeAll() {
  return emptyInstance;
}

var mutate = Transient.create;

function addImpl(owner, value, set) {
  if (Curry._2(contains$1, value, set)) {
    return set;
  } else {
    var newRoot = BitmapTrieIntSet.add(BitmapTrieIntSet.updateLevelNodeTransient, owner, 0, value, set[/* root */1]);
    return /* record */[
            /* count */set[/* count */0] + 1 | 0,
            /* root */newRoot
          ];
  }
}

function add$1(value, $$transient) {
  return Transient.update1(addImpl, value, $$transient);
}

function addAllImpl(owner, iter, set) {
  var count = set[/* count */0];
  var newCount = [count];
  var newRoot = Iterable.reduce(/* None */0, (function (acc, value) {
          if (BitmapTrieIntSet.contains(0, value, acc)) {
            return acc;
          } else {
            var newRoot = BitmapTrieIntSet.add(BitmapTrieIntSet.updateLevelNodeTransient, owner, 0, value, acc);
            newCount[0] = newCount[0] + 1 | 0;
            return newRoot;
          }
        }), set[/* root */1], iter);
  if (newCount[0] === count) {
    return set;
  } else {
    return /* record */[
            /* count */newCount[0],
            /* root */newRoot
          ];
  }
}

function addAll(iter, $$transient) {
  return Transient.update1(addAllImpl, iter, $$transient);
}

function contains$2(value, $$transient) {
  return Curry._2(contains$1, value, Transient.get($$transient));
}

function count$2($$transient) {
  return Curry._1(count$1, Transient.get($$transient));
}

function empty$1() {
  return Transient.create(emptyInstance);
}

function isEmpty$1($$transient) {
  return Curry._1(isEmpty, Transient.get($$transient));
}

function isNotEmpty$1($$transient) {
  return Curry._1(isNotEmpty, Transient.get($$transient));
}

var persist = Transient.persist;

function removeImpl(owner, value, set) {
  var root = set[/* root */1];
  var newRoot = BitmapTrieIntSet.remove(BitmapTrieIntSet.updateLevelNodeTransient, owner, 0, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] - 1 | 0,
            /* root */newRoot
          ];
  }
}

function remove$1(value, $$transient) {
  return Transient.update1(removeImpl, value, $$transient);
}

function removeAllImpl(_, _$1) {
  return emptyInstance;
}

function removeAll$1($$transient) {
  return Transient.update(removeAllImpl, $$transient);
}

var Transient$1 = /* module */[
  /* mutate */mutate,
  /* addImpl */addImpl,
  /* add */add$1,
  /* addAllImpl */addAllImpl,
  /* addAll */addAll,
  /* contains */contains$2,
  /* count */count$2,
  /* empty */empty$1,
  /* isEmpty */isEmpty$1,
  /* isNotEmpty */isNotEmpty$1,
  /* persist */persist,
  /* removeImpl */removeImpl,
  /* remove */remove$1,
  /* removeAllImpl */removeAllImpl,
  /* removeAll */removeAll$1
];

function addAll$1(iter, set) {
  var $$transient = Transient.create(set);
  return Transient.persist(Transient.update1(addAllImpl, iter, $$transient));
}

function from(iter) {
  return addAll$1(iter, emptyInstance);
}

function intersect($$this, that) {
  return addAll$1(ImmSet.intersect(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
}

function subtract($$this, that) {
  return addAll$1(ImmSet.subtract(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
}

function union($$this, that) {
  return addAll$1(ImmSet.union(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var some = include[6];

var toIterable = include[7];

var toCollection = include[11];

var toSequence$1 = include[12];

var equals = include[13];

exports.every         = every;
exports.find          = find;
exports.findOrRaise   = findOrRaise;
exports.forEach       = forEach;
exports.none          = none;
exports.reduce        = reduce$1;
exports.some          = some;
exports.toIterable    = toIterable;
exports.count         = count$1;
exports.isEmpty       = isEmpty;
exports.isNotEmpty    = isNotEmpty;
exports.toCollection  = toCollection;
exports.toSequence    = toSequence$1;
exports.equals        = equals;
exports.contains      = contains$1;
exports.toSet         = toSet;
exports.add           = add;
exports.emptyInstance = emptyInstance;
exports.empty         = empty;
exports.hash          = hash;
exports.remove        = remove;
exports.removeAll     = removeAll;
exports.Transient     = Transient$1;
exports.mutate        = mutate;
exports.addAll        = addAll$1;
exports.from          = from;
exports.intersect     = intersect;
exports.subtract      = subtract;
exports.union         = union;
/* include Not a pure module */


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block                   = __webpack_require__(25);
var Curry                   = __webpack_require__(1);
var Sequence                = __webpack_require__(56);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var BitmapTrie              = __webpack_require__(72);
var Caml_array              = __webpack_require__(7);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function add(updateLevelNode, owner, depth, value, _set) {
  while(true) {
    var set = _set;
    if (typeof set === "number") {
      return /* Entry */Block.__(1, [value]);
    } else if (set.tag) {
      var entryValue = set[0];
      if (value === entryValue) {
        return set;
      } else {
        var bitmap = BitmapTrie.bitPos(entryValue, depth);
        _set = /* Level */Block.__(0, [
            bitmap,
            /* array */[set],
            owner
          ]);
        continue ;
        
      }
    } else {
      var nodes = set[1];
      var bitmap$1 = set[0];
      var bit = BitmapTrie.bitPos(value, depth);
      var index = BitmapTrie.index(bitmap$1, bit);
      if (BitmapTrie.containsNode(bitmap$1, bit)) {
        var childNode = Caml_array.caml_array_get(nodes, index);
        var newChildNode = add(updateLevelNode, owner, depth + 1 | 0, value, childNode);
        if (childNode === newChildNode) {
          return set;
        } else {
          return Curry._4(updateLevelNode, owner, index, newChildNode, set);
        }
      } else {
        var entry = /* Entry */Block.__(1, [value]);
        var nodes$1 = CopyOnWriteArray.insertAt(index, entry, nodes);
        return /* Level */Block.__(0, [
                  bitmap$1 | bit,
                  nodes$1,
                  owner
                ]);
      }
    }
  };
}

function contains(_depth, value, _set) {
  while(true) {
    var set = _set;
    var depth = _depth;
    if (typeof set === "number") {
      return /* false */0;
    } else if (set.tag) {
      return +(value === set[0]);
    } else {
      var bitmap = set[0];
      var bit = BitmapTrie.bitPos(value, depth);
      var index = BitmapTrie.index(bitmap, bit);
      if (BitmapTrie.containsNode(bitmap, bit)) {
        _set = Caml_array.caml_array_get(set[1], index);
        _depth = depth + 1 | 0;
        continue ;
        
      } else {
        return /* false */0;
      }
    }
  };
}

function reduceWhile(levelPredicate, levelReducer, predicate, f, acc, map) {
  if (typeof map === "number") {
    return acc;
  } else if (map.tag) {
    var entryValue = map[0];
    if (Curry._2(predicate, acc, entryValue)) {
      return Curry._2(f, acc, entryValue);
    } else {
      return acc;
    }
  } else {
    return Curry._4(CopyOnWriteArray.reduce, levelPredicate, levelReducer, acc, map[1]);
  }
}

function reduce(predicate, f, acc, map) {
  if (predicate === Functions.alwaysTrue2) {
    var levelReducer = function (acc, node) {
      return reduceWhile(/* None */0, levelReducer, Functions.alwaysTrue2, f, acc, node);
    };
    return levelReducer(acc, map);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, v) {
      if (shouldContinue[0]) {
        var result = Curry._2(predicate, acc, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    var levelPredicate = /* Some */[(function (_, _$1) {
          return shouldContinue[0];
        })];
    var levelReducer$1 = function (acc, node) {
      return reduceWhile(levelPredicate, levelReducer$1, predicate$1, f, acc, node);
    };
    return levelReducer$1(acc, map);
  }
}

function remove(updateLevelNode, owner, depth, value, set) {
  if (typeof set === "number") {
    return set;
  } else if (set.tag) {
    if (value === set[0]) {
      return /* Empty */0;
    } else {
      return set;
    }
  } else {
    var nodes = set[1];
    var bitmap = set[0];
    var bit = BitmapTrie.bitPos(value, depth);
    var index = BitmapTrie.index(bitmap, bit);
    if (BitmapTrie.containsNode(bitmap, bit)) {
      var childNode = Caml_array.caml_array_get(nodes, index);
      var newChildNode = remove(updateLevelNode, owner, depth + 1 | 0, value, childNode);
      if (newChildNode === childNode) {
        return set;
      } else if (newChildNode) {
        return Curry._4(updateLevelNode, owner, index, newChildNode, set);
      } else {
        var nodes$1 = CopyOnWriteArray.removeAt(index, nodes);
        if (Curry._1(CopyOnWriteArray.count, nodes$1) > 0) {
          return /* Level */Block.__(0, [
                    bitmap ^ bit,
                    nodes$1,
                    owner
                  ]);
        } else {
          return /* Empty */0;
        }
      }
    } else {
      return set;
    }
  }
}

function toSequence(set) {
  if (typeof set === "number") {
    return Sequence.empty(/* () */0);
  } else if (set.tag) {
    var partial_arg = set[0];
    return (function (param) {
        return Sequence.$$return(partial_arg, param);
      });
  } else {
    return Sequence.flatMap(toSequence, Curry._1(CopyOnWriteArray.toSequence, set[1]));
  }
}

function updateLevelNodePersistent(_, index, childNode, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieIntSet.re",
            142,
            4
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieIntSet.re",
            142,
            4
          ]
        ];
  } else {
    return /* Level */Block.__(0, [
              param[0],
              CopyOnWriteArray.update(index, childNode, param[1]),
              Transient.Owner[/* none */1]
            ]);
  }
}

function updateLevelNodeTransient(owner, index, childNode, node) {
  if (typeof node === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieIntSet.re",
            149,
            4
          ]
        ];
  } else if (node.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieIntSet.re",
            149,
            4
          ]
        ];
  } else {
    var nodes = node[1];
    if (node[2] === owner) {
      Caml_array.caml_array_set(nodes, index, childNode);
      return node;
    } else {
      return /* Level */Block.__(0, [
                node[0],
                CopyOnWriteArray.update(index, childNode, nodes),
                owner
              ]);
    }
  }
}

exports.add                       = add;
exports.contains                  = contains;
exports.reduceWhile               = reduceWhile;
exports.reduce                    = reduce;
exports.remove                    = remove;
exports.toSequence                = toSequence;
exports.updateLevelNodePersistent = updateLevelNodePersistent;
exports.updateLevelNodeTransient  = updateLevelNodeTransient;
/* Sequence Not a pure module */


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var ImmMap        = __webpack_require__(71);
var ImmSet        = __webpack_require__(59);
var Iterable      = __webpack_require__(57);
var Functions     = __webpack_require__(55);
var Transient     = __webpack_require__(58);
var Pervasives    = __webpack_require__(2);
var KeyedReducer  = __webpack_require__(62);
var BitmapTrieMap = __webpack_require__(93);
var KeyedIterable = __webpack_require__(67);

function containsKey(key, param) {
  var hashKey = Curry._1(param[/* hash */3], key);
  return BitmapTrieMap.containsKey(param[/* comparator */2], 0, hashKey, key, param[/* root */1]);
}

function count(param) {
  return param[/* count */0];
}

function get(key, param) {
  var hashKey = Curry._1(param[/* hash */3], key);
  return BitmapTrieMap.get(param[/* comparator */2], 0, hashKey, key, param[/* root */1]);
}

function getOrDefault($$default, key, param) {
  var hashKey = Curry._1(param[/* hash */3], key);
  return BitmapTrieMap.getOrDefault(param[/* comparator */2], 0, $$default, hashKey, key, param[/* root */1]);
}

function getOrRaise(key, param) {
  var hashKey = Curry._1(param[/* hash */3], key);
  return BitmapTrieMap.getOrRaise(param[/* comparator */2], 0, hashKey, key, param[/* root */1]);
}

function reduce(predicate, f, acc, param) {
  return BitmapTrieMap.reduce(predicate, f, acc, param[/* root */1]);
}

var include = KeyedReducer.Make2(/* module */[/* reduce */reduce]);

function toSequence(selector, param) {
  return BitmapTrieMap.toSequence(selector, param[/* root */1]);
}

var include$1 = ImmMap.Make2(/* module */[
      /* containsKey */containsKey,
      /* count */count,
      /* get */get,
      /* getOrDefault */getOrDefault,
      /* getOrRaise */getOrRaise,
      /* reduce */include[0],
      /* reduceKeys */include[1],
      /* reduceValues */include[2],
      /* toSequence */toSequence
    ]);

var containsKey$1 = include$1[13];

var count$1 = include$1[14];

var isEmpty = include$1[15];

var isNotEmpty = include$1[16];

var get$1 = include$1[23];

var getOrDefault$1 = include$1[24];

var getOrRaise$1 = include$1[25];

var keysSet = include$1[26];

function alter(key, f, map) {
  var hash = map[/* hash */3];
  var comparator = map[/* comparator */2];
  var count = map[/* count */0];
  var hashKey = Curry._1(hash, key);
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieMap.alter(comparator, BitmapTrieMap.updateLevelNodePersistent, Transient.Owner[/* none */1], alterResult, 0, hashKey, key, f, map[/* root */1]);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 1 : 
        return map;
    case 2 : 
        return /* record */[
                /* count */count - 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 3 : 
        return /* record */[
                /* count */count,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    
  }
}

function emptyWith(hash, comparator) {
  return /* record */[
          /* count */0,
          /* root : Empty */0,
          /* comparator */comparator,
          /* hash */hash
        ];
}

function put(key, value, map) {
  var hash = map[/* hash */3];
  var comparator = map[/* comparator */2];
  var count = map[/* count */0];
  var hashKey = Curry._1(hash, key);
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieMap.putWithResult(comparator, BitmapTrieMap.updateLevelNodePersistent, Transient.Owner[/* none */1], alterResult, 0, hashKey, key, value, map[/* root */1]);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 1 : 
        return map;
    case 2 : 
        return Pervasives.failwith("invalid state");
    case 3 : 
        return /* record */[
                /* count */count,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    
  }
}

function remove(key, map) {
  return alter(key, Functions.alwaysNone, map);
}

function removeAll(param) {
  return emptyWith(param[/* hash */3], param[/* comparator */2]);
}

var mutate = Transient.create;

function alterImpl(owner, key, f, map) {
  var hash = map[/* hash */3];
  var comparator = map[/* comparator */2];
  var root = map[/* root */1];
  var count = map[/* count */0];
  var hashKey = Curry._1(hash, key);
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieMap.alter(comparator, BitmapTrieMap.updateLevelNodeTransient, owner, alterResult, 0, hashKey, key, f, root);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 1 : 
        return map;
    case 2 : 
        return /* record */[
                /* count */count - 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 3 : 
        if (newRoot === root) {
          return map;
        } else {
          return /* record */[
                  /* count */count,
                  /* root */newRoot,
                  /* comparator */comparator,
                  /* hash */hash
                ];
        }
    
  }
}

function alter$1(key, f, $$transient) {
  return Transient.update2(alterImpl, key, f, $$transient);
}

function containsKey$2(key, $$transient) {
  return Curry._2(containsKey$1, key, Transient.get($$transient));
}

function count$2($$transient) {
  return Curry._1(count$1, Transient.get($$transient));
}

function emptyWith$1(hash, comparator, _) {
  return Transient.create(emptyWith(hash, comparator));
}

function get$2(key, $$transient) {
  return Curry._2(get$1, key, Transient.get($$transient));
}

function getOrDefault$2($$default, key, $$transient) {
  return Curry._3(getOrDefault$1, $$default, key, Transient.get($$transient));
}

function getOrRaise$2(key, $$transient) {
  return Curry._2(getOrRaise$1, key, Transient.get($$transient));
}

function isEmpty$1($$transient) {
  return Curry._1(isEmpty, Transient.get($$transient));
}

function isNotEmpty$1($$transient) {
  return Curry._1(isNotEmpty, Transient.get($$transient));
}

var persist = Transient.persist;

function putImpl(owner, key, value, map) {
  var hash = map[/* hash */3];
  var comparator = map[/* comparator */2];
  var root = map[/* root */1];
  var count = map[/* count */0];
  var hashKey = Curry._1(hash, key);
  var alterResult = [/* NoChange */1];
  var newRoot = BitmapTrieMap.putWithResult(comparator, BitmapTrieMap.updateLevelNodeTransient, owner, alterResult, 0, hashKey, key, value, root);
  var match = alterResult[0];
  switch (match) {
    case 0 : 
        return /* record */[
                /* count */count + 1 | 0,
                /* root */newRoot,
                /* comparator */comparator,
                /* hash */hash
              ];
    case 1 : 
        return map;
    case 2 : 
        return Pervasives.failwith("invalid state");
    case 3 : 
        if (newRoot === root) {
          return map;
        } else {
          return /* record */[
                  /* count */count,
                  /* root */newRoot,
                  /* comparator */comparator,
                  /* hash */hash
                ];
        }
    
  }
}

function put$1(key, value, $$transient) {
  return Transient.update2(putImpl, key, value, $$transient);
}

function putAll(iter, $$transient) {
  return KeyedIterable.reduce(/* None */0, (function (acc, k, v) {
                return put$1(k, v, acc);
              }), $$transient, iter);
}

function putAllEntries(iter, $$transient) {
  return Iterable.reduce(/* None */0, (function (acc, param) {
                return put$1(param[0], param[1], acc);
              }), $$transient, iter);
}

function remove$1(key, $$transient) {
  return alter$1(key, Functions.alwaysNone, $$transient);
}

function removeAllImpl(_, param) {
  return emptyWith(param[/* hash */3], param[/* comparator */2]);
}

function removeAll$1($$transient) {
  return Transient.update(removeAllImpl, $$transient);
}

var Transient$1 = /* module */[
  /* mutate */mutate,
  /* alterImpl */alterImpl,
  /* alter */alter$1,
  /* containsKey */containsKey$2,
  /* count */count$2,
  /* persistentEmptyWith */emptyWith,
  /* emptyWith */emptyWith$1,
  /* get */get$2,
  /* getOrDefault */getOrDefault$2,
  /* getOrRaise */getOrRaise$2,
  /* isEmpty */isEmpty$1,
  /* isNotEmpty */isNotEmpty$1,
  /* persist */persist,
  /* putImpl */putImpl,
  /* put */put$1,
  /* putAll */putAll,
  /* putAllEntries */putAllEntries,
  /* remove */remove$1,
  /* removeAllImpl */removeAllImpl,
  /* removeAll */removeAll$1
];

function putAll$1(iter, map) {
  return Transient.persist(putAll(iter, Transient.create(map)));
}

function putAllEntries$1(iter, map) {
  return Transient.persist(putAllEntries(iter, Transient.create(map)));
}

function fromWith(hash, comparator, iter) {
  return putAll$1(iter, emptyWith(hash, comparator));
}

function fromEntriesWith(hash, comparator, iter) {
  return putAllEntries$1(iter, emptyWith(hash, comparator));
}

function merge(f, initialValue, next) {
  return Transient.persist(Iterable.reduce(/* None */0, (function (acc, key) {
                    var result = Curry._3(f, key, Curry._2(get$1, key, initialValue), Curry._2(get$1, key, next));
                    if (result) {
                      return put$1(key, result[0], acc);
                    } else {
                      return alter$1(key, Functions.alwaysNone, acc);
                    }
                  }), Transient.create(initialValue), ImmSet.union(Curry._1(keysSet, next), Curry._1(keysSet, initialValue))));
}

var every = include$1[0];

var find = include$1[1];

var findOrRaise = include$1[2];

var forEach = include$1[3];

var keys = include$1[4];

var none = include$1[5];

var reduce$1 = include$1[6];

var reduceKeys = include$1[7];

var reduceValues = include$1[8];

var some = include$1[9];

var toIterable = include$1[10];

var toKeyedIterable = include$1[11];

var values = include$1[12];

var keysCollection = include$1[17];

var keysSequence = include$1[18];

var toKeyedCollection = include$1[19];

var toSequence$1 = include$1[20];

var valuesCollection = include$1[21];

var valuesSequence = include$1[22];

var toMap = include$1[27];

exports.every             = every;
exports.find              = find;
exports.findOrRaise       = findOrRaise;
exports.forEach           = forEach;
exports.keys              = keys;
exports.none              = none;
exports.reduce            = reduce$1;
exports.reduceKeys        = reduceKeys;
exports.reduceValues      = reduceValues;
exports.some              = some;
exports.toIterable        = toIterable;
exports.toKeyedIterable   = toKeyedIterable;
exports.values            = values;
exports.containsKey       = containsKey$1;
exports.count             = count$1;
exports.isEmpty           = isEmpty;
exports.isNotEmpty        = isNotEmpty;
exports.keysCollection    = keysCollection;
exports.keysSequence      = keysSequence;
exports.toKeyedCollection = toKeyedCollection;
exports.toSequence        = toSequence$1;
exports.valuesCollection  = valuesCollection;
exports.valuesSequence    = valuesSequence;
exports.get               = get$1;
exports.getOrDefault      = getOrDefault$1;
exports.getOrRaise        = getOrRaise$1;
exports.keysSet           = keysSet;
exports.toMap             = toMap;
exports.alter             = alter;
exports.emptyWith         = emptyWith;
exports.put               = put;
exports.remove            = remove;
exports.removeAll         = removeAll;
exports.Transient         = Transient$1;
exports.mutate            = mutate;
exports.putAll            = putAll$1;
exports.putAllEntries     = putAllEntries$1;
exports.fromWith          = fromWith;
exports.fromEntriesWith   = fromEntriesWith;
exports.merge             = merge;
/* include Not a pure module */


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block                   = __webpack_require__(25);
var Curry                   = __webpack_require__(1);
var Option                  = __webpack_require__(61);
var Sequence                = __webpack_require__(56);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var AVLTreeMap              = __webpack_require__(84);
var BitmapTrie              = __webpack_require__(72);
var Caml_array              = __webpack_require__(7);
var Comparator              = __webpack_require__(73);
var Pervasives              = __webpack_require__(2);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function containsKey(comparator, _depth, hash, key, _set) {
  while(true) {
    var set = _set;
    var depth = _depth;
    if (typeof set === "number") {
      return /* false */0;
    } else {
      switch (set.tag | 0) {
        case 0 : 
            var bitmap = set[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              _set = Caml_array.caml_array_get(set[1], index);
              _depth = depth + 1 | 0;
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        case 1 : 
            if (hash === set[0]) {
              return AVLTreeMap.containsKey(comparator, key, set[1]);
            } else {
              return /* false */0;
            }
        case 2 : 
            if (hash === set[0]) {
              return Comparator.toEquality(comparator, set[1], key);
            } else {
              return /* false */0;
            }
        
      }
    }
  };
}

function get(comparator, _depth, hash, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return /* None */0;
    } else {
      switch (map.tag | 0) {
        case 0 : 
            var bitmap = map[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              _map = Caml_array.caml_array_get(map[1], index);
              _depth = depth + 1 | 0;
              continue ;
              
            } else {
              return /* None */0;
            }
            break;
        case 1 : 
            if (hash === map[0]) {
              return AVLTreeMap.get(comparator, key, map[1]);
            } else {
              return /* None */0;
            }
        case 2 : 
            if (hash === map[0] && Comparator.toEquality(comparator, map[1], key)) {
              return /* Some */[map[2]];
            } else {
              return /* None */0;
            }
        
      }
    }
  };
}

function getOrDefault(comparator, _depth, $$default, hash, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return $$default;
    } else {
      switch (map.tag | 0) {
        case 0 : 
            var bitmap = map[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              _map = Caml_array.caml_array_get(map[1], index);
              _depth = depth + 1 | 0;
              continue ;
              
            } else {
              return $$default;
            }
            break;
        case 1 : 
            if (hash === map[0]) {
              return AVLTreeMap.getOrDefault(comparator, $$default, key, map[1]);
            } else {
              return $$default;
            }
        case 2 : 
            if (hash === map[0] && Comparator.toEquality(comparator, map[1], key)) {
              return map[2];
            } else {
              return $$default;
            }
        
      }
    }
  };
}

function getOrRaise(comparator, _depth, hash, key, _map) {
  while(true) {
    var map = _map;
    var depth = _depth;
    if (typeof map === "number") {
      return Pervasives.failwith("NotFound");
    } else {
      switch (map.tag | 0) {
        case 0 : 
            var bitmap = map[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              _map = Caml_array.caml_array_get(map[1], index);
              _depth = depth + 1 | 0;
              continue ;
              
            } else {
              return Pervasives.failwith("NotFound");
            }
            break;
        case 1 : 
            if (hash === map[0]) {
              return AVLTreeMap.getOrRaise(comparator, key, map[1]);
            } else {
              return Pervasives.failwith("NotFound");
            }
        case 2 : 
            if (hash === map[0] && Comparator.toEquality(comparator, map[1], key)) {
              return map[2];
            } else {
              return Pervasives.failwith("NotFound");
            }
        
      }
    }
  };
}

function reduceWhile(levelPredicate, levelReducer, predicate, f, acc, map) {
  if (typeof map === "number") {
    return acc;
  } else {
    switch (map.tag | 0) {
      case 0 : 
          return Curry._4(CopyOnWriteArray.reduce, levelPredicate, levelReducer, acc, map[1]);
      case 1 : 
          return AVLTreeMap.reduceWhile(predicate, f, acc, map[1]);
      case 2 : 
          var entryValue = map[2];
          var entryKey = map[1];
          if (Curry._3(predicate, acc, entryKey, entryValue)) {
            return Curry._3(f, acc, entryKey, entryValue);
          } else {
            return acc;
          }
      
    }
  }
}

function reduce(predicate, f, acc, map) {
  if (predicate === Functions.alwaysTrue3) {
    var levelReducer = function (acc, node) {
      return reduceWhile(/* None */0, levelReducer, Functions.alwaysTrue3, f, acc, node);
    };
    return levelReducer(acc, map);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, k, v) {
      if (shouldContinue[0]) {
        var result = Curry._3(predicate, acc, k, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    var levelPredicate = /* Some */[(function (_, _$1) {
          return shouldContinue[0];
        })];
    var levelReducer$1 = function (acc, node) {
      return reduceWhile(levelPredicate, levelReducer$1, predicate$1, f, acc, node);
    };
    return levelReducer$1(acc, map);
  }
}

function toSequence(selector, map) {
  if (typeof map === "number") {
    return Sequence.empty(/* () */0);
  } else {
    switch (map.tag | 0) {
      case 0 : 
          return Sequence.flatMap((function (param) {
                        return toSequence(selector, param);
                      }), Curry._1(CopyOnWriteArray.toSequence, map[1]));
      case 1 : 
          return AVLTreeMap.toSequence(selector, map[1]);
      case 2 : 
          var partial_arg = Curry._2(selector, map[1], map[2]);
          return (function (param) {
              return Sequence.$$return(partial_arg, param);
            });
      
    }
  }
}

function putWithResult(comparator, updateLevelNode, owner, alterResult, depth, hash, key, newEntryValue, _map) {
  while(true) {
    var map = _map;
    if (typeof map === "number") {
      alterResult[0] = /* Added */0;
      return /* Entry */Block.__(2, [
                hash,
                key,
                newEntryValue
              ]);
    } else {
      switch (map.tag | 0) {
        case 0 : 
            var nodes = map[1];
            var bitmap = map[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              var childNode = Caml_array.caml_array_get(nodes, index);
              var newChildNode = putWithResult(comparator, updateLevelNode, owner, alterResult, depth + 1 | 0, hash, key, newEntryValue, childNode);
              var match = alterResult[0];
              if (match !== 0) {
                switch (match - 1 | 0) {
                  case 0 : 
                      return map;
                  case 1 : 
                      return Pervasives.failwith("invalid state");
                  case 2 : 
                      return Curry._4(updateLevelNode, owner, index, newChildNode, map);
                  
                }
              } else {
                return Curry._4(updateLevelNode, owner, index, newChildNode, map);
              }
            } else {
              alterResult[0] = /* Added */0;
              var node = /* Entry */Block.__(2, [
                  hash,
                  key,
                  newEntryValue
                ]);
              var nodes$1 = CopyOnWriteArray.insertAt(index, node, nodes);
              return /* Level */Block.__(0, [
                        bitmap | bit,
                        nodes$1,
                        owner
                      ]);
            }
            break;
        case 1 : 
            var entryHash = map[0];
            if (hash === entryHash) {
              var newEntryMap = AVLTreeMap.putWithResult(comparator, alterResult, key, newEntryValue, map[1]);
              var match$1 = alterResult[0];
              switch (match$1) {
                case 0 : 
                    alterResult[0] = /* Added */0;
                    return /* Collision */Block.__(1, [
                              entryHash,
                              newEntryMap
                            ]);
                case 1 : 
                    alterResult[0] = /* NoChange */1;
                    return map;
                case 2 : 
                    return Pervasives.failwith("Invalid State");
                case 3 : 
                    alterResult[0] = /* Replace */3;
                    return /* Collision */Block.__(1, [
                              entryHash,
                              newEntryMap
                            ]);
                
              }
            } else {
              var bitmap$1 = BitmapTrie.bitPos(entryHash, depth);
              _map = /* Level */Block.__(0, [
                  bitmap$1,
                  /* array */[map],
                  owner
                ]);
              continue ;
              
            }
            break;
        case 2 : 
            var entryValue = map[2];
            var entryKey = map[1];
            var entryHash$1 = map[0];
            if (hash === entryHash$1) {
              if (Comparator.toEquality(comparator, key, entryKey)) {
                if (newEntryValue === entryValue) {
                  alterResult[0] = /* NoChange */1;
                  return map;
                } else {
                  alterResult[0] = /* Replace */3;
                  return /* Entry */Block.__(2, [
                            entryHash$1,
                            key,
                            newEntryValue
                          ]);
                }
              } else {
                var map$1 = AVLTreeMap.put(comparator, key, newEntryValue, AVLTreeMap.put(comparator, entryKey, entryValue, /* Empty */0));
                alterResult[0] = /* Added */0;
                return /* Collision */Block.__(1, [
                          entryHash$1,
                          map$1
                        ]);
              }
            } else {
              var bitmap$2 = BitmapTrie.bitPos(entryHash$1, depth);
              _map = /* Level */Block.__(0, [
                  bitmap$2,
                  /* array */[map],
                  owner
                ]);
              continue ;
              
            }
            break;
        
      }
    }
  };
}

function alter(comparator, updateLevelNode, owner, alterResult, depth, hash, key, f, map) {
  if (typeof map === "number") {
    var match = Curry._1(f, /* None */0);
    if (match) {
      alterResult[0] = /* Added */0;
      return /* Entry */Block.__(2, [
                hash,
                key,
                match[0]
              ]);
    } else {
      alterResult[0] = /* NoChange */1;
      return map;
    }
  } else {
    switch (map.tag | 0) {
      case 0 : 
          var nodes = map[1];
          var bitmap = map[0];
          var bit = BitmapTrie.bitPos(hash, depth);
          var index = BitmapTrie.index(bitmap, bit);
          if (BitmapTrie.containsNode(bitmap, bit)) {
            var childNode = Caml_array.caml_array_get(nodes, index);
            var newChildNode = alter(comparator, updateLevelNode, owner, alterResult, depth + 1 | 0, hash, key, f, childNode);
            var match$1 = alterResult[0];
            if (match$1 !== 0) {
              switch (match$1 - 1 | 0) {
                case 0 : 
                    return map;
                case 1 : 
                    if (newChildNode) {
                      return Curry._4(updateLevelNode, owner, index, newChildNode, map);
                    } else {
                      var nodes$1 = CopyOnWriteArray.removeAt(index, nodes);
                      if (Curry._1(CopyOnWriteArray.count, nodes$1) > 0) {
                        return /* Level */Block.__(0, [
                                  bitmap ^ bit,
                                  nodes$1,
                                  owner
                                ]);
                      } else {
                        return /* Empty */0;
                      }
                    }
                    break;
                case 2 : 
                    return Curry._4(updateLevelNode, owner, index, newChildNode, map);
                
              }
            } else {
              return Curry._4(updateLevelNode, owner, index, newChildNode, map);
            }
          } else {
            var match$2 = Curry._1(f, /* None */0);
            if (match$2) {
              alterResult[0] = /* Added */0;
              var node_002 = match$2[0];
              var node = /* Entry */Block.__(2, [
                  hash,
                  key,
                  node_002
                ]);
              var nodes$2 = CopyOnWriteArray.insertAt(index, node, nodes);
              return /* Level */Block.__(0, [
                        bitmap | bit,
                        nodes$2,
                        owner
                      ]);
            } else {
              alterResult[0] = /* NoChange */1;
              return map;
            }
          }
          break;
      case 1 : 
          var entryHash = map[0];
          if (hash === entryHash) {
            var newEntryMap = AVLTreeMap.alter(comparator, alterResult, key, f, map[1]);
            var match$3 = alterResult[0];
            switch (match$3) {
              case 0 : 
                  alterResult[0] = /* Added */0;
                  return /* Collision */Block.__(1, [
                            entryHash,
                            newEntryMap
                          ]);
              case 1 : 
                  alterResult[0] = /* NoChange */1;
                  return map;
              case 2 : 
                  if (typeof newEntryMap === "number") {
                    alterResult[0] = /* Removed */2;
                    return /* Collision */Block.__(1, [
                              entryHash,
                              newEntryMap
                            ]);
                  } else {
                    alterResult[0] = /* Removed */2;
                    if (newEntryMap.tag) {
                      return /* Collision */Block.__(1, [
                                entryHash,
                                newEntryMap
                              ]);
                    } else {
                      return /* Entry */Block.__(2, [
                                entryHash,
                                newEntryMap[0],
                                newEntryMap[1]
                              ]);
                    }
                  }
                  break;
              case 3 : 
                  alterResult[0] = /* Replace */3;
                  return /* Collision */Block.__(1, [
                            entryHash,
                            newEntryMap
                          ]);
              
            }
          } else {
            var match$4 = Curry._1(f, /* None */0);
            if (match$4) {
              var bitmap$1 = BitmapTrie.bitPos(entryHash, depth);
              return putWithResult(comparator, updateLevelNode, owner, alterResult, depth, hash, key, match$4[0], /* Level */Block.__(0, [
                            bitmap$1,
                            /* array */[map],
                            owner
                          ]));
            } else {
              alterResult[0] = /* NoChange */1;
              return map;
            }
          }
          break;
      case 2 : 
          var entryValue = map[2];
          var entryKey = map[1];
          var entryHash$1 = map[0];
          if (hash === entryHash$1) {
            if (Comparator.toEquality(comparator, key, entryKey)) {
              var match$5 = Curry._1(f, Option.$$return(entryValue));
              if (match$5) {
                var newEntryValue = match$5[0];
                if (newEntryValue === entryValue) {
                  alterResult[0] = /* NoChange */1;
                  return map;
                } else {
                  alterResult[0] = /* Replace */3;
                  return /* Entry */Block.__(2, [
                            entryHash$1,
                            key,
                            newEntryValue
                          ]);
                }
              } else {
                alterResult[0] = /* Removed */2;
                return /* Empty */0;
              }
            } else {
              var match$6 = Curry._1(f, /* None */0);
              if (match$6) {
                var map$1 = AVLTreeMap.put(comparator, key, match$6[0], AVLTreeMap.put(comparator, entryKey, entryValue, /* Empty */0));
                alterResult[0] = /* Added */0;
                return /* Collision */Block.__(1, [
                          entryHash$1,
                          map$1
                        ]);
              } else {
                alterResult[0] = /* NoChange */1;
                return map;
              }
            }
          } else {
            var match$7 = Curry._1(f, /* None */0);
            if (match$7) {
              var bitmap$2 = BitmapTrie.bitPos(entryHash$1, depth);
              return putWithResult(comparator, updateLevelNode, owner, alterResult, depth, hash, key, match$7[0], /* Level */Block.__(0, [
                            bitmap$2,
                            /* array */[map],
                            owner
                          ]));
            } else {
              alterResult[0] = /* NoChange */1;
              return map;
            }
          }
          break;
      
    }
  }
}

function updateLevelNodePersistent(_, index, childNode, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieMap.re",
            350,
            4
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieMap.re",
            350,
            4
          ]
        ];
  } else {
    return /* Level */Block.__(0, [
              param[0],
              CopyOnWriteArray.update(index, childNode, param[1]),
              Transient.Owner[/* none */1]
            ]);
  }
}

function updateLevelNodeTransient(owner, index, childNode, node) {
  if (typeof node === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieMap.re",
            357,
            4
          ]
        ];
  } else if (node.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/maps/BitmapTrieMap.re",
            357,
            4
          ]
        ];
  } else {
    var nodes = node[1];
    if (node[2] === owner) {
      Caml_array.caml_array_set(nodes, index, childNode);
      return node;
    } else {
      return /* Level */Block.__(0, [
                node[0],
                CopyOnWriteArray.update(index, childNode, nodes),
                owner
              ]);
    }
  }
}

exports.containsKey               = containsKey;
exports.get                       = get;
exports.getOrDefault              = getOrDefault;
exports.getOrRaise                = getOrRaise;
exports.reduceWhile               = reduceWhile;
exports.reduce                    = reduce;
exports.toSequence                = toSequence;
exports.putWithResult             = putWithResult;
exports.alter                     = alter;
exports.updateLevelNodePersistent = updateLevelNodePersistent;
exports.updateLevelNodeTransient  = updateLevelNodeTransient;
/* Sequence Not a pure module */


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var ImmSet        = __webpack_require__(59);
var Iterable      = __webpack_require__(57);
var Transient     = __webpack_require__(58);
var BitmapTrieSet = __webpack_require__(95);

function contains(value, param) {
  var keyHash = Curry._1(param[/* hash */3], value);
  return BitmapTrieSet.contains(param[/* comparator */2], 0, keyHash, value, param[/* root */1]);
}

function count(param) {
  return param[/* count */0];
}

function reduce(predicate, f, acc, param) {
  return BitmapTrieSet.reduce(predicate, f, acc, param[/* root */1]);
}

function toSequence(param) {
  return BitmapTrieSet.toSequence(param[/* root */1]);
}

var include = ImmSet.Make1(/* module */[
      /* contains */contains,
      /* count */count,
      /* reduce */reduce,
      /* toSequence */toSequence
    ]);

var reduce$1 = include[5];

var count$1 = include[8];

var isEmpty = include[9];

var isNotEmpty = include[10];

var contains$1 = include[13];

var toSet = include[15];

function add(value, set) {
  var hash = set[/* hash */3];
  var comparator = set[/* comparator */2];
  var root = set[/* root */1];
  var keyHash = Curry._1(hash, value);
  var newRoot = BitmapTrieSet.add(comparator, BitmapTrieSet.updateLevelNodePersistent, Transient.Owner[/* none */1], 0, keyHash, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] + 1 | 0,
            /* root */newRoot,
            /* comparator */comparator,
            /* hash */hash
          ];
  }
}

function emptyWith(hash, comparator) {
  return /* record */[
          /* count */0,
          /* root : Empty */0,
          /* comparator */comparator,
          /* hash */hash
        ];
}

function hash(set) {
  var hash$1 = set[/* hash */3];
  return Curry._4(reduce$1, /* None */0, (function (acc, next) {
                return acc + Curry._1(hash$1, next) | 0;
              }), 0, set);
}

function remove(value, set) {
  var hash = set[/* hash */3];
  var comparator = set[/* comparator */2];
  var root = set[/* root */1];
  var keyHash = Curry._1(hash, value);
  var newRoot = BitmapTrieSet.remove(comparator, BitmapTrieSet.updateLevelNodePersistent, Transient.Owner[/* none */1], 0, keyHash, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] - 1 | 0,
            /* root */newRoot,
            /* comparator */comparator,
            /* hash */hash
          ];
  }
}

function removeAll(param) {
  return emptyWith(param[/* hash */3], param[/* comparator */2]);
}

var mutate = Transient.create;

function addImpl(owner, value, set) {
  var hash = set[/* hash */3];
  var comparator = set[/* comparator */2];
  var keyHash = Curry._1(hash, value);
  if (Curry._2(contains$1, value, set)) {
    return set;
  } else {
    var newRoot = BitmapTrieSet.add(comparator, BitmapTrieSet.updateLevelNodeTransient, owner, 0, keyHash, value, set[/* root */1]);
    return /* record */[
            /* count */set[/* count */0] + 1 | 0,
            /* root */newRoot,
            /* comparator */comparator,
            /* hash */hash
          ];
  }
}

function add$1(value, $$transient) {
  return Transient.update1(addImpl, value, $$transient);
}

function addAllImpl(owner, iter, set) {
  var hash = set[/* hash */3];
  var comparator = set[/* comparator */2];
  var count = set[/* count */0];
  var newCount = [count];
  var newRoot = Iterable.reduce(/* None */0, (function (acc, value) {
          var keyHash = Curry._1(hash, value);
          if (BitmapTrieSet.contains(comparator, 0, keyHash, value, acc)) {
            return acc;
          } else {
            var newRoot = BitmapTrieSet.add(comparator, BitmapTrieSet.updateLevelNodeTransient, owner, 0, keyHash, value, acc);
            newCount[0] = newCount[0] + 1 | 0;
            return newRoot;
          }
        }), set[/* root */1], iter);
  if (newCount[0] === count) {
    return set;
  } else {
    return /* record */[
            /* count */newCount[0],
            /* root */newRoot,
            /* comparator */comparator,
            /* hash */hash
          ];
  }
}

function addAll(iter, $$transient) {
  return Transient.update1(addAllImpl, iter, $$transient);
}

function contains$2(value, $$transient) {
  return Curry._2(contains$1, value, Transient.get($$transient));
}

function count$2($$transient) {
  return Curry._1(count$1, Transient.get($$transient));
}

function emptyWith$1(hash, comparator, _) {
  return Transient.create(emptyWith(hash, comparator));
}

function isEmpty$1($$transient) {
  return Curry._1(isEmpty, Transient.get($$transient));
}

function isNotEmpty$1($$transient) {
  return Curry._1(isNotEmpty, Transient.get($$transient));
}

var persist = Transient.persist;

function removeImpl(owner, value, set) {
  var hash = set[/* hash */3];
  var comparator = set[/* comparator */2];
  var root = set[/* root */1];
  var keyHash = Curry._1(hash, value);
  var newRoot = BitmapTrieSet.remove(comparator, BitmapTrieSet.updateLevelNodeTransient, owner, 0, keyHash, value, root);
  if (newRoot === root) {
    return set;
  } else {
    return /* record */[
            /* count */set[/* count */0] - 1 | 0,
            /* root */newRoot,
            /* comparator */comparator,
            /* hash */hash
          ];
  }
}

function remove$1(value, $$transient) {
  return Transient.update1(removeImpl, value, $$transient);
}

function removeAllImpl(_, param) {
  return emptyWith(param[/* hash */3], param[/* comparator */2]);
}

function removeAll$1($$transient) {
  return Transient.update(removeAllImpl, $$transient);
}

var Transient$1 = /* module */[
  /* mutate */mutate,
  /* addImpl */addImpl,
  /* add */add$1,
  /* addAllImpl */addAllImpl,
  /* addAll */addAll,
  /* contains */contains$2,
  /* count */count$2,
  /* persistentEmptyWith */emptyWith,
  /* emptyWith */emptyWith$1,
  /* isEmpty */isEmpty$1,
  /* isNotEmpty */isNotEmpty$1,
  /* persist */persist,
  /* removeImpl */removeImpl,
  /* remove */remove$1,
  /* removeAllImpl */removeAllImpl,
  /* removeAll */removeAll$1
];

function addAll$1(iter, set) {
  var $$transient = Transient.create(set);
  return Transient.persist(Transient.update1(addAllImpl, iter, $$transient));
}

function fromWith(hash, comparator, iterable) {
  return addAll$1(iterable, emptyWith(hash, comparator));
}

function intersect($$this, that) {
  return addAll$1(ImmSet.intersect(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyWith($$this[/* hash */3], $$this[/* comparator */2]));
}

function subtract($$this, that) {
  return addAll$1(ImmSet.subtract(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyWith($$this[/* hash */3], $$this[/* comparator */2]));
}

function union($$this, that) {
  return addAll$1(ImmSet.union(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyWith($$this[/* hash */3], $$this[/* comparator */2]));
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var some = include[6];

var toIterable = include[7];

var toCollection = include[11];

var toSequence$1 = include[12];

var equals = include[14];

exports.every        = every;
exports.find         = find;
exports.findOrRaise  = findOrRaise;
exports.forEach      = forEach;
exports.none         = none;
exports.reduce       = reduce$1;
exports.some         = some;
exports.toIterable   = toIterable;
exports.count        = count$1;
exports.isEmpty      = isEmpty;
exports.isNotEmpty   = isNotEmpty;
exports.toCollection = toCollection;
exports.toSequence   = toSequence$1;
exports.contains     = contains$1;
exports.equals       = equals;
exports.toSet        = toSet;
exports.add          = add;
exports.emptyWith    = emptyWith;
exports.hash         = hash;
exports.remove       = remove;
exports.removeAll    = removeAll;
exports.Transient    = Transient$1;
exports.mutate       = mutate;
exports.addAll       = addAll$1;
exports.fromWith     = fromWith;
exports.intersect    = intersect;
exports.subtract     = subtract;
exports.union        = union;
/* include Not a pure module */


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Block                   = __webpack_require__(25);
var Curry                   = __webpack_require__(1);
var Sequence                = __webpack_require__(56);
var Functions               = __webpack_require__(55);
var Transient               = __webpack_require__(58);
var AVLTreeSet              = __webpack_require__(85);
var BitmapTrie              = __webpack_require__(72);
var Caml_array              = __webpack_require__(7);
var Comparator              = __webpack_require__(73);
var CopyOnWriteArray        = __webpack_require__(60);
var Caml_builtin_exceptions = __webpack_require__(0);

function add(comparator, updateLevelNode, owner, depth, hash, value, _set) {
  while(true) {
    var set = _set;
    if (typeof set === "number") {
      return /* Entry */Block.__(2, [
                hash,
                value
              ]);
    } else {
      switch (set.tag | 0) {
        case 0 : 
            var nodes = set[1];
            var bitmap = set[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              var childNode = Caml_array.caml_array_get(nodes, index);
              var newChildNode = add(comparator, updateLevelNode, owner, depth + 1 | 0, hash, value, childNode);
              if (childNode === newChildNode) {
                return set;
              } else {
                return Curry._4(updateLevelNode, owner, index, newChildNode, set);
              }
            } else {
              var entry = /* Entry */Block.__(2, [
                  hash,
                  value
                ]);
              var nodes$1 = CopyOnWriteArray.insertAt(index, entry, nodes);
              return /* Level */Block.__(0, [
                        bitmap | bit,
                        nodes$1,
                        owner
                      ]);
            }
            break;
        case 1 : 
            var entrySet = set[1];
            var entryHash = set[0];
            if (hash === entryHash) {
              var newEntrySet = AVLTreeSet.add(comparator, value, entrySet);
              if (newEntrySet === entrySet) {
                return set;
              } else {
                return /* Collision */Block.__(1, [
                          entryHash,
                          newEntrySet
                        ]);
              }
            } else {
              var bitmap$1 = BitmapTrie.bitPos(entryHash, depth);
              _set = /* Level */Block.__(0, [
                  bitmap$1,
                  /* array */[set],
                  owner
                ]);
              continue ;
              
            }
            break;
        case 2 : 
            var entryValue = set[1];
            var entryHash$1 = set[0];
            if (hash === entryHash$1) {
              if (Comparator.toEquality(comparator, value, entryValue)) {
                return set;
              } else {
                var set$1 = AVLTreeSet.add(comparator, value, AVLTreeSet.add(comparator, entryValue, /* Empty */0));
                return /* Collision */Block.__(1, [
                          entryHash$1,
                          set$1
                        ]);
              }
            } else {
              var bitmap$2 = BitmapTrie.bitPos(entryHash$1, depth);
              _set = /* Level */Block.__(0, [
                  bitmap$2,
                  /* array */[set],
                  owner
                ]);
              continue ;
              
            }
            break;
        
      }
    }
  };
}

function contains(comparator, _depth, hash, value, _set) {
  while(true) {
    var set = _set;
    var depth = _depth;
    if (typeof set === "number") {
      return /* false */0;
    } else {
      switch (set.tag | 0) {
        case 0 : 
            var bitmap = set[0];
            var bit = BitmapTrie.bitPos(hash, depth);
            var index = BitmapTrie.index(bitmap, bit);
            if (BitmapTrie.containsNode(bitmap, bit)) {
              _set = Caml_array.caml_array_get(set[1], index);
              _depth = depth + 1 | 0;
              continue ;
              
            } else {
              return /* false */0;
            }
            break;
        case 1 : 
            if (hash === set[0]) {
              return AVLTreeSet.contains(comparator, value, set[1]);
            } else {
              return /* false */0;
            }
        case 2 : 
            if (hash === set[0]) {
              return Comparator.toEquality(comparator, set[1], value);
            } else {
              return /* false */0;
            }
        
      }
    }
  };
}

function reduceWhile(levelPredicate, levelReducer, predicate, f, acc, map) {
  if (typeof map === "number") {
    return acc;
  } else {
    switch (map.tag | 0) {
      case 0 : 
          return Curry._4(CopyOnWriteArray.reduce, levelPredicate, levelReducer, acc, map[1]);
      case 1 : 
          return AVLTreeSet.reduceWhile(predicate, f, acc, map[1]);
      case 2 : 
          var entryValue = map[1];
          if (Curry._2(predicate, acc, entryValue)) {
            return Curry._2(f, acc, entryValue);
          } else {
            return acc;
          }
      
    }
  }
}

function reduce(predicate, f, acc, map) {
  if (predicate === Functions.alwaysTrue2) {
    var levelReducer = function (acc, node) {
      return reduceWhile(/* None */0, levelReducer, Functions.alwaysTrue2, f, acc, node);
    };
    return levelReducer(acc, map);
  } else {
    var shouldContinue = [/* true */1];
    var predicate$1 = function (acc, v) {
      if (shouldContinue[0]) {
        var result = Curry._2(predicate, acc, v);
        shouldContinue[0] = result;
        return result;
      } else {
        return /* false */0;
      }
    };
    var levelPredicate = /* Some */[(function (_, _$1) {
          return shouldContinue[0];
        })];
    var levelReducer$1 = function (acc, node) {
      return reduceWhile(levelPredicate, levelReducer$1, predicate$1, f, acc, node);
    };
    return levelReducer$1(acc, map);
  }
}

function remove(comparator, updateLevelNode, owner, depth, hash, value, set) {
  if (typeof set === "number") {
    return set;
  } else {
    switch (set.tag | 0) {
      case 0 : 
          var nodes = set[1];
          var bitmap = set[0];
          var bit = BitmapTrie.bitPos(hash, depth);
          var index = BitmapTrie.index(bitmap, bit);
          if (BitmapTrie.containsNode(bitmap, bit)) {
            var childNode = Caml_array.caml_array_get(nodes, index);
            var newChildNode = remove(comparator, updateLevelNode, owner, depth + 1 | 0, hash, value, childNode);
            if (newChildNode === childNode) {
              return set;
            } else if (newChildNode) {
              return Curry._4(updateLevelNode, owner, index, newChildNode, set);
            } else {
              var nodes$1 = CopyOnWriteArray.removeAt(index, nodes);
              if (Curry._1(CopyOnWriteArray.count, nodes$1) > 0) {
                return /* Level */Block.__(0, [
                          bitmap ^ bit,
                          nodes$1,
                          owner
                        ]);
              } else {
                return /* Empty */0;
              }
            }
          } else {
            return set;
          }
          break;
      case 1 : 
          var entryHash = set[0];
          if (hash === entryHash) {
            var entrySet = set[1];
            var newEntrySet = AVLTreeSet.remove(comparator, value, entrySet);
            if (newEntrySet === entrySet) {
              return set;
            } else if (typeof newEntrySet === "number") {
              return /* Collision */Block.__(1, [
                        entryHash,
                        newEntrySet
                      ]);
            } else if (newEntrySet.tag) {
              return /* Collision */Block.__(1, [
                        entryHash,
                        newEntrySet
                      ]);
            } else {
              return /* Entry */Block.__(2, [
                        entryHash,
                        newEntrySet[0]
                      ]);
            }
          } else {
            return set;
          }
          break;
      case 2 : 
          if (hash === set[0] && Comparator.toEquality(comparator, set[1], value)) {
            return /* Empty */0;
          } else {
            return set;
          }
      
    }
  }
}

function toSequence(set) {
  if (typeof set === "number") {
    return Sequence.empty(/* () */0);
  } else {
    switch (set.tag | 0) {
      case 0 : 
          return Sequence.flatMap(toSequence, Curry._1(CopyOnWriteArray.toSequence, set[1]));
      case 1 : 
          return AVLTreeSet.toSequence(set[1]);
      case 2 : 
          var entryValue = set[1];
          return (function (param) {
              return Sequence.$$return(entryValue, param);
            });
      
    }
  }
}

function updateLevelNodePersistent(_, index, childNode, param) {
  if (typeof param === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieSet.re",
            171,
            4
          ]
        ];
  } else if (param.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieSet.re",
            171,
            4
          ]
        ];
  } else {
    return /* Level */Block.__(0, [
              param[0],
              CopyOnWriteArray.update(index, childNode, param[1]),
              Transient.Owner[/* none */1]
            ]);
  }
}

function updateLevelNodeTransient(owner, index, childNode, node) {
  if (typeof node === "number") {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieSet.re",
            178,
            4
          ]
        ];
  } else if (node.tag) {
    throw [
          Caml_builtin_exceptions.match_failure,
          [
            "/Users/jared/clone/apps/reasnake/node_modules/immutable-re/src/sets/BitmapTrieSet.re",
            178,
            4
          ]
        ];
  } else {
    var nodes = node[1];
    if (node[2] === owner) {
      Caml_array.caml_array_set(nodes, index, childNode);
      return node;
    } else {
      return /* Level */Block.__(0, [
                node[0],
                CopyOnWriteArray.update(index, childNode, nodes),
                owner
              ]);
    }
  }
}

exports.add                       = add;
exports.contains                  = contains;
exports.reduceWhile               = reduceWhile;
exports.reduce                    = reduce;
exports.remove                    = remove;
exports.toSequence                = toSequence;
exports.updateLevelNodePersistent = updateLevelNodePersistent;
exports.updateLevelNodeTransient  = updateLevelNodeTransient;
/* Sequence Not a pure module */


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Char      = __webpack_require__(27);
var Bytes     = __webpack_require__(40);
var Curry     = __webpack_require__(1);
var Int32     = __webpack_require__(35);
var Int64     = __webpack_require__(36);
var $$String  = __webpack_require__(17);
var Nativeint = __webpack_require__(42);

function make(compare, $$this, that) {
  var cmp = Curry._2(compare, $$this, that);
  return +(cmp === 0);
}

function bytes(param, param$1) {
  return make(Bytes.compare, param, param$1);
}

function $$char(param, param$1) {
  return make(Char.compare, param, param$1);
}

function $$int($$this, that) {
  return +($$this === that);
}

function int32(param, param$1) {
  return make(Int32.compare, param, param$1);
}

function int64(param, param$1) {
  return make(Int64.compare, param, param$1);
}

function nativeInt(param, param$1) {
  return make(Nativeint.compare, param, param$1);
}

function reference(that, $$this) {
  return +(that === $$this);
}

function string(param, param$1) {
  return make($$String.compare, param, param$1);
}

exports.make      = make;
exports.bytes     = bytes;
exports.$$char    = $$char;
exports.$$int     = $$int;
exports.int32     = int32;
exports.int64     = int64;
exports.nativeInt = nativeInt;
exports.reference = reference;
exports.string    = string;
/* No side effect */


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var ImmList              = __webpack_require__(64);
var Iterable             = __webpack_require__(57);
var Sequence             = __webpack_require__(56);
var Pervasives           = __webpack_require__(2);
var SequentialCollection = __webpack_require__(70);

function count(param) {
  return param[/* count */0];
}

function firstOrRaise(param) {
  return ImmList.firstOrRaise(param[/* list */1]);
}

function reduce(predicate, f, acc, param) {
  return ImmList.reduce(/* Some */[predicate], f, acc, param[/* list */1]);
}

function toSequence(param) {
  var list = param[/* list */1];
  return (function (param) {
      return Sequence.ofList(list, param);
    });
}

var include = SequentialCollection.Make1(/* module */[
      /* count */count,
      /* firstOrRaise */firstOrRaise,
      /* reduce */reduce,
      /* toSequence */toSequence
    ]);

function addFirst(value, param) {
  return /* record */[
          /* count */param[/* count */0] + 1 | 0,
          /* list : :: */[
            value,
            param[/* list */1]
          ]
        ];
}

function addFirstAll(values, param) {
  var newCount = [param[/* count */0]];
  var newList = Iterable.reduce(/* None */0, (function (acc, next) {
          newCount[0] = newCount[0] + 1 | 0;
          return /* :: */[
                  next,
                  acc
                ];
        }), param[/* list */1], values);
  return /* record */[
          /* count */newCount[0],
          /* list */newList
        ];
}

function empty() {
  return /* record */[
          /* count */0,
          /* list : [] */0
        ];
}

function fromList(list) {
  return /* record */[
          /* count */ImmList.count(list),
          /* list */list
        ];
}

function fromReverse(iter) {
  return addFirstAll(iter, /* record */[
              /* count */0,
              /* list : [] */0
            ]);
}

function removeAll() {
  return /* record */[
          /* count */0,
          /* list : [] */0
        ];
}

function removeFirstOrRaise(param) {
  var list = param[/* list */1];
  return /* record */[
          /* count */param[/* count */0] - 1 | 0,
          /* list */list ? list[1] : Pervasives.failwith("stack is empty")
        ];
}

function $$return(value) {
  return /* record */[
          /* count */1,
          /* list : :: */[
            value,
            /* [] */0
          ]
        ];
}

function toList(param) {
  return param[/* list */1];
}

var every = include[0];

var find = include[1];

var findOrRaise = include[2];

var forEach = include[3];

var none = include[4];

var reduce$1 = include[5];

var some = include[6];

var toIterable = include[7];

var count$1 = include[8];

var isEmpty = include[9];

var isNotEmpty = include[10];

var toCollection = include[11];

var toSequence$1 = include[12];

var first = include[13];

var firstOrRaise$1 = include[14];

var toSequentialCollection = include[15];

exports.every                  = every;
exports.find                   = find;
exports.findOrRaise            = findOrRaise;
exports.forEach                = forEach;
exports.none                   = none;
exports.reduce                 = reduce$1;
exports.some                   = some;
exports.toIterable             = toIterable;
exports.count                  = count$1;
exports.isEmpty                = isEmpty;
exports.isNotEmpty             = isNotEmpty;
exports.toCollection           = toCollection;
exports.toSequence             = toSequence$1;
exports.first                  = first;
exports.firstOrRaise           = firstOrRaise$1;
exports.toSequentialCollection = toSequentialCollection;
exports.addFirst               = addFirst;
exports.addFirstAll            = addFirstAll;
exports.empty                  = empty;
exports.fromList               = fromList;
exports.fromReverse            = fromReverse;
exports.removeAll              = removeAll;
exports.removeFirstOrRaise     = removeFirstOrRaise;
exports.$$return               = $$return;
exports.toList                 = toList;
/* include Not a pure module */


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry         = __webpack_require__(1);
var ImmSet        = __webpack_require__(59);
var Iterable      = __webpack_require__(57);
var Functions     = __webpack_require__(55);
var AVLTreeMap    = __webpack_require__(84);
var Pervasives    = __webpack_require__(2);
var KeyedReducer  = __webpack_require__(62);
var NavigableMap  = __webpack_require__(77);
var KeyedIterable = __webpack_require__(67);

function Make1(Comparable) {
  var comparator = Comparable[/* compare */1];
  var containsKey = function (key, param) {
    return AVLTreeMap.containsKey(comparator, key, param[/* tree */1]);
  };
  var count = function (param) {
    return param[/* count */0];
  };
  var firstOrRaise = function (selector, param) {
    return AVLTreeMap.firstOrRaise(selector, param[/* tree */1]);
  };
  var get = function (key, param) {
    return AVLTreeMap.get(comparator, key, param[/* tree */1]);
  };
  var getOrDefault = function ($$default, key, param) {
    return AVLTreeMap.getOrDefault(comparator, $$default, key, param[/* tree */1]);
  };
  var getOrRaise = function (key, param) {
    return AVLTreeMap.getOrRaise(comparator, key, param[/* tree */1]);
  };
  var lastOrRaise = function (selector, param) {
    return AVLTreeMap.lastOrRaise(selector, param[/* tree */1]);
  };
  var reduce = function (predicate, f, acc, param) {
    return AVLTreeMap.reduce(predicate, f, acc, param[/* tree */1]);
  };
  var include = KeyedReducer.Make1(/* module */[/* reduce */reduce]);
  var reduce$1 = function (predicate, f, acc, param) {
    return AVLTreeMap.reduceReversed(predicate, f, acc, param[/* tree */1]);
  };
  var KeyedReducerReversed = KeyedReducer.Make1(/* module */[/* reduce */reduce$1]);
  var reduceReversed = KeyedReducerReversed[/* reduce */0];
  var reduceKeysReversed = KeyedReducerReversed[/* reduceKeys */1];
  var reduceValuesReversed = KeyedReducerReversed[/* reduceValues */2];
  var toSequence = function (selector, param) {
    return AVLTreeMap.toSequence(selector, param[/* tree */1]);
  };
  var toSequenceReversed = function (selector, param) {
    return AVLTreeMap.toSequenceReversed(selector, param[/* tree */1]);
  };
  var include$1 = NavigableMap.Make1(/* module */[
        /* containsKey */containsKey,
        /* count */count,
        /* firstOrRaise */firstOrRaise,
        /* get */get,
        /* getOrDefault */getOrDefault,
        /* getOrRaise */getOrRaise,
        /* lastOrRaise */lastOrRaise,
        /* reduce */include[0],
        /* reduceReversed */reduceReversed,
        /* reduceKeys */include[1],
        /* reduceKeysReversed */reduceKeysReversed,
        /* reduceValues */include[2],
        /* reduceValuesReversed */reduceValuesReversed,
        /* toSequence */toSequence,
        /* toSequenceReversed */toSequenceReversed
      ]);
  var get$1 = include$1[50];
  var keysSet = include$1[56];
  var alter = function (key, f, map) {
    var count = map[/* count */0];
    var alterResult = [/* NoChange */1];
    var newTree = AVLTreeMap.alter(comparator, alterResult, key, f, map[/* tree */1]);
    var match = alterResult[0];
    switch (match) {
      case 0 : 
          return /* record */[
                  /* count */count + 1 | 0,
                  /* tree */newTree
                ];
      case 1 : 
          return map;
      case 2 : 
          return /* record */[
                  /* count */count - 1 | 0,
                  /* tree */newTree
                ];
      case 3 : 
          return /* record */[
                  /* count */count,
                  /* tree */newTree
                ];
      
    }
  };
  var empty = function () {
    return /* record */[
            /* count */0,
            /* tree : Empty */0
          ];
  };
  var put = function (key, value, map) {
    var count = map[/* count */0];
    var alterResult = [/* NoChange */1];
    var newTree = AVLTreeMap.putWithResult(comparator, alterResult, key, value, map[/* tree */1]);
    var match = alterResult[0];
    switch (match) {
      case 0 : 
          return /* record */[
                  /* count */count + 1 | 0,
                  /* tree */newTree
                ];
      case 1 : 
          return map;
      case 2 : 
          return Pervasives.failwith("invalid state");
      case 3 : 
          return /* record */[
                  /* count */count,
                  /* tree */newTree
                ];
      
    }
  };
  var putAll = function (iter, map) {
    return KeyedIterable.reduce(/* None */0, (function (acc, k, v) {
                  return put(k, v, acc);
                }), map, iter);
  };
  var putAllEntries = function (iter, map) {
    return Iterable.reduce(/* None */0, (function (acc, param) {
                  return put(param[0], param[1], acc);
                }), map, iter);
  };
  var from = function (iter) {
    return putAll(iter, /* record */[
                /* count */0,
                /* tree : Empty */0
              ]);
  };
  var fromEntries = function (iter) {
    return putAllEntries(iter, /* record */[
                /* count */0,
                /* tree : Empty */0
              ]);
  };
  var remove = function (key, map) {
    return alter(key, Functions.alwaysNone, map);
  };
  var removeAll = function () {
    return /* record */[
            /* count */0,
            /* tree : Empty */0
          ];
  };
  var removeFirstOrRaise = function (param) {
    var newTree = AVLTreeMap.removeFirstOrRaise(param[/* tree */1]);
    return /* record */[
            /* count */param[/* count */0] - 1 | 0,
            /* tree */newTree
          ];
  };
  var removeLastOrRaise = function (param) {
    var newTree = AVLTreeMap.removeLastOrRaise(param[/* tree */1]);
    return /* record */[
            /* count */param[/* count */0] - 1 | 0,
            /* tree */newTree
          ];
  };
  var merge = function (f, acc, next) {
    return Iterable.reduce(/* None */0, (function (acc, key) {
                  var result = Curry._3(f, key, Curry._2(get$1, key, acc), Curry._2(get$1, key, next));
                  if (result) {
                    return put(key, result[0], acc);
                  } else {
                    return alter(key, Functions.alwaysNone, acc);
                  }
                }), acc, ImmSet.union(Curry._1(keysSet, next), Curry._1(keysSet, acc)));
  };
  return /* module */[
          /* comparator */comparator,
          /* first */include$1[0],
          /* firstOrRaise */include$1[1],
          /* keysCollectionReversed */include$1[2],
          /* keysNavigableCollection */include$1[3],
          /* keysNavigableCollectionReversed */include$1[4],
          /* keysReversed */include$1[5],
          /* keysSequentialCollection */include$1[6],
          /* keysSequentialCollectionReversed */include$1[7],
          /* keysSequenceReversed */include$1[8],
          /* last */include$1[9],
          /* lastOrRaise */include$1[10],
          /* reduceReversed */include$1[11],
          /* reduceKeysReversed */include$1[12],
          /* reduceValuesReversed */include$1[13],
          /* toIterableReversed */include$1[14],
          /* toKeyedCollectionReversed */include$1[15],
          /* toKeyedIterableReversed */include$1[16],
          /* toNavigableKeyedCollection */include$1[17],
          /* toNavigableKeyedCollectionReversed */include$1[18],
          /* toSequenceReversed */include$1[19],
          /* valuesCollectionReversed */include$1[20],
          /* valuesNavigableCollection */include$1[21],
          /* valuesNavigableCollectionReversed */include$1[22],
          /* valuesReversed */include$1[23],
          /* valuesSequentialCollection */include$1[24],
          /* valuesSequentialCollectionReversed */include$1[25],
          /* valuesSequenceReversed */include$1[26],
          /* every */include$1[27],
          /* find */include$1[28],
          /* findOrRaise */include$1[29],
          /* forEach */include$1[30],
          /* keys */include$1[31],
          /* none */include$1[32],
          /* reduce */include$1[33],
          /* reduceKeys */include$1[34],
          /* reduceValues */include$1[35],
          /* some */include$1[36],
          /* toIterable */include$1[37],
          /* toKeyedIterable */include$1[38],
          /* values */include$1[39],
          /* containsKey */include$1[40],
          /* count */include$1[41],
          /* isEmpty */include$1[42],
          /* isNotEmpty */include$1[43],
          /* keysCollection */include$1[44],
          /* keysSequence */include$1[45],
          /* toKeyedCollection */include$1[46],
          /* toSequence */include$1[47],
          /* valuesCollection */include$1[48],
          /* valuesSequence */include$1[49],
          /* get */get$1,
          /* getOrDefault */include$1[51],
          /* getOrRaise */include$1[52],
          /* toMap */include$1[53],
          /* keysNavigableSet */include$1[54],
          /* keysNavigableSetReversed */include$1[55],
          /* keysSet */keysSet,
          /* toMapReversed */include$1[57],
          /* toNavigableMap */include$1[58],
          /* toNavigableMapReversed */include$1[59],
          /* alter */alter,
          /* empty */empty,
          /* put */put,
          /* putAll */putAll,
          /* putAllEntries */putAllEntries,
          /* from */from,
          /* fromEntries */fromEntries,
          /* remove */remove,
          /* removeAll */removeAll,
          /* removeFirstOrRaise */removeFirstOrRaise,
          /* removeLastOrRaise */removeLastOrRaise,
          /* merge */merge
        ];
}

exports.Make1 = Make1;
/* ImmSet Not a pure module */


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry        = __webpack_require__(1);
var ImmSet       = __webpack_require__(59);
var Iterable     = __webpack_require__(57);
var Ordering     = __webpack_require__(65);
var AVLTreeSet   = __webpack_require__(85);
var Comparator   = __webpack_require__(73);
var NavigableSet = __webpack_require__(68);

function Make(Comparable) {
  var comparator = Comparable[/* compare */1];
  var contains = function (x, param) {
    return AVLTreeSet.contains(comparator, x, param[/* tree */1]);
  };
  var count = function (param) {
    return param[/* count */0];
  };
  var firstOrRaise = function (param) {
    return AVLTreeSet.firstOrRaise(param[/* tree */1]);
  };
  var lastOrRaise = function (param) {
    return AVLTreeSet.lastOrRaise(param[/* tree */1]);
  };
  var reduce = function (predicate, f, acc, param) {
    return AVLTreeSet.reduce(predicate, f, acc, param[/* tree */1]);
  };
  var reduceReversed = function (predicate, f, acc, param) {
    return AVLTreeSet.reduceReversed(predicate, f, acc, param[/* tree */1]);
  };
  var toSequence = function (param) {
    return AVLTreeSet.toSequence(param[/* tree */1]);
  };
  var toSequenceReversed = function (param) {
    return AVLTreeSet.toSequenceReversed(param[/* tree */1]);
  };
  var include = NavigableSet.Make(/* module */[
        /* contains */contains,
        /* count */count,
        /* firstOrRaise */firstOrRaise,
        /* lastOrRaise */lastOrRaise,
        /* reduce */reduce,
        /* reduceReversed */reduceReversed,
        /* toSequence */toSequence,
        /* toSequenceReversed */toSequenceReversed
      ]);
  var toSet = include[2];
  var toSequence$1 = include[15];
  var add = function (x, sortedSet) {
    var tree = sortedSet[/* tree */1];
    var newTree = AVLTreeSet.add(comparator, x, tree);
    if (newTree === tree) {
      return sortedSet;
    } else {
      return /* record */[
              /* count */sortedSet[/* count */0] + 1 | 0,
              /* tree */newTree
            ];
    }
  };
  var addAll = function (iter, sortedSet) {
    return Iterable.reduce(/* None */0, (function (acc, next) {
                  return add(next, acc);
                }), sortedSet, iter);
  };
  var compareWith = function (valueCompare, _this, _that) {
    while(true) {
      var that = _that;
      var $$this = _this;
      var match = Curry._1($$this, /* () */0);
      var match$1 = Curry._1(that, /* () */0);
      if (match) {
        if (match$1) {
          var cmp = Curry._2(valueCompare, match[0], match$1[0]);
          if (cmp === Ordering.equal) {
            _that = match$1[1];
            _this = match[1];
            continue ;
            
          } else {
            return cmp;
          }
        } else {
          return Ordering.greaterThan;
        }
      } else if (match$1) {
        return Ordering.lessThan;
      } else {
        return Ordering.equal;
      }
    };
  };
  var compare = function ($$this, that) {
    return compareWith(comparator, Curry._1(toSequence$1, $$this), Curry._1(toSequence$1, that));
  };
  var emptyInstance = /* record */[
    /* count */0,
    /* tree : Empty */0
  ];
  var empty = function () {
    return emptyInstance;
  };
  var equalsWith = function (equality, _this, _that) {
    while(true) {
      var that = _that;
      var $$this = _this;
      if (that === $$this) {
        return /* true */1;
      } else {
        var match = Curry._1(that, /* () */0);
        var match$1 = Curry._1($$this, /* () */0);
        if (match) {
          if (match$1) {
            if (Curry._2(equality, match[0], match$1[0])) {
              _that = match$1[1];
              _this = match[1];
              continue ;
              
            } else {
              return /* false */0;
            }
          } else {
            return /* false */0;
          }
        } else if (match$1) {
          return /* false */0;
        } else {
          return /* true */1;
        }
      }
    };
  };
  var equality = function (param, param$1) {
    return Comparator.toEquality(comparator, param, param$1);
  };
  var equals = function ($$this, that) {
    return equalsWith(equality, Curry._1(toSequence$1, $$this), Curry._1(toSequence$1, that));
  };
  var from = function (iter) {
    return addAll(iter, emptyInstance);
  };
  var remove = function (x, sortedSet) {
    var tree = sortedSet[/* tree */1];
    var newTree = AVLTreeSet.remove(comparator, x, tree);
    if (newTree === tree) {
      return sortedSet;
    } else {
      return /* record */[
              /* count */sortedSet[/* count */0] - 1 | 0,
              /* tree */newTree
            ];
    }
  };
  var removeAll = function () {
    return emptyInstance;
  };
  var removeFirstOrRaise = function (param) {
    var newTree = AVLTreeSet.removeFirstOrRaise(param[/* tree */1]);
    return /* record */[
            /* count */param[/* count */0] - 1 | 0,
            /* tree */newTree
          ];
  };
  var removeLastOrRaise = function (param) {
    var newTree = AVLTreeSet.removeLastOrRaise(param[/* tree */1]);
    return /* record */[
            /* count */param[/* count */0] - 1 | 0,
            /* tree */newTree
          ];
  };
  var intersect = function ($$this, that) {
    return addAll(ImmSet.intersect(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
  };
  var subtract = function ($$this, that) {
    return addAll(ImmSet.subtract(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
  };
  var union = function ($$this, that) {
    return addAll(ImmSet.union(Curry._1(toSet, $$this), Curry._1(toSet, that)), emptyInstance);
  };
  return /* module */[
          /* comparator */comparator,
          /* contains */include[1],
          /* toSet */toSet,
          /* every */include[3],
          /* find */include[4],
          /* findOrRaise */include[5],
          /* forEach */include[6],
          /* none */include[7],
          /* reduce */include[8],
          /* some */include[9],
          /* toIterable */include[10],
          /* count */include[11],
          /* isEmpty */include[12],
          /* isNotEmpty */include[13],
          /* toCollection */include[14],
          /* toSequence */toSequence$1,
          /* first */include[16],
          /* firstOrRaise */include[17],
          /* toSequentialCollection */include[18],
          /* last */include[19],
          /* lastOrRaise */include[20],
          /* reduceReversed */include[21],
          /* toCollectionReversed */include[22],
          /* toIterableReversed */include[23],
          /* toNavigableCollection */include[24],
          /* toNavigableCollectionReversed */include[25],
          /* toSequenceReversed */include[26],
          /* toSequentialCollectionReversed */include[27],
          /* toNavigableSet */include[28],
          /* toNavigableSetReversed */include[29],
          /* toSetReversed */include[30],
          /* add */add,
          /* addAll */addAll,
          /* compareWith */compareWith,
          /* compare */compare,
          /* emptyInstance */emptyInstance,
          /* empty */empty,
          /* equalsWith */equalsWith,
          /* equality */equality,
          /* equals */equals,
          /* from */from,
          /* remove */remove,
          /* removeAll */removeAll,
          /* removeFirstOrRaise */removeFirstOrRaise,
          /* removeLastOrRaise */removeLastOrRaise,
          /* intersect */intersect,
          /* subtract */subtract,
          /* union */union
        ];
}

exports.Make = Make;
/* ImmSet Not a pure module */


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Sys                     = __webpack_require__(21);
var $$Array                 = __webpack_require__(24);
var Block                   = __webpack_require__(25);
var Bytes                   = __webpack_require__(40);
var Curry                   = __webpack_require__(1);
var Random                  = __webpack_require__(23);
var Caml_obj                = __webpack_require__(4);
var Caml_sys                = __webpack_require__(15);
var Caml_hash               = __webpack_require__(101);
var Caml_array              = __webpack_require__(7);
var Pervasives              = __webpack_require__(2);
var Caml_string             = __webpack_require__(6);
var CamlinternalLazy        = __webpack_require__(103);
var Caml_missing_polyfill   = __webpack_require__(28);
var Caml_builtin_exceptions = __webpack_require__(0);

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function hash_param(n1, n2, x) {
  return Caml_hash.caml_hash(n1, n2, 0, x);
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

var params;

try {
  params = Caml_sys.caml_sys_getenv("OCAMLRUNPARAM");
}
catch (exn){
  try {
    params = Caml_sys.caml_sys_getenv("CAMLRUNPARAM");
  }
  catch (exn$1){
    params = "";
  }
}

var randomized_default = Bytes.contains(Caml_string.bytes_of_string(params), /* "R" */82);

var randomized = [randomized_default];

function randomize() {
  randomized[0] = /* true */1;
  return /* () */0;
}

var prng = Block.__(246, [(function () {
        return Curry._1(Random.State[/* make_self_init */1], /* () */0);
      })]);

function power_2_above(_x, n) {
  while(true) {
    var x = _x;
    if (x >= n) {
      return x;
    } else if ((x << 1) > Sys.max_array_length) {
      return x;
    } else {
      _x = (x << 1);
      continue ;
      
    }
  };
}

function create($staropt$star, initial_size) {
  var random = $staropt$star ? $staropt$star[0] : randomized[0];
  var s = power_2_above(16, initial_size);
  var seed;
  if (random) {
    var tag = prng.tag | 0;
    seed = Curry._1(Random.State[/* bits */3], tag === 250 ? prng[0] : (
            tag === 246 ? CamlinternalLazy.force_lazy_block(prng) : prng
          ));
  } else {
    seed = 0;
  }
  return /* record */[
          /* size */0,
          /* data */Caml_array.caml_make_vect(s, /* Empty */0),
          /* seed */seed,
          /* initial_size */s
        ];
}

function clear(h) {
  h[/* size */0] = 0;
  var len = h[/* data */1].length;
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(h[/* data */1], i, /* Empty */0);
  }
  return /* () */0;
}

function reset(h) {
  var len = h[/* data */1].length;
  if (h.length < 4 || len === h[/* initial_size */3]) {
    return clear(h);
  } else {
    h[/* size */0] = 0;
    h[/* data */1] = Caml_array.caml_make_vect(h[/* initial_size */3], /* Empty */0);
    return /* () */0;
  }
}

function copy(h) {
  return /* record */[
          /* size */h[/* size */0],
          /* data */$$Array.copy(h[/* data */1]),
          /* seed */h[/* seed */2],
          /* initial_size */h[/* initial_size */3]
        ];
}

function length(h) {
  return h[/* size */0];
}

function resize(indexfun, h) {
  var odata = h[/* data */1];
  var osize = odata.length;
  var nsize = (osize << 1);
  if (nsize < Sys.max_array_length) {
    var ndata = Caml_array.caml_make_vect(nsize, /* Empty */0);
    h[/* data */1] = ndata;
    var insert_bucket = function (param) {
      if (param) {
        var key = param[0];
        insert_bucket(param[2]);
        var nidx = Curry._2(indexfun, h, key);
        return Caml_array.caml_array_set(ndata, nidx, /* Cons */[
                    key,
                    param[1],
                    Caml_array.caml_array_get(ndata, nidx)
                  ]);
      } else {
        return /* () */0;
      }
    };
    for(var i = 0 ,i_finish = osize - 1 | 0; i <= i_finish; ++i){
      insert_bucket(Caml_array.caml_array_get(odata, i));
    }
    return /* () */0;
  } else {
    return 0;
  }
}

function key_index(h, key) {
  if (h.length >= 3) {
    return Caml_hash.caml_hash(10, 100, h[/* seed */2], key) & (h[/* data */1].length - 1 | 0);
  } else {
    return Caml_missing_polyfill.not_implemented("caml_hash_univ_param not implemented by bucklescript yet\n") % h[/* data */1].length;
  }
}

function add(h, key, info) {
  var i = key_index(h, key);
  var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);
  var bucket = /* Cons */[
    key,
    info,
    bucket_002
  ];
  Caml_array.caml_array_set(h[/* data */1], i, bucket);
  h[/* size */0] = h[/* size */0] + 1 | 0;
  if (h[/* size */0] > (h[/* data */1].length << 1)) {
    return resize(key_index, h);
  } else {
    return 0;
  }
}

function remove(h, key) {
  var remove_bucket = function (param) {
    if (param) {
      var next = param[2];
      var k = param[0];
      if (Caml_obj.caml_compare(k, key)) {
        return /* Cons */[
                k,
                param[1],
                remove_bucket(next)
              ];
      } else {
        h[/* size */0] = h[/* size */0] - 1 | 0;
        return next;
      }
    } else {
      return /* Empty */0;
    }
  };
  var i = key_index(h, key);
  return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));
}

function find(h, key) {
  var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
  if (match) {
    if (Caml_obj.caml_compare(key, match[0])) {
      var rest1 = match[2];
      if (rest1) {
        if (Caml_obj.caml_compare(key, rest1[0])) {
          var rest2 = rest1[2];
          if (rest2) {
            if (Caml_obj.caml_compare(key, rest2[0])) {
              var key$1 = key;
              var _param = rest2[2];
              while(true) {
                var param = _param;
                if (param) {
                  if (Caml_obj.caml_compare(key$1, param[0])) {
                    _param = param[2];
                    continue ;
                    
                  } else {
                    return param[1];
                  }
                } else {
                  throw Caml_builtin_exceptions.not_found;
                }
              };
            } else {
              return rest2[1];
            }
          } else {
            throw Caml_builtin_exceptions.not_found;
          }
        } else {
          return rest1[1];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      return match[1];
    }
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_all(h, key) {
  var find_in_bucket = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var rest = param[2];
        if (Caml_obj.caml_compare(param[0], key)) {
          _param = rest;
          continue ;
          
        } else {
          return /* :: */[
                  param[1],
                  find_in_bucket(rest)
                ];
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));
}

function replace(h, key, info) {
  var replace_bucket = function (param) {
    if (param) {
      var next = param[2];
      var k = param[0];
      if (Caml_obj.caml_compare(k, key)) {
        return /* Cons */[
                k,
                param[1],
                replace_bucket(next)
              ];
      } else {
        return /* Cons */[
                key,
                info,
                next
              ];
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var i = key_index(h, key);
  var l = Caml_array.caml_array_get(h[/* data */1], i);
  try {
    return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[
            key,
            info,
            l
          ]);
      h[/* size */0] = h[/* size */0] + 1 | 0;
      if (h[/* size */0] > (h[/* data */1].length << 1)) {
        return resize(key_index, h);
      } else {
        return 0;
      }
    } else {
      throw exn;
    }
  }
}

function mem(h, key) {
  var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
  while(true) {
    var param = _param;
    if (param) {
      if (Caml_obj.caml_compare(param[0], key)) {
        _param = param[2];
        continue ;
        
      } else {
        return /* true */1;
      }
    } else {
      return /* false */0;
    }
  };
}

function iter(f, h) {
  var do_bucket = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        Curry._2(f, param[0], param[1]);
        _param = param[2];
        continue ;
        
      } else {
        return /* () */0;
      }
    };
  };
  var d = h[/* data */1];
  for(var i = 0 ,i_finish = d.length - 1 | 0; i <= i_finish; ++i){
    do_bucket(Caml_array.caml_array_get(d, i));
  }
  return /* () */0;
}

function fold(f, h, init) {
  var do_bucket = function (_b, _accu) {
    while(true) {
      var accu = _accu;
      var b = _b;
      if (b) {
        _accu = Curry._3(f, b[0], b[1], accu);
        _b = b[2];
        continue ;
        
      } else {
        return accu;
      }
    };
  };
  var d = h[/* data */1];
  var accu = init;
  for(var i = 0 ,i_finish = d.length - 1 | 0; i <= i_finish; ++i){
    accu = do_bucket(Caml_array.caml_array_get(d, i), accu);
  }
  return accu;
}

function bucket_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (param) {
      _param = param[2];
      _accu = accu + 1 | 0;
      continue ;
      
    } else {
      return accu;
    }
  };
}

function stats(h) {
  var mbl = $$Array.fold_left((function (m, b) {
          return Pervasives.max(m, bucket_length(0, b));
        }), 0, h[/* data */1]);
  var histo = Caml_array.caml_make_vect(mbl + 1 | 0, 0);
  $$Array.iter((function (b) {
          var l = bucket_length(0, b);
          return Caml_array.caml_array_set(histo, l, Caml_array.caml_array_get(histo, l) + 1 | 0);
        }), h[/* data */1]);
  return /* record */[
          /* num_bindings */h[/* size */0],
          /* num_buckets */h[/* data */1].length,
          /* max_bucket_length */mbl,
          /* bucket_histogram */histo
        ];
}

function MakeSeeded(H) {
  var key_index = function (h, key) {
    return Curry._2(H[/* hash */1], h[/* seed */2], key) & (h[/* data */1].length - 1 | 0);
  };
  var add = function (h, key, info) {
    var i = key_index(h, key);
    var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);
    var bucket = /* Cons */[
      key,
      info,
      bucket_002
    ];
    Caml_array.caml_array_set(h[/* data */1], i, bucket);
    h[/* size */0] = h[/* size */0] + 1 | 0;
    if (h[/* size */0] > (h[/* data */1].length << 1)) {
      return resize(key_index, h);
    } else {
      return 0;
    }
  };
  var remove = function (h, key) {
    var remove_bucket = function (param) {
      if (param) {
        var next = param[2];
        var k = param[0];
        if (Curry._2(H[/* equal */0], k, key)) {
          h[/* size */0] = h[/* size */0] - 1 | 0;
          return next;
        } else {
          return /* Cons */[
                  k,
                  param[1],
                  remove_bucket(next)
                ];
        }
      } else {
        return /* Empty */0;
      }
    };
    var i = key_index(h, key);
    return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));
  };
  var find = function (h, key) {
    var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
    if (match) {
      var rest1 = match[2];
      if (Curry._2(H[/* equal */0], key, match[0])) {
        return match[1];
      } else if (rest1) {
        var rest2 = rest1[2];
        if (Curry._2(H[/* equal */0], key, rest1[0])) {
          return rest1[1];
        } else if (rest2) {
          if (Curry._2(H[/* equal */0], key, rest2[0])) {
            return rest2[1];
          } else {
            var key$1 = key;
            var _param = rest2[2];
            while(true) {
              var param = _param;
              if (param) {
                if (Curry._2(H[/* equal */0], key$1, param[0])) {
                  return param[1];
                } else {
                  _param = param[2];
                  continue ;
                  
                }
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            };
          }
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var find_all = function (h, key) {
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (param) {
          var rest = param[2];
          if (Curry._2(H[/* equal */0], param[0], key)) {
            return /* :: */[
                    param[1],
                    find_in_bucket(rest)
                  ];
          } else {
            _param = rest;
            continue ;
            
          }
        } else {
          return /* [] */0;
        }
      };
    };
    return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));
  };
  var replace = function (h, key, info) {
    var replace_bucket = function (param) {
      if (param) {
        var next = param[2];
        var k = param[0];
        if (Curry._2(H[/* equal */0], k, key)) {
          return /* Cons */[
                  key,
                  info,
                  next
                ];
        } else {
          return /* Cons */[
                  k,
                  param[1],
                  replace_bucket(next)
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
    var i = key_index(h, key);
    var l = Caml_array.caml_array_get(h[/* data */1], i);
    try {
      return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[
              key,
              info,
              l
            ]);
        h[/* size */0] = h[/* size */0] + 1 | 0;
        if (h[/* size */0] > (h[/* data */1].length << 1)) {
          return resize(key_index, h);
        } else {
          return 0;
        }
      } else {
        throw exn;
      }
    }
  };
  var mem = function (h, key) {
    var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(H[/* equal */0], param[0], key)) {
          return /* true */1;
        } else {
          _param = param[2];
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    };
  };
  return /* module */[
          /* create */create,
          /* clear */clear,
          /* reset */reset,
          /* copy */copy,
          /* add */add,
          /* remove */remove,
          /* find */find,
          /* find_all */find_all,
          /* replace */replace,
          /* mem */mem,
          /* iter */iter,
          /* fold */fold,
          /* length */length,
          /* stats */stats
        ];
}

function Make(H) {
  var equal = H[/* equal */0];
  var key_index = function (h, key) {
    return Curry._1(H[/* hash */1], key) & (h[/* data */1].length - 1 | 0);
  };
  var add = function (h, key, info) {
    var i = key_index(h, key);
    var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);
    var bucket = /* Cons */[
      key,
      info,
      bucket_002
    ];
    Caml_array.caml_array_set(h[/* data */1], i, bucket);
    h[/* size */0] = h[/* size */0] + 1 | 0;
    if (h[/* size */0] > (h[/* data */1].length << 1)) {
      return resize(key_index, h);
    } else {
      return 0;
    }
  };
  var remove = function (h, key) {
    var remove_bucket = function (param) {
      if (param) {
        var next = param[2];
        var k = param[0];
        if (Curry._2(equal, k, key)) {
          h[/* size */0] = h[/* size */0] - 1 | 0;
          return next;
        } else {
          return /* Cons */[
                  k,
                  param[1],
                  remove_bucket(next)
                ];
        }
      } else {
        return /* Empty */0;
      }
    };
    var i = key_index(h, key);
    return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));
  };
  var find = function (h, key) {
    var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
    if (match) {
      var rest1 = match[2];
      if (Curry._2(equal, key, match[0])) {
        return match[1];
      } else if (rest1) {
        var rest2 = rest1[2];
        if (Curry._2(equal, key, rest1[0])) {
          return rest1[1];
        } else if (rest2) {
          if (Curry._2(equal, key, rest2[0])) {
            return rest2[1];
          } else {
            var key$1 = key;
            var _param = rest2[2];
            while(true) {
              var param = _param;
              if (param) {
                if (Curry._2(equal, key$1, param[0])) {
                  return param[1];
                } else {
                  _param = param[2];
                  continue ;
                  
                }
              } else {
                throw Caml_builtin_exceptions.not_found;
              }
            };
          }
        } else {
          throw Caml_builtin_exceptions.not_found;
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
  var find_all = function (h, key) {
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (param) {
          var rest = param[2];
          if (Curry._2(equal, param[0], key)) {
            return /* :: */[
                    param[1],
                    find_in_bucket(rest)
                  ];
          } else {
            _param = rest;
            continue ;
            
          }
        } else {
          return /* [] */0;
        }
      };
    };
    return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));
  };
  var replace = function (h, key, info) {
    var replace_bucket = function (param) {
      if (param) {
        var next = param[2];
        var k = param[0];
        if (Curry._2(equal, k, key)) {
          return /* Cons */[
                  key,
                  info,
                  next
                ];
        } else {
          return /* Cons */[
                  k,
                  param[1],
                  replace_bucket(next)
                ];
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
    var i = key_index(h, key);
    var l = Caml_array.caml_array_get(h[/* data */1], i);
    try {
      return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[
              key,
              info,
              l
            ]);
        h[/* size */0] = h[/* size */0] + 1 | 0;
        if (h[/* size */0] > (h[/* data */1].length << 1)) {
          return resize(key_index, h);
        } else {
          return 0;
        }
      } else {
        throw exn;
      }
    }
  };
  var mem = function (h, key) {
    var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));
    while(true) {
      var param = _param;
      if (param) {
        if (Curry._2(equal, param[0], key)) {
          return /* true */1;
        } else {
          _param = param[2];
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    };
  };
  var create$1 = function (sz) {
    return create(/* Some */[/* false */0], sz);
  };
  return /* module */[
          /* create */create$1,
          /* clear */clear,
          /* reset */reset,
          /* copy */copy,
          /* add */add,
          /* remove */remove,
          /* find */find,
          /* find_all */find_all,
          /* replace */replace,
          /* mem */mem,
          /* iter */iter,
          /* fold */fold,
          /* length */length,
          /* stats */stats
        ];
}

var seeded_hash_param = Caml_hash.caml_hash;

exports.create            = create;
exports.clear             = clear;
exports.reset             = reset;
exports.copy              = copy;
exports.add               = add;
exports.find              = find;
exports.find_all          = find_all;
exports.mem               = mem;
exports.remove            = remove;
exports.replace           = replace;
exports.iter              = iter;
exports.fold              = fold;
exports.length            = length;
exports.randomize         = randomize;
exports.stats             = stats;
exports.Make              = Make;
exports.MakeSeeded        = MakeSeeded;
exports.hash              = hash;
exports.seeded_hash       = seeded_hash;
exports.hash_param        = hash_param;
exports.seeded_hash_param = seeded_hash_param;
/* randomized_default Not a pure module */


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_int32              = __webpack_require__(5);
var Caml_queue              = __webpack_require__(102);
var Caml_builtin_exceptions = __webpack_require__(0);

function rotl32(x, n) {
  return (x << n) | (x >>> (32 - n | 0));
}

function mix(h, d) {
  var d$1 = d;
  d$1 = Caml_int32.imul(d$1, 3432918353);
  d$1 = rotl32(d$1, 15);
  d$1 = Caml_int32.imul(d$1, 461845907);
  var h$1 = h ^ d$1;
  h$1 = rotl32(h$1, 13);
  return (h$1 + (h$1 << 2) | 0) + 3864292196 | 0;
}

function final_mix(h) {
  var h$1 = h ^ (h >>> 16);
  h$1 = Caml_int32.imul(h$1, 2246822507);
  h$1 = h$1 ^ (h$1 >>> 13);
  h$1 = Caml_int32.imul(h$1, 3266489909);
  return h$1 ^ (h$1 >>> 16);
}

function caml_hash_mix_string(h, s) {
  var len = s.length;
  var block = (len / 4 | 0) - 1 | 0;
  var hash = h;
  for(var i = 0; i <= block; ++i){
    var j = (i << 2);
    var w = s.charCodeAt(j) | (s.charCodeAt(j + 1 | 0) << 8) | (s.charCodeAt(j + 2 | 0) << 16) | (s.charCodeAt(j + 3 | 0) << 24);
    hash = mix(hash, w);
  }
  var modulo = len & 3;
  if (modulo !== 0) {
    var w$1 = modulo === 3 ? (s.charCodeAt(len - 1 | 0) << 16) | (s.charCodeAt(len - 2 | 0) << 8) | s.charCodeAt(len - 3 | 0) : (
        modulo === 2 ? (s.charCodeAt(len - 1 | 0) << 8) | s.charCodeAt(len - 2 | 0) : s.charCodeAt(len - 1 | 0)
      );
    hash = mix(hash, w$1);
  }
  hash = hash ^ len;
  return hash;
}

function caml_hash(count, _, seed, obj) {
  var hash = seed;
  if (typeof obj === "number") {
    var u = obj | 0;
    hash = mix(hash, (u + u | 0) + 1 | 0);
    return final_mix(hash);
  } else if (typeof obj === "string") {
    hash = caml_hash_mix_string(hash, obj);
    return final_mix(hash);
  } else {
    var queue = /* record */[
      /* length */0,
      /* tail : None */0
    ];
    var num = count;
    Caml_queue.push(obj, queue);
    num = num - 1 | 0;
    while(queue[/* length */0] !== 0 && num > 0) {
      var obj$1 = Caml_queue.unsafe_pop(queue);
      if (typeof obj$1 === "number") {
        var u$1 = obj$1 | 0;
        hash = mix(hash, (u$1 + u$1 | 0) + 1 | 0);
        num = num - 1 | 0;
      } else if (typeof obj$1 === "string") {
        hash = caml_hash_mix_string(hash, obj$1);
        num = num - 1 | 0;
      } else if (typeof obj$1 !== "boolean") {
        if (typeof obj$1 !== "undefined") {
          if (typeof obj$1 === "symbol") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "caml_hash.ml",
                    135,
                    8
                  ]
                ];
          } else if (typeof obj$1 !== "function") {
            var size = obj$1.length;
            if (size !== undefined) {
              var obj_tag = obj$1.tag | 0;
              var tag = (size << 10) | obj_tag;
              if (tag === 248) {
                hash = mix(hash, obj$1[1]);
              } else {
                hash = mix(hash, tag);
                var v = size - 1 | 0;
                var block = v < num ? v : num;
                for(var i = 0; i <= block; ++i){
                  Caml_queue.push(obj$1[i], queue);
                }
              }
            }
            
          }
          
        }
        
      }
      
    };
    return final_mix(hash);
  }
}

exports.caml_hash = caml_hash;
/* No side effect */


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



function create() {
  return /* record */[
          /* length */0,
          /* tail : None */0
        ];
}

function push(x, q) {
  if (q[/* length */0]) {
    var tail = q[/* tail */1];
    var head = tail[/* next */1];
    var cell = /* record */[
      /* content */x,
      /* next */head
    ];
    q[/* length */0] = q[/* length */0] + 1 | 0;
    tail[/* next */1] = cell;
    q[/* tail */1] = cell;
    return /* () */0;
  } else {
    var cell$1 = [];
    cell$1[0] = x;
    cell$1[1] = cell$1;
    q[/* length */0] = 1;
    q[/* tail */1] = cell$1;
    return /* () */0;
  }
}

function unsafe_pop(q) {
  q[/* length */0] = q[/* length */0] - 1 | 0;
  var tail = q[/* tail */1];
  var head = tail[/* next */1];
  if (head === tail) {
    q[/* tail */1] = /* None */0;
  } else {
    tail[/* next */1] = head[/* next */1];
  }
  return head[/* content */0];
}

function is_empty(q) {
  return +(q[/* length */0] === 0);
}

exports.create     = create;
exports.push       = push;
exports.unsafe_pop = unsafe_pop;
exports.is_empty   = is_empty;
/* No side effect */


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Obj             = __webpack_require__(104);
var Curry           = __webpack_require__(1);
var Caml_exceptions = __webpack_require__(11);

var Undefined = Caml_exceptions.create("CamlinternalLazy.Undefined");

function raise_undefined() {
  throw Undefined;
}

function force_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  try {
    var result = Curry._1(closure, /* () */0);
    blk[0] = result;
    blk.tag = Obj.forward_tag;
    return result;
  }
  catch (e){
    blk[0] = (function () {
        throw e;
      });
    throw e;
  }
}

function force_val_lazy_block(blk) {
  var closure = blk[0];
  blk[0] = raise_undefined;
  var result = Curry._1(closure, /* () */0);
  blk[0] = result;
  blk.tag = Obj.forward_tag;
  return result;
}

function force(lzv) {
  var t = lzv.tag | 0;
  if (t === Obj.forward_tag) {
    return lzv[0];
  } else if (t !== Obj.lazy_tag) {
    return lzv;
  } else {
    return force_lazy_block(lzv);
  }
}

function force_val(lzv) {
  var t = lzv.tag | 0;
  if (t === Obj.forward_tag) {
    return lzv[0];
  } else if (t !== Obj.lazy_tag) {
    return lzv;
  } else {
    return force_val_lazy_block(lzv);
  }
}

exports.Undefined            = Undefined;
exports.force_lazy_block     = force_lazy_block;
exports.force_val_lazy_block = force_val_lazy_block;
exports.force                = force;
exports.force_val            = force_val;
/* No side effect */


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Marshal                 = __webpack_require__(105);
var Caml_array              = __webpack_require__(7);
var Caml_missing_polyfill   = __webpack_require__(28);
var Caml_builtin_exceptions = __webpack_require__(0);

var double_field = Caml_array.caml_array_get;

var set_double_field = Caml_array.caml_array_set;

function marshal() {
  return Caml_missing_polyfill.not_implemented("caml_output_value_to_string not implemented by bucklescript yet\n");
}

function unmarshal(str, pos) {
  return /* tuple */[
          Marshal.from_bytes(str, pos),
          pos + Marshal.total_size(str, pos) | 0
        ];
}

function extension_slot(x) {
  var slot = x.length !== undefined && (x.tag | 0) !== 248 && x.length >= 1 ? x[0] : x;
  var name;
  if (slot.length !== undefined && slot.tag === 248) {
    name = slot[0];
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
  if (name.tag === 252) {
    return slot;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function extension_name(x) {
  try {
    var slot = extension_slot(x);
    return slot[0];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_name"
          ];
    } else {
      throw exn;
    }
  }
}

function extension_id(x) {
  try {
    var slot = extension_slot(x);
    return slot[1];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_id"
          ];
    } else {
      throw exn;
    }
  }
}

function extension_slot$1(x) {
  try {
    return extension_slot(x);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Obj.extension_slot"
          ];
    } else {
      throw exn;
    }
  }
}

var first_non_constant_constructor_tag = 0;

var last_non_constant_constructor_tag = 245;

var lazy_tag = 246;

var closure_tag = 247;

var object_tag = 248;

var infix_tag = 249;

var forward_tag = 250;

var no_scan_tag = 251;

var abstract_tag = 251;

var string_tag = 252;

var double_tag = 253;

var double_array_tag = 254;

var custom_tag = 255;

var final_tag = 255;

var int_tag = 1000;

var out_of_heap_tag = 1001;

var unaligned_tag = 1002;

exports.double_field                       = double_field;
exports.set_double_field                   = set_double_field;
exports.first_non_constant_constructor_tag = first_non_constant_constructor_tag;
exports.last_non_constant_constructor_tag  = last_non_constant_constructor_tag;
exports.lazy_tag                           = lazy_tag;
exports.closure_tag                        = closure_tag;
exports.object_tag                         = object_tag;
exports.infix_tag                          = infix_tag;
exports.forward_tag                        = forward_tag;
exports.no_scan_tag                        = no_scan_tag;
exports.abstract_tag                       = abstract_tag;
exports.string_tag                         = string_tag;
exports.double_tag                         = double_tag;
exports.double_array_tag                   = double_array_tag;
exports.custom_tag                         = custom_tag;
exports.final_tag                          = final_tag;
exports.int_tag                            = int_tag;
exports.out_of_heap_tag                    = out_of_heap_tag;
exports.unaligned_tag                      = unaligned_tag;
exports.extension_name                     = extension_name;
exports.extension_id                       = extension_id;
exports.extension_slot                     = extension_slot$1;
exports.marshal                            = marshal;
exports.unmarshal                          = unmarshal;
/* No side effect */


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Caml_string             = __webpack_require__(6);
var Caml_missing_polyfill   = __webpack_require__(28);
var Caml_builtin_exceptions = __webpack_require__(0);

function to_buffer(buff, ofs, len, _, _$1) {
  if (ofs < 0 || len < 0 || ofs > (buff.length - len | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.to_buffer: substring out of bounds"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_output_value_to_buffer not implemented by bucklescript yet\n");
  }
}

function data_size(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.data_size"
        ];
  } else {
    return Caml_missing_polyfill.not_implemented("caml_marshal_data_size not implemented by bucklescript yet\n");
  }
}

function total_size(buff, ofs) {
  return 20 + data_size(buff, ofs) | 0;
}

function from_bytes(buff, ofs) {
  if (ofs < 0 || ofs > (buff.length - 20 | 0)) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Marshal.from_bytes"
        ];
  } else {
    var len = Caml_missing_polyfill.not_implemented("caml_marshal_data_size not implemented by bucklescript yet\n");
    if (ofs > (buff.length - (20 + len | 0) | 0)) {
      throw [
            Caml_builtin_exceptions.invalid_argument,
            "Marshal.from_bytes"
          ];
    } else {
      return Caml_missing_polyfill.not_implemented("caml_input_value_from_string not implemented by bucklescript yet\n");
    }
  }
}

function from_string(buff, ofs) {
  return from_bytes(Caml_string.bytes_of_string(buff), ofs);
}

function to_channel(_, _$1, _$2) {
  return Caml_missing_polyfill.not_implemented("caml_output_value not implemented by bucklescript yet\n");
}

function from_channel() {
  return Caml_missing_polyfill.not_implemented("caml_input_value not implemented by bucklescript yet\n");
}

var header_size = 20;

exports.to_channel   = to_channel;
exports.to_buffer    = to_buffer;
exports.from_channel = from_channel;
exports.from_bytes   = from_bytes;
exports.from_string  = from_string;
exports.header_size  = header_size;
exports.data_size    = data_size;
exports.total_size   = total_size;
/* No side effect */


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry     = __webpack_require__(1);
var Snake     = __webpack_require__(107);
var Hashtbl   = __webpack_require__(100);
var Caml_obj  = __webpack_require__(4);
var Immutable = __webpack_require__(86);

function step(state) {
  var tiles = state[/* tiles */0];
  var match = Snake.move(state[/* snake */2], state[/* size */1]);
  var cleared = match[1];
  var tiles$1 = cleared ? Curry._3(Immutable.HashMap[/* put */32], cleared[0], /* Empty */0, tiles) : tiles;
  var tiles$2 = Curry._3(Immutable.HashMap[/* put */32], match[2], /* SnakeBody */3, tiles$1);
  var tiles$3 = Curry._3(Immutable.HashMap[/* put */32], match[3], /* SnakeHead */4, tiles$2);
  return /* record */[
          /* tiles */tiles$3,
          /* size */state[/* size */1],
          /* snake */match[0]
        ];
}

function makeBoard(w, h) {
  var res = /* [] */0;
  for(var x = 0 ,x_finish = w - 1 | 0; x <= x_finish; ++x){
    for(var y = 0 ,y_finish = h - 1 | 0; y <= y_finish; ++y){
      res = /* :: */[
        /* tuple */[
          /* tuple */[
            x,
            y
          ],
          /* Empty */0
        ],
        res
      ];
    }
  }
  return res;
}

function addSnake(snake, board) {
  var board$1 = Curry._4(Immutable.Vector[/* reduce */30], /* None */0, (function (board, pos) {
          return Curry._3(Immutable.HashMap[/* put */32], pos, /* SnakeBody */3, board);
        }), board, snake[/* body */0]);
  return Curry._3(Immutable.HashMap[/* put */32], snake[/* head */1], /* SnakeHead */4, board$1);
}

function universalCompare(x, y) {
  var c = Caml_obj.caml_compare(x, y);
  var match = +(c < 0);
  if (match !== 0) {
    return Immutable.Ordering[/* lessThan */2];
  } else {
    var match$1 = +(c > 0);
    if (match$1 !== 0) {
      return Immutable.Ordering[/* greaterThan */1];
    } else {
      return Immutable.Ordering[/* equal */0];
    }
  }
}

function initialState(param) {
  var h = param[1];
  var w = param[0];
  var snake = Snake.initial(/* tuple */[
        w,
        h
      ]);
  return /* record */[
          /* tiles */addSnake(snake, Curry._3(Immutable.HashMap[/* fromEntriesWith */37], Hashtbl.hash, universalCompare, Curry._1(Immutable.List[/* toIterable */7], makeBoard(w, h)))),
          /* size : tuple */[
            w,
            h
          ],
          /* snake */snake
        ];
}

var HashMap = 0;

var Vector = 0;

exports.HashMap          = HashMap;
exports.Vector           = Vector;
exports.step             = step;
exports.makeBoard        = makeBoard;
exports.addSnake         = addSnake;
exports.universalCompare = universalCompare;
exports.initialState     = initialState;
/* Snake Not a pure module */


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Curry     = __webpack_require__(1);
var Immutable = __webpack_require__(86);

function directionToPos(direction) {
  switch (direction) {
    case 0 : 
        return /* tuple */[
                0,
                -1
              ];
    case 1 : 
        return /* tuple */[
                0,
                1
              ];
    case 2 : 
        return /* tuple */[
                -1,
                0
              ];
    case 3 : 
        return /* tuple */[
                1,
                0
              ];
    
  }
}

function initial() {
  return /* record */[
          /* body */Curry._2(Immutable.Vector[/* init */56], 5, (function (x) {
                  return /* tuple */[
                          x,
                          5
                        ];
                })),
          /* head : tuple */[
            5,
            5
          ],
          /* direction : Right */3
        ];
}

function wrap(n, max) {
  var match = +(n < 0);
  if (match !== 0) {
    return n + max | 0;
  } else {
    var match$1 = +(n >= max);
    if (match$1 !== 0) {
      return n - max | 0;
    } else {
      return n;
    }
  }
}

function calcNextHead(param, direction, param$1) {
  var match = directionToPos(direction);
  return /* tuple */[
          wrap(param[0] + match[0] | 0, param$1[0]),
          wrap(param[1] + match[1] | 0, param$1[1])
        ];
}

function move(param, size) {
  var direction = param[/* direction */2];
  var body = param[/* body */0];
  var last = Curry._1(Immutable.Vector[/* firstOrRaise */39], body);
  var length = Curry._1(Immutable.Vector[/* count */33], body);
  var head = Curry._2(Immutable.Vector[/* getOrRaise */2], length - 1 | 0, body);
  var nextHead = calcNextHead(head, direction, size);
  var body$1 = Curry._2(Immutable.Vector[/* skip */50], 1, body);
  var body$2 = Curry._2(Immutable.Vector[/* addLast */44], nextHead, body$1);
  return /* tuple */[
          /* record */[
            /* body */body$2,
            /* head */head,
            /* direction */direction
          ],
          /* Some */[last],
          head,
          nextHead
        ];
}

var Vector = 0;

exports.Vector         = Vector;
exports.directionToPos = directionToPos;
exports.initial        = initial;
exports.wrap           = wrap;
exports.calcNextHead   = calcNextHead;
exports.move           = move;
/* Immutable Not a pure module */


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Generated by BUCKLESCRIPT VERSION 1.8.2, PLEASE EDIT WITH CARE


var Reprocessing_Constants = __webpack_require__(14);

function tileColor(tile) {
  if (typeof tile === "number") {
    switch (tile) {
      case 0 : 
          return Reprocessing_Constants.white;
      case 1 : 
      case 2 : 
          return Reprocessing_Constants.black;
      case 3 : 
          return Reprocessing_Constants.red;
      case 4 : 
          return Reprocessing_Constants.green;
      
    }
  } else {
    return Reprocessing_Constants.black;
  }
}

var Constants = 0;

exports.Constants = Constants;
exports.tileColor = tileColor;
/* Reprocessing_Constants Not a pure module */


/***/ })
/******/ ]);